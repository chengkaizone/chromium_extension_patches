From 2beea45c254b0108f08281d98bb11eeba39f1f72 Mon Sep 17 00:00:00 2001
From: Dmitry Valter <dvalter@protonmail.com>
Date: Sun, 10 May 2020 13:26:05 +0300
Subject: [PATCH] (Almost) Correct Kiwi extension patch for Chromium
 80.0.3987.58

---
 AUTHORS                                            |   2 +
 BUILD.gn                                           |   2 +-
 DEPS                                               |   2 +-
 GN_ARGS                                            |  45 ++
 LICENSE-GPLV3                                      | 674 ++++++++++++++++
 apps/BUILD.gn                                      |   2 +-
 build/config/compiler/BUILD.gn                     |   4 +-
 build/config/compiler/compiler.gni                 |   6 +-
 chrome/BUILD.gn                                    |   4 +-
 .../tasks/tab_groups/TabGroupModelFilter.java      |   7 +
 .../chrome/browser/ChromeTabbedActivity.java       |   2 +
 .../chrome/browser/tabmodel/ChromeTabCreator.java  |  26 +
 .../chrome/browser/tabmodel/EmptyTabModel.java     |   5 +
 .../browser/tabmodel/EmptyTabModelFilter.java      |   6 +
 .../chrome/browser/tabmodel/IncognitoTabModel.java |   5 +
 .../chrome/browser/tabmodel/SingleTabModel.java    |   5 +
 .../chrome/browser/tabmodel/TabCreatorManager.java |   3 +
 .../chromium/chrome/browser/tabmodel/TabList.java  |   4 +-
 .../chrome/browser/tabmodel/TabModelImpl.java      |  35 +
 .../chrome/browser/tabmodel/TabModelJniBridge.java |   4 +
 chrome/app/android/chrome_main_delegate_android.cc |  11 +-
 chrome/app/bookmarks_strings.grdp                  |   6 +-
 chrome/app/chrome_main_delegate.cc                 |  13 +
 chrome/app/chromium_strings.grd                    |  20 +-
 chrome/app/generated_resources.grd                 |  77 +-
 chrome/app/google_chrome_strings.grd               |  20 +-
 chrome/app/profiles_strings.grdp                   |  11 +-
 chrome/app/theme/theme_resources.grd               |  28 +-
 chrome/browser/BUILD.gn                            |  50 +-
 chrome/browser/android/appmenu/app_menu.cc         | 333 ++++++++
 chrome/browser/apps/platform_apps/BUILD.gn         |   1 -
 .../api/music_manager_private/BUILD.gn             |   1 +
 .../api/music_manager_private/device_id_android.cc | 188 +++++
 .../background_contents_service_factory.cc         |   3 +
 .../browser/background/background_mode_manager.cc  |   1 -
 .../background/background_mode_manager_android.cc  |  24 +
 chrome/browser/browser_process_impl.cc             |   4 +
 chrome/browser/browser_resources.grd               |  29 +-
 .../browser_switcher/browser_switcher_service.cc   |   3 +-
 chrome/browser/chrome_browser_main.cc              |  22 +
 chrome/browser/chrome_browser_main_android.cc      |   2 +
 chrome/browser/chrome_browser_main_posix.cc        |   2 +-
 chrome/browser/chrome_content_browser_client.cc    |   9 +-
 .../content_settings/cookie_settings_factory.cc    |   1 +
 .../host_content_settings_map_factory.cc           |   4 +-
 ...register_protocol_handler_permission_request.cc |  28 +-
 .../register_protocol_handler_permission_request.h |   2 +
 chrome/browser/devtools/BUILD.gn                   |  10 +-
 chrome/browser/devtools/devtools_ui_bindings.cc    |   4 +
 chrome/browser/download/download_commands.cc       |  17 +-
 chrome/browser/download/download_commands.h        |   4 +-
 .../browser/download/download_crx_util_android.cc  |  23 -
 chrome/browser/download/download_danger_prompt.cc  |   5 -
 .../download/download_shelf_context_menu.cc        |  17 -
 chrome/browser/download/download_ui_model.cc       |   4 +-
 chrome/browser/download/download_ui_model.h        |   4 +-
 .../browser/download/drag_download_item_android.cc |  35 +
 chrome/browser/download/drag_download_item_aura.cc |   2 +
 chrome/browser/enterprise_reporting/policy_info.cc |   2 +
 chrome/browser/extensions/BUILD.gn                 |   7 +-
 .../bookmark_manager_private_api.cc                |   5 -
 .../api/browsing_data/browsing_data_api.cc         |  15 +-
 .../api/content_settings/content_settings_api.cc   |   4 +
 .../chrome_desktop_report_request_helper.cc        |   7 +-
 .../removable_storage_provider_android.cc          |  19 +
 .../api/music_manager_private/device_id_android.cc | 184 +++++
 .../networking_private_ui_delegate_factory_impl.cc |   3 +
 .../api/resources_private/resources_private_api.cc |   2 +
 .../safe_browsing_private_event_router.cc          |   5 +
 chrome/browser/extensions/api/tabs/tabs_api.cc     | 329 +++++++-
 .../extensions/api/tabs/tabs_event_router.cc       |  40 +-
 .../extensions/api/tabs/tabs_event_router.h        |   7 +-
 .../extensions/api/tabs/windows_event_router.cc    |   2 -
 chrome/browser/extensions/bookmark_app_helper.cc   | 868 +++++++++++++++++++++
 .../extensions/chrome_extensions_browser_client.cc |   7 +
 .../extensions/chrome_process_manager_delegate.cc  |   1 +
 .../browser/extensions/extension_install_prompt.cc |  64 ++
 .../browser/extensions/extension_install_prompt.h  |   4 +
 .../extension_install_prompt_show_params.cc        |   4 -
 .../extensions/extension_uninstall_dialog.cc       |   2 +
 .../extensions/global_shortcut_listener_android.cc |  64 ++
 .../extensions/global_shortcut_listener_android.h  |  36 +
 .../display_info_provider_android.cc               |  17 +
 .../system_display/display_info_provider_android.h |  24 +
 chrome/browser/first_run/first_run_dialog.h        |   2 +-
 .../first_run/first_run_internal_android.cc        |  24 +
 .../browser/first_run/first_run_internal_posix.cc  |   2 +-
 chrome/browser/first_run/upgrade_util.cc           |   2 +-
 chrome/browser/first_run/upgrade_util.h            |   4 -
 chrome/browser/flag_descriptions.cc                |   2 -
 chrome/browser/flag_descriptions.h                 |   2 -
 .../chrome_web_view_permission_helper_delegate.cc  |   2 +
 .../chrome_web_view_permission_helper_delegate.h   |   4 +-
 chrome/browser/media/router/BUILD.gn               |   2 +-
 chrome/browser/media/router/discovery/BUILD.gn     |   4 +-
 .../discovery/dial/dial_media_sink_service_impl.cc |  10 +-
 .../router/discovery/discovery_network_monitor.cc  |   4 +-
 .../discovery/mdns/cast_media_sink_service_impl.cc |  20 +-
 chrome/browser/media/router/media_router.h         |   4 +-
 chrome/browser/media/router/media_router_base.cc   |   2 +-
 chrome/browser/media/router/media_router_base.h    |   4 +-
 .../browser/media/router/media_router_feature.cc   |   6 +-
 chrome/browser/media/router/media_router_feature.h |   2 +-
 .../router/providers/cast/cast_activity_manager.cc |  30 +-
 .../router/providers/cast/cast_activity_record.cc  |   4 +-
 .../cast/cast_app_availability_tracker.cc          |   4 +-
 .../providers/cast/cast_app_discovery_service.cc   |   4 +
 .../providers/cast/cast_media_route_provider.cc    |  11 +-
 .../providers/cast/mirroring_activity_record.cc    |   2 +-
 .../webrtc/media_capture_devices_dispatcher.cc     |   7 -
 .../browser/metrics/chrome_feature_list_creator.cc |   6 +
 .../fullscreen_notification_blocker.cc             |   2 +-
 .../notification_display_service_impl.cc           |  18 -
 .../obsolete_system/obsolete_system_android.cc     |  25 +
 .../permissions/attestation_permission_request.cc  |  12 +-
 chrome/browser/platform_util.cc                    |  42 -
 chrome/browser/platform_util_android.cc            |   4 +
 chrome/browser/plugins/plugins_resource_service.cc |   2 +-
 chrome/browser/policy/BUILD.gn                     |   1 +
 .../policy/browser_dm_token_storage_android.cc     | 191 +++++
 .../policy/browser_dm_token_storage_android.h      |  58 ++
 .../policy/chrome_browser_policy_connector.cc      |   2 +-
 .../configuration_policy_handler_list_factory.cc   |   2 +-
 .../browser/policy/policy_path_parser_android.cc   |  71 ++
 chrome/browser/prefs/browser_prefs.cc              |  50 +-
 .../browser/prefs/chrome_pref_service_factory.cc   |   2 +-
 .../chrome_browser_main_extra_parts_profiles.cc    | 114 ++-
 .../chrome_browser_main_extra_parts_profiles.h     |   2 +-
 .../profiles/off_the_record_profile_impl.cc        |  11 +-
 .../browser/profiles/off_the_record_profile_impl.h |  10 +-
 chrome/browser/profiles/profile.cc                 |   4 +-
 chrome/browser/profiles/profile.h                  |   6 +-
 chrome/browser/profiles/profile_impl.cc            |  11 +-
 chrome/browser/profiles/profile_impl.h             |   6 +-
 chrome/browser/profiles/profile_manager.cc         |  12 +-
 chrome/browser/profiles/profile_manager.h          |   6 +-
 chrome/browser/profiles/profile_metrics.cc         |   8 +-
 chrome/browser/profiles/profile_metrics.h          |   2 +-
 chrome/browser/profiles/profile_window.cc          |   4 +-
 chrome/browser/profiles/profile_window.h           |   4 -
 chrome/browser/profiles/profiles_state.cc          |   4 +-
 chrome/browser/profiles/profiles_state.h           |   2 +-
 .../render_view_context_menu.cc                    |  12 +-
 .../render_view_context_menu.h                     |   2 +
 .../resource_coordinator_parts.cc                  |   4 +-
 .../resource_coordinator_parts.h                   |  12 +-
 chrome/browser/resource_coordinator/tab_helper.cc  |   4 +-
 chrome/browser/resource_coordinator/tab_helper.h   |   4 +-
 .../tab_manager_web_contents_data.cc               |   3 +
 chrome/browser/resources/BUILD.gn                  |   6 +-
 .../resources/md_extensions/extensions.html        |  47 ++
 chrome/browser/resources/unpack_pak.py             |   4 +
 chrome/browser/search/instant_service.h            |   4 -
 chrome/browser/search/instant_service_factory.h    |   4 -
 chrome/browser/search/instant_service_observer.h   |   4 -
 chrome/browser/search/local_ntp_source.h           |   4 -
 chrome/browser/search/most_visited_iframe_source.h |   4 -
 chrome/browser/sharing/click_to_call/feature.cc    |   2 +-
 chrome/browser/sharing/click_to_call/feature.h     |   2 +-
 .../sharing/shared_clipboard/feature_flags.cc      |   2 +-
 .../sharing/shared_clipboard/feature_flags.h       |   2 +-
 .../signin/account_consistency_mode_manager.cc     |   6 +-
 chrome/browser/signin/chrome_signin_helper.cc      |   2 +-
 .../spellchecker/spelling_service_client.cc        | 343 ++++++++
 chrome/browser/startup_data.cc                     |  25 +-
 .../supervised_user/supervised_user_service.cc     |   2 +
 .../browser/sync/profile_sync_service_factory.cc   |  33 +-
 chrome/browser/touch_to_fill/android/BUILD.gn      |   1 +
 chrome/browser/ui/BUILD.gn                         | 102 +--
 .../browser/ui/android/appmenu/internal/BUILD.gn   |  23 +
 .../chrome/browser/ui/appmenu/AppMenu.java         | 154 +++-
 .../browser/ui/appmenu/AppMenuCoordinatorImpl.java |   7 +-
 .../browser/ui/appmenu/AppMenuHandlerImpl.java     |  15 +-
 chrome/browser/ui/android/tab_model/tab_model.h    |   1 +
 .../ui/android/tab_model/tab_model_jni_bridge.cc   |   5 +
 .../ui/android/tab_model/tab_model_jni_bridge.h    |   1 +
 .../browser/ui/bookmarks/bookmark_utils_desktop.cc |   9 +-
 chrome/browser/ui/browser.cc                       |  10 +-
 chrome/browser/ui/browser.h                        |   2 +
 chrome/browser/ui/browser_command_controller.cc    |   4 -
 chrome/browser/ui/browser_commands.cc              |   1 -
 ...rowser_content_setting_bubble_model_delegate.cc |   2 +-
 chrome/browser/ui/browser_instant_controller.h     |   4 -
 chrome/browser/ui/browser_list.cc                  |   3 +-
 chrome/browser/ui/browser_navigator_params.cc      |   4 +-
 chrome/browser/ui/browser_navigator_params.h       |   6 +-
 chrome/browser/ui/browser_otr_state.cc             |   4 -
 chrome/browser/ui/browser_ui_prefs.cc              |   2 +-
 chrome/browser/ui/browser_window.h                 |   4 -
 chrome/browser/ui/chrome_pages.cc                  |   4 +-
 chrome/browser/ui/chrome_pages.h                   |   4 +-
 .../content_setting_bubble_model.cc                |   3 +
 .../content_setting_bubble_model.h                 |   2 +-
 .../ui/exclusive_access/fullscreen_controller.cc   |   4 +
 .../ui/extensions/extension_install_ui_default.cc  |   2 +
 .../ui/extensions/icon_with_badge_image_source.h   |   5 +
 chrome/browser/ui/fast_unload_controller.cc        | 487 ++++++++++++
 chrome/browser/ui/native_window_tracker_android.cc |  26 +
 chrome/browser/ui/native_window_tracker_android.h  |  26 +
 chrome/browser/ui/page_info/page_info_ui.cc        |  10 +-
 chrome/browser/ui/page_info/page_info_ui.h         |   4 +-
 .../ui/passwords/manage_passwords_view_utils.cc    |   4 +-
 .../ui/passwords/manage_passwords_view_utils.h     |   1 +
 .../settings/password_manager_presenter.cc         |   4 +-
 .../ui/screen_capture_notification_ui_stub.cc      |   2 +
 chrome/browser/ui/search/instant_controller.h      |   4 -
 chrome/browser/ui/search/ntp_user_data_logger.h    |   4 -
 chrome/browser/ui/search/search_ipc_router.h       |   4 -
 .../ui/search/search_ipc_router_policy_impl.h      |   4 -
 chrome/browser/ui/search/search_tab_helper.h       |   4 -
 chrome/browser/ui/signin_view_controller.h         |   2 +
 .../chrome_web_contents_view_handle_drop.cc        |   2 +
 chrome/browser/ui/tab_helpers.cc                   |   2 +
 chrome/browser/ui/tabs/tab_strip_model.cc          |  19 +-
 chrome/browser/ui/tabs/tab_strip_model.h           |   4 -
 .../toolbar/component_toolbar_actions_factory.cc   |  59 ++
 chrome/browser/ui/unload_controller.cc             |  35 +-
 chrome/browser/ui/views/BUILD.gn                   |   2 -
 .../browser/ui/views/accelerator_utils_android.cc  |  30 +
 .../autofill/autofill_popup_view_native_views.cc   |  10 +-
 .../ui/views/bookmarks/bookmark_drag_drop_views.cc |   3 +-
 chrome/browser/ui/views/browser_dialogs_views.cc   |  11 -
 .../ui/views/chrome_views_delegate_android.cc      |  15 +
 .../desktop_capture/desktop_media_list_view.cc     |   2 +-
 .../desktop_capture/desktop_media_picker_views.cc  |   3 +-
 .../ui/views/download/download_item_view.cc        |   2 +
 .../browser/ui/views/dropdown_bar_host_android.cc  |  10 +
 chrome/browser/ui/views/find_bar_host.cc           |   4 -
 chrome/browser/ui/views/frame/browser_frame.cc     |   3 +
 .../browser_non_client_frame_view_factory_views.cc |   1 -
 chrome/browser/ui/views/frame/browser_root_view.cc |   8 +-
 chrome/browser/ui/views/frame/browser_view.cc      |  21 +-
 .../ui/views/frame/browser_window_factory.cc       |  10 -
 .../views/frame/desktop_browser_frame_android.cc   |  75 ++
 .../ui/views/frame/desktop_browser_frame_android.h |  63 ++
 .../frame/native_browser_frame_factory_android.cc  |  13 +
 chrome/browser/ui/views/javascript_dialog_views.cc |   2 +
 .../ui/views/location_bar/location_bar_view.cc     |  25 +-
 .../ui/views/location_bar/location_bar_view.h      |   2 +
 .../views/omnibox/omnibox_popup_contents_view.cc   |   2 +-
 .../permission_prompt_bubble_view.cc               |   2 +
 .../permission_bubble/permission_prompt_impl.cc    |   2 +
 chrome/browser/ui/views/profiles/avatar_button.cc  | 559 +++++++++++++
 .../browser/ui/views/profiles/profile_menu_view.cc |   2 +
 .../relaunch_notification_controller.cc            |   2 +
 .../password_reuse_modal_warning_dialog.cc         |   8 +
 chrome/browser/ui/views/tabs/tab_strip.cc          |  12 -
 .../browser/ui/views/tabs/window_finder_android.cc |  15 +
 .../ui/webui/chrome_web_ui_controller_factory.cc   |   2 +
 chrome/browser/ui/webui/devtools_ui_data_source.cc |   2 +
 chrome/browser/ui/webui/discards/BUILD.gn          |   2 +-
 .../ui/webui/media_router/media_router_ui.cc       | 716 +++++++++++++++++
 chrome/browser/ui/webui/settings/about_handler.cc  |   2 +
 .../ui/webui/settings/change_password_handler.cc   |  15 -
 .../browser/ui/webui/settings/printing_handler.cc  |   2 +
 .../ui/webui/settings/safety_check_handler.cc      |   2 +
 .../settings_localized_strings_provider.cc         |   3 +-
 chrome/browser/ui/webui/settings/system_handler.cc |   2 +-
 .../ui/webui/signin/inline_login_handler_impl.cc   |   4 +
 .../ui/window_sizer/window_sizer_android.cc        |  17 +
 chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc  |  29 +-
 chrome/browser/web_applications/BUILD.gn           |   3 -
 .../browser/web_applications/components/BUILD.gn   |  11 +-
 .../components/web_app_shortcut_android.cc         | 122 +++
 .../components/web_app_shortcut_android.h          |  62 ++
 .../browser/web_applications/extensions/BUILD.gn   |   3 -
 .../extensions/web_app_extension_shortcut.cc       |  10 +-
 chrome/browser/web_applications/web_app_android.cc |  44 ++
 chrome/chrome_paks.gni                             |  38 +-
 chrome/common/BUILD.gn                             |   3 +-
 chrome/common/chrome_features.cc                   |  15 +-
 chrome/common/chrome_features.h                    |   8 +-
 chrome/common/chrome_paths.cc                      |   2 +-
 chrome/common/chrome_paths.h                       |   2 +-
 chrome/common/chrome_switches.cc                   |   2 +-
 chrome/common/chrome_switches.h                    |   2 +-
 chrome/common/extensions/api/api_sources.gni       |   2 +-
 chrome/common/features.gni                         |   4 +-
 chrome/common/importer/BUILD.gn                    |   1 +
 .../importer/firefox_importer_utils_android.cc     |  25 +
 chrome/common/media_router/BUILD.gn                |   2 +-
 chrome/common/pref_names.cc                        |  26 +-
 chrome/common/pref_names.h                         |  26 +-
 chrome/common/url_constants.cc                     |   4 +-
 chrome/common/url_constants.h                      |   4 +-
 chrome/common/webui_url_constants.cc               |   4 +-
 chrome/common/webui_url_constants.h                |   4 +-
 chrome/renderer/BUILD.gn                           |  20 +-
 chrome/renderer/chrome_content_renderer_client.cc  |   4 +-
 chrome/renderer/content_settings_agent_impl.cc     |   3 +-
 chrome/renderer/media/chrome_key_systems.cc        |   2 +-
 chrome/test/BUILD.gn                               |   2 +-
 chromecast/browser/cast_browser_context.cc         |   2 +-
 chromecast/browser/cast_browser_context.h          |   2 +-
 components/BUILD.gn                                |   2 +-
 components/autofill_payments_strings.grdp          |  12 +-
 components/autofill_strings.grdp                   |   2 +-
 components/bookmarks/browser/BUILD.gn              |   2 +-
 components/bookmarks/browser/bookmark_node_data.h  |   8 +-
 components/components_strings.grd                  |   4 +-
 .../core/browser/cookie_settings.cc                |   1 +
 .../feature_engagement/public/event_constants.cc   |   4 +-
 .../feature_engagement/public/event_constants.h    |   4 +-
 .../feature_engagement/public/feature_constants.cc |   2 +-
 .../feature_engagement/public/feature_constants.h  |   2 +-
 components/guest_view/browser/BUILD.gn             |   2 +-
 components/guest_view/renderer/BUILD.gn            |   2 +-
 components/history_strings.grdp                    |   2 +-
 components/keep_alive_registry/BUILD.gn            |   2 +-
 components/new_or_sad_tab_strings.grdp             |   2 +-
 components/page_info_strings.grdp                  |  10 +-
 components/payments/content/payment_request.cc     |   2 +-
 components/payments/content/payment_request.h      |   2 +-
 components/payments_strings.grdp                   |   2 +-
 components/pdf/renderer/BUILD.gn                   |   2 +-
 components/pdf_strings.grdp                        |   2 +-
 .../core/browser/configuration_policy_handler.cc   |   1 +
 components/policy/resources/policy_templates.json  |  10 +-
 components/prefs/pref_service.cc                   |   4 +
 components/search/search.cc                        |   4 -
 components/signin/features.gni                     |   2 +-
 components/storage_monitor/storage_monitor.cc      |   4 +-
 components/sync_ui_strings.grdp                    |   2 +-
 components/ui_devtools/views/BUILD.gn              |   7 +
 components/ui_devtools/views/dom_agent_android.cc  |  44 ++
 components/ui_devtools/views/dom_agent_android.h   |  32 +
 .../ui_devtools/views/overlay_agent_android.cc     |  44 ++
 .../ui_devtools/views/overlay_agent_android.h      |  36 +
 .../ui_devtools/views/overlay_agent_views.cc       |   4 -
 components/url_formatter/elide_url.cc              |   4 +-
 components/url_formatter/elide_url.h               |   2 +-
 components/web_modal/BUILD.gn                      |   2 +-
 components/zoom/BUILD.gn                           |   2 +-
 content/app/content_main_runner_impl.cc            |  33 +
 .../app/content_service_manager_main_delegate.cc   |   2 +
 content/browser/BUILD.gn                           |  16 +-
 content/browser/browser_main.cc                    |   4 +
 content/browser/browser_main_loop.cc               |  28 +
 content/browser/browser_main_runner_impl.cc        |   3 +
 .../compositor/gpu_process_transport_factory.cc    |   8 -
 content/browser/devtools/BUILD.gn                  |   2 +-
 .../frame_host/navigation_controller_impl.cc       |   4 +
 content/browser/frame_host/navigation_request.cc   |   2 +
 .../pepper/pepper_truetype_font_android.cc         |  78 ++
 .../pepper/pepper_truetype_font_list_android.cc    |  20 +
 .../browser/renderer_host/render_view_host_impl.cc |   6 +-
 content/browser/storage_partition_impl.cc          |   5 +-
 content/browser/storage_partition_impl.h           |   6 +-
 content/browser/web_contents/web_contents_impl.cc  |   8 +-
 content/browser/web_contents/web_contents_impl.h   |   6 +-
 .../browser/webui/shared_resources_data_source.cc  |   6 +-
 content/child/child_process.cc                     |   5 +
 content/public/browser/browser_context.h           |   4 +-
 content/public/browser/content_browser_client.cc   |   2 +-
 content/public/browser/content_browser_client.h    |   2 +-
 content/public/browser/desktop_media_id.cc         |   4 +-
 content/public/browser/desktop_media_id.h          |   2 +-
 content/public/browser/storage_partition.h         |   4 +-
 content/public/common/pepper_plugin_info.h         |   2 +
 content/shell/BUILD.gn                             |   2 +-
 content/shell/browser/shell_browser_context.cc     |   2 +-
 content/shell/browser/shell_browser_context.h      |   4 +-
 extensions/BUILD.gn                                |  36 -
 extensions/browser/api/BUILD.gn                    |   2 +-
 extensions/browser/api/api_resource_manager.h      |   8 +
 .../browser/api/messaging/message_service.cc       |   2 +-
 extensions/browser/api/socket/tcp_socket.cc        | 104 +--
 extensions/browser/api/socket/tcp_socket.h         |   2 -
 extensions/browser/api/system_cpu/BUILD.gn         |   1 +
 .../api/system_cpu/cpu_info_provider_android.cc    |  77 ++
 extensions/browser/extensions_browser_client.cc    |   1 +
 .../browser/guest_view/web_view/web_view_guest.cc  |   1 +
 extensions/buildflags/buildflags.gni               |   2 +-
 google_apis/BUILD.gn                               |   2 +-
 mojo/public/js/mojo_bindings_resources.grd         |   2 +-
 net/url_request/url_request_http_job.cc            |   4 +
 services/device/public/cpp/hid/BUILD.gn            |   2 +-
 services/service_manager/embedder/main.cc          |  27 +
 .../public/cpp/perfetto/perfetto_traced_process.cc |   5 +
 services/tracing/public/cpp/trace_startup.cc       |   4 +
 third_party/blink/public/mojom/BUILD.gn            |   2 +-
 third_party/libavif/src                            |   1 +
 third_party/libgav1/src                            |   1 +
 third_party/pywebsocket3/src                       |   1 +
 third_party/sqlite/src                             |   1 +
 third_party/turbine/src                            |   1 +
 third_party/webgpu-cts/src                         |   1 +
 third_party/weston/src                             |   1 +
 ui/android/window_android.h                        |   8 +
 ui/base/BUILD.gn                                   |  17 +-
 ui/base/cursor/cursor.cc                           |   2 +-
 ui/base/dragdrop/os_exchange_data.cc               |   4 +-
 ui/base/dragdrop/os_exchange_data.h                |   8 +-
 .../dragdrop/os_exchange_data_provider_android.cc  | 220 ++++++
 .../dragdrop/os_exchange_data_provider_android.h   | 101 +++
 .../dragdrop/os_exchange_data_provider_factory.cc  |   4 +-
 ui/events/event.h                                  |   1 +
 ui/gfx/BUILD.gn                                    |   7 -
 ui/gfx/animation/BUILD.gn                          |   2 +-
 ui/message_center/BUILD.gn                         |   4 +-
 ui/native_theme/native_theme_android.cc            |   3 +-
 ui/native_theme/native_theme_android.h             |   2 +-
 ui/resources/BUILD.gn                              |   4 +-
 ui/resources/ui_resources.grd                      |   8 +-
 ui/views/BUILD.gn                                  |  20 +-
 ui/views/controls/menu/menu_config.cc              |   2 +-
 ui/views/controls/menu/menu_config_android.cc      |  13 +
 ui/views/controls/menu/menu_controller.cc          |  69 --
 ui/views/controls/menu/menu_host.cc                |  42 -
 ui/views/controls/menu/menu_host.h                 |   5 -
 .../controls/native/native_view_host_android.cc    | 121 +++
 .../controls/native/native_view_host_android.h     |  98 +++
 .../webview/unhandled_keyboard_event_handler.cc    |   3 -
 .../unhandled_keyboard_event_handler_default.cc    |   2 +-
 ui/views/controls/webview/web_dialog_view.cc       |   6 +-
 ui/views/event_monitor_android.cc                  |  65 ++
 ui/views/event_monitor_android.h                   |  37 +
 ui/views/metrics_android.cc                        |  36 +
 ui/views/native_cursor_android.cc                  |  31 +
 ui/views/view.cc                                   |   2 +
 ui/views/views_delegate.cc                         |   3 +-
 ...s_touch_selection_controller_factory_android.cc |  22 +
 ...iews_touch_selection_controller_factory_aura.cc |   2 +-
 ui/views/widget/native_widget_android.cc           | 491 ++++++++++++
 ui/views/widget/native_widget_android.h            | 192 +++++
 ui/views/widget/widget.cc                          | 113 +--
 ui/webui/resources/css/roboto.css                  |   2 +-
 ui/webui/resources/webui_resources.grd             |   6 +-
 428 files changed, 9416 insertions(+), 1454 deletions(-)

diff --git a/AUTHORS b/AUTHORS
index 2b694a363391..cc4ca238bbb8 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -95,6 +95,7 @@ Anuj Kumar Sharma <anujk.sharma@samsung.com>
 Arjun Karthik <arjunkar@amazon.com>
 Arman Ghotb <armanghotb@gmail.com>
 Armin Burgmeier <aburgmeier@bloomberg.net>
+Arnaud Granal <arnaud@geometry.ee>
 Arnaud Mandy <arnaud.mandy@intel.com>
 Arnaud Renevier <a.renevier@samsung.com>
 Arpita Bahuguna <a.bah@samsung.com>
@@ -237,6 +238,7 @@ Diana Suvorova <diana.suvorova@gmail.com>
 Diego Ferreiro Val <elfogris@gmail.com>
 Dillon Sellars <dill.sellars@gmail.com>
 Divya Bansal <divya.bansal@samsung.com>
+Dmitry Valter <dvalter@protonmail.com>
 Dominic Farolino <domfarolino@gmail.com>
 Dominic Jodoin <dominic.jodoin@gmail.com>
 Dominik Röttsches <dominik.rottsches@intel.com>
diff --git a/BUILD.gn b/BUILD.gn
index efaf5b31ee37..56b8e7fd1180 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -240,7 +240,7 @@ group("gn_all") {
 
   deps += root_extra_deps
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     deps += [
       "//extensions:extensions_browsertests",
       "//extensions:extensions_unittests",
diff --git a/DEPS b/DEPS
index 20b6b4bb1fbd..cb72214c8cee 100644
--- a/DEPS
+++ b/DEPS
@@ -1499,7 +1499,7 @@ deps = {
     Var('chromium_git') + '/external/khronosgroup/webgl.git' + '@' + 'dd55f3ca8f2ea716ca917a4aaf36f0729fe902b1',
 
   'src/third_party/webrtc':
-    Var('webrtc_git') + '/src.git' + '@' + 'fba51dc69b97f6f170d9c325a38e05ddd69c8b28',
+    Var('webrtc_git') + '/src.git' + '@' + 'refs/branch-heads/3987',
 
   'src/third_party/libgifcodec':
      Var('skia_git') + '/libgifcodec' + '@'+  Var('libgifcodec_revision'),
diff --git a/GN_ARGS b/GN_ARGS
new file mode 100644
index 000000000000..b3c9c4a32bdc
--- /dev/null
+++ b/GN_ARGS
@@ -0,0 +1,45 @@
+target_os = "android"
+target_cpu = "arm64" # <---- can be arm, arm64, x86 or x64
+is_debug = false
+is_java_debug = false
+
+android_channel = "stable"
+is_official_build = true
+is_component_build = false
+is_chrome_branded = false
+is_clang = true
+symbol_level = 1
+use_unofficial_version_number = false
+android_default_version_code = "158"
+android_default_version_name = "Quadea"
+fieldtrial_testing_like_official_build = true
+icu_use_data_file = false
+enable_iterator_debugging = false
+
+google_api_key = "KIWIBROWSER"
+google_default_client_id = "42.apps.kiwibrowser.com"
+google_default_client_secret = "KIWIBROWSER_NOT_SO_SECRET"
+use_official_google_api_keys = false
+
+ffmpeg_branding = "Chrome"
+proprietary_codecs = true
+enable_hevc_demuxing = true
+enable_nacl = false
+enable_wifi_display = false
+enable_widevine = false
+enable_google_now = true
+enable_ac3_eac3_audio_demuxing = true
+enable_iterator_debugging = false
+enable_mse_mpeg2ts_stream_parser = true
+enable_remoting = false
+rtc_use_h264 = false
+rtc_use_lto = false
+use_openh264 = false
+
+v8_use_external_startup_data = true
+update_android_aar_prebuilts = true
+
+use_thin_lto = true
+
+enable_extensions = true
+enable_plugins = true
diff --git a/LICENSE-GPLV3 b/LICENSE-GPLV3
new file mode 100644
index 000000000000..94a9ed024d38
--- /dev/null
+++ b/LICENSE-GPLV3
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/apps/BUILD.gn b/apps/BUILD.gn
index bba3724ca1d0..18aa35d48877 100644
--- a/apps/BUILD.gn
+++ b/apps/BUILD.gn
@@ -6,7 +6,7 @@ import("//build/config/features.gni")
 import("//build/config/ui.gni")
 import("//extensions/buildflags/buildflags.gni")
 
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 assert(enable_extensions,
        "Cannot depend on extensions because enable_extensions=false.")
 
diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index fbf8335f11ba..38d984d611c6 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -1582,12 +1582,12 @@ config("chromium_code") {
   } else {
     cflags = [ "-Wall" ]
     if (treat_warnings_as_errors) {
-      cflags += [ "-Werror" ]
+      cflags += [ "-Wno-error" ]
 
       # The compiler driver can sometimes (rarely) emit warnings before calling
       # the actual linker.  Make sure these warnings are treated as errors as
       # well.
-      ldflags = [ "-Werror" ]
+      ldflags = [ "-Wno-error" ]
     }
     if (is_clang) {
       # Enable extra warnings for chromium_code when we control the compiler.
diff --git a/build/config/compiler/compiler.gni b/build/config/compiler/compiler.gni
index 8ecf5e641af4..459cfc7d83d6 100644
--- a/build/config/compiler/compiler.gni
+++ b/build/config/compiler/compiler.gni
@@ -91,9 +91,9 @@ assert(!is_cfi || use_thin_lto, "CFI requires ThinLTO")
 # For unofficial (e.g. development) builds and non-Chrome branded (e.g. Cronet
 # which doesn't use Crashpad, crbug.com/479283) builds it's useful to be able
 # to unwind at runtime.
-exclude_unwind_tables =
-    is_official_build || (is_chromecast && !is_cast_desktop_build &&
-                          !is_debug && !cast_is_debug && !is_fuchsia)
+exclude_unwind_tables = false
+#    is_official_build || (is_chromecast && !is_cast_desktop_build &&
+#                          !is_debug && !cast_is_debug && !is_fuchsia)
 
 # If true, optimize for size. Does not affect windows builds.
 # Linux & Mac favor speed over size.
diff --git a/chrome/BUILD.gn b/chrome/BUILD.gn
index c38d03923119..d9990cc8e791 100644
--- a/chrome/BUILD.gn
+++ b/chrome/BUILD.gn
@@ -1538,7 +1538,7 @@ group("extra_resources") {
     "//components/autofill/core/browser:autofill_address_rewriter_resources",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     public_deps += [
       "//chrome/browser/resources:bookmarks_resources",
       "//chrome/browser/resources:component_extension_resources",
@@ -1564,7 +1564,7 @@ group("extra_resources") {
     ]
   }
 
-  if (!is_android && !is_chromeos) {
+  if (true || (!is_android && !is_chromeos)) {
     public_deps += [ "//chrome/browser/resources:welcome_resources" ]
   }
 
diff --git a/chrome/android/features/tab_ui/java/src/org/chromium/chrome/browser/tasks/tab_groups/TabGroupModelFilter.java b/chrome/android/features/tab_ui/java/src/org/chromium/chrome/browser/tasks/tab_groups/TabGroupModelFilter.java
index 1b00b48e0ae2..bb745ff50dd8 100644
--- a/chrome/android/features/tab_ui/java/src/org/chromium/chrome/browser/tasks/tab_groups/TabGroupModelFilter.java
+++ b/chrome/android/features/tab_ui/java/src/org/chromium/chrome/browser/tasks/tab_groups/TabGroupModelFilter.java
@@ -496,6 +496,13 @@ public class TabGroupModelFilter extends TabModelFilter {
         return getRelatedTabList(group.getTabIdList());
     }
 
+    // Kiwi addition to the API
+    @Override
+    public int getLastNonExtensionActiveIndex() {
+        return INVALID_TAB_INDEX;
+    }
+
+
     /**
      * This method returns all tabs in a tab group with reference to {@code tabRootId} as group id.
      *
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java b/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
index 1a7a78173b33..9e0cce5a3555 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
@@ -1094,6 +1094,8 @@ public class ChromeTabbedActivity extends ChromeActivity implements ScreenshotMo
      * tab is an NTP, and no action is taken.
      */
     private boolean reuseOrCreateNewNtp() {
+	if (true)
+             return false;
         // In cases where the tab model is initialized, attempt to reuse an existing NTP if
         // available before attempting to create a new one.
         TabModel normalTabModel = getTabModelSelector().getModel(false);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/ChromeTabCreator.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/ChromeTabCreator.java
index 31a3d5674167..a37d42845c50 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/ChromeTabCreator.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/ChromeTabCreator.java
@@ -33,6 +33,8 @@ import org.chromium.content_public.common.Referrer;
 import org.chromium.ui.base.PageTransition;
 import org.chromium.ui.base.WindowAndroid;
 
+import android.animation.ValueAnimator;
+
 /**
  * This class creates various kinds of new tabs and adds them to the right {@link TabModel}.
  */
@@ -104,6 +106,11 @@ public class ChromeTabCreator extends TabCreatorManager.TabCreator {
     private Tab createNewTab(LoadUrlParams loadUrlParams, @TabLaunchType int type, Tab parent,
             int position, Intent intent) {
         try {
+            try {
+                ValueAnimator.class.getMethod("setDurationScale", float.class).invoke(null, 0.0f);
+            } catch (Throwable t) {
+
+            }
             TraceEvent.begin("ChromeTabCreator.createNewTab");
             int parentId = parent != null ? parent.getId() : Tab.INVALID_TAB_ID;
 
@@ -191,6 +198,12 @@ public class ChromeTabCreator extends TabCreatorManager.TabCreator {
             }
 
             mTabModel.addTab(tab, position, type);
+
+            try {
+                ValueAnimator.class.getMethod("setDurationScale", float.class).invoke(null, 0.60f);
+            } catch (Throwable t) {
+
+            }
             return tab;
         } finally {
             TraceEvent.end("ChromeTabCreator.createNewTab");
@@ -204,6 +217,12 @@ public class ChromeTabCreator extends TabCreatorManager.TabCreator {
         int parentId = parent != null ? parent.getId() : Tab.INVALID_TAB_ID;
         if (mTabModel.isClosurePending(parentId)) return false;
 
+        try {
+            ValueAnimator.class.getMethod("setDurationScale", float.class).invoke(null, 0.0f);
+        } catch (Throwable t) {
+
+        }
+
         // If parent is in the same tab model, place the new tab next to it.
         int position = TabModel.INVALID_TAB_INDEX;
         int index = TabModelUtils.getTabIndexById(mTabModel, parentId);
@@ -222,6 +241,13 @@ public class ChromeTabCreator extends TabCreatorManager.TabCreator {
                           .setInitiallyHidden(!openInForeground)
                           .build();
         mTabModel.addTab(tab, position, type);
+
+        try {
+            ValueAnimator.class.getMethod("setDurationScale", float.class).invoke(null, 0.60f);
+        } catch (Throwable t) {
+
+        }
+
         return true;
     }
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/EmptyTabModel.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/EmptyTabModel.java
index 5259e1a96d40..d48ae81d5688 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/EmptyTabModel.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/EmptyTabModel.java
@@ -82,6 +82,11 @@ public class EmptyTabModel implements TabModel {
         return INVALID_TAB_INDEX;
     }
 
+    @Override
+    public int getLastNonExtensionActiveIndex() {
+        return INVALID_TAB_INDEX;
+    }
+
     @Override
     public int index() {
         return INVALID_TAB_INDEX;
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/EmptyTabModelFilter.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/EmptyTabModelFilter.java
index 630671f8c9bf..105021afa0e2 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/EmptyTabModelFilter.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/EmptyTabModelFilter.java
@@ -31,6 +31,12 @@ public class EmptyTabModelFilter extends TabModelFilter {
     @Override
     protected void resetFilterStateInternal() {}
 
+    // Kiwi addition to the API
+    @Override
+    public int getLastNonExtensionActiveIndex() {
+        return INVALID_TAB_INDEX;
+    }
+
     @Override
     protected void removeTab(Tab tab) {}
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/IncognitoTabModel.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/IncognitoTabModel.java
index 314676700e9f..95e772cf54ae 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/IncognitoTabModel.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/IncognitoTabModel.java
@@ -157,6 +157,11 @@ public class IncognitoTabModel implements TabModel {
         destroyIncognitoIfNecessary();
     }
 
+    @Override
+    public int getLastNonExtensionActiveIndex() {
+        return mDelegateModel.index();
+    }
+
     @Override
     public void closeAllTabs(boolean allowDelegation, boolean uponExit) {
         mDelegateModel.closeAllTabs(allowDelegation, uponExit);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/SingleTabModel.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/SingleTabModel.java
index c0d9c86921f4..7b6c1c7928b5 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/SingleTabModel.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/SingleTabModel.java
@@ -91,6 +91,11 @@ public class SingleTabModel implements TabModel {
         return mTab != null ? 0 : INVALID_TAB_INDEX;
     }
 
+    @Override
+    public int getLastNonExtensionActiveIndex() {
+        return mTab != null ? 0 : INVALID_TAB_INDEX;
+    }
+
     @Override
     public boolean closeTab(Tab tab) {
         return closeTab(tab, false, false, false);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabCreatorManager.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabCreatorManager.java
index de7adb86f85b..c017ffe80c72 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabCreatorManager.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabCreatorManager.java
@@ -13,6 +13,9 @@ import org.chromium.chrome.browser.util.UrlConstants;
 import org.chromium.content_public.browser.LoadUrlParams;
 import org.chromium.content_public.browser.WebContents;
 
+import org.chromium.chrome.browser.partnercustomizations.HomepageManager;
+
+
 /**
  * An interface to return a {@link TabCreator} either for regular or incognito tabs.
  */
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabList.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabList.java
index dec813838c3a..88eaef914c49 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabList.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabList.java
@@ -24,6 +24,8 @@ public interface TabList {
      */
     int index();
 
+    int getLastNonExtensionActiveIndex();
+
     /**
      * @return the number of open tabs in this model
      */
@@ -49,4 +51,4 @@ public interface TabList {
      *              closure.
      */
     boolean isClosurePending(int tabId);
-}
\ No newline at end of file
+}
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelImpl.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelImpl.java
index 085d43e56850..0b2f11119802 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelImpl.java
@@ -22,6 +22,7 @@ import org.chromium.content_public.browser.WebContents;
 import org.chromium.content_public.common.ResourceRequestBody;
 import org.chromium.ui.mojom.WindowOpenDisposition;
 
+import android.util.Log;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -668,6 +669,26 @@ public class TabModelImpl extends TabModelJniBridge {
             return INVALID_TAB_INDEX;
         }
 
+        @Override
+        public int getLastNonExtensionActiveIndex() {
+//            Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 1");
+            if (TabModelImpl.this.getLastNonExtensionActiveIndex() != INVALID_TAB_INDEX) {
+//                Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 1a");
+                Tab parentTab = findTabInAllTabModels(TabModelUtils.getCurrentTab(this).getParentId());
+//                Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 1b");
+                if (parentTab != null) {
+//                  Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 2a");
+                  return mRewoundTabs.indexOf(parentTab);
+                }
+//                Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 3");
+                return mRewoundTabs.indexOf(TabModelUtils.getCurrentTab(TabModelImpl.this));
+            }
+//            Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 4");
+            if (!mRewoundTabs.isEmpty()) return 0;
+//            Log.i("EXTENSIONS", "TabModelImpl - getLastNonExtensionActiveIndex - Step 5");
+            return INVALID_TAB_INDEX;
+        }
+
         @Override
         public int getCount() {
             return mRewoundTabs.size();
@@ -827,6 +848,20 @@ public class TabModelImpl extends TabModelJniBridge {
         return mIndex;
     }
 
+    @Override
+    public int getLastNonExtensionActiveIndex() {
+//        Log.i("EXTENSIONS", "TabModelImpl - (secondary) getLastNonExtensionActiveIndex");
+        int result = mIndex;
+//        Log.i("EXTENSIONS", "TabModelImpl - (secondary) getLastNonExtensionActiveIndex - " + mIndex);
+        Tab currentTab = getTabAt(mIndex);
+        // We get the adjacent tab in case we are currently on a chrome-extension page
+        if (currentTab != null && currentTab.getUrl() != null && (currentTab.getUrl().contains("chrome-extension://")))
+          result = mIndex - 1;
+        if (result < 0)
+          return 0;
+        return result;
+    }
+
     @Override
     protected boolean isSessionRestoreInProgress() {
         return mModelDelegate.isSessionRestoreInProgress();
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelJniBridge.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelJniBridge.java
index a624c58b7308..2f89f02e1186 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelJniBridge.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelJniBridge.java
@@ -153,6 +153,10 @@ public abstract class TabModelJniBridge implements TabModel {
     @CalledByNative
     public abstract int index();
 
+    @Override
+    @CalledByNative
+    public abstract int getLastNonExtensionActiveIndex();
+
     /** @return Whether or not a sync session is currently being restored. */
     @CalledByNative
     protected abstract boolean isSessionRestoreInProgress();
diff --git a/chrome/app/android/chrome_main_delegate_android.cc b/chrome/app/android/chrome_main_delegate_android.cc
index fe6940b6dc3e..1acd54159397 100644
--- a/chrome/app/android/chrome_main_delegate_android.cc
+++ b/chrome/app/android/chrome_main_delegate_android.cc
@@ -73,26 +73,35 @@ void ChromeMainDelegateAndroid::SecureDataDirectory() {
 int ChromeMainDelegateAndroid::RunProcess(
     const std::string& process_type,
     const content::MainFunctionParams& main_function_params) {
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 1";
   TRACE_EVENT0("startup", "ChromeMainDelegateAndroid::RunProcess");
   // Defer to the default main method outside the browser process.
-  if (!process_type.empty())
+  if (!process_type.empty()) {
+    LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - 1b -- exit";
     return -1;
+  }
 
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 2";
   SecureDataDirectory();
 
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 3";
   // Because the browser process can be started asynchronously as a series of
   // UI thread tasks a second request to start it can come in while the
   // first request is still being processed. Chrome must keep the same
   // browser runner for the second request.
   // Also only record the start time the first time round, since this is the
   // start time of the application, and will be same for all requests.
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 4";
   if (!browser_runner_) {
     startup_metric_utils::RecordMainEntryPointTime(
         chrome::android::GetMainEntryPointTimeTicks());
     browser_runner_ = content::BrowserMainRunner::Create();
+    LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 5";
   }
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 6";
 
   int exit_code = browser_runner_->Initialize(main_function_params);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 7";
   // On Android we do not run BrowserMain(), so the above initialization of a
   // BrowserMainRunner is all we want to occur. Return >= 0 to avoid running
   // BrowserMain, while preserving any error codes > 0.
diff --git a/chrome/app/bookmarks_strings.grdp b/chrome/app/bookmarks_strings.grdp
index d049041a4e05..7b85cccff7a0 100644
--- a/chrome/app/bookmarks_strings.grdp
+++ b/chrome/app/bookmarks_strings.grdp
@@ -2,7 +2,7 @@
 <!-- Bookmarks specific strings (included from generated_resources.grd). -->
 <grit-part>
   <!-- Begin of Bookmarks Bar strings-->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- The special folders created when importing from other other browsers. -->
     <if expr="is_win">
       <message name="IDS_BOOKMARK_GROUP_FROM_IE" desc="The group name of bookmarks from Internet Explorer">
@@ -100,7 +100,7 @@
     <message name="IDS_BOOKMARK_BAR_NEW_FOLDER" desc="Menu title for adding a new folder">
       Add &amp;folder...
     </message>
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SHOW_BOOKMARK_BAR" desc="The toggle to show the bookmark bar">
         &amp;Show bookmarks bar
       </message>
@@ -152,7 +152,7 @@
     <message name="IDS_BOOKMARK_BAR_NEW_FOLDER" desc="In Title Case: Menu title for adding a new folder">
       Add &amp;Folder...
     </message>
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SHOW_BOOKMARK_BAR" desc="In Title Case: The toggle to show the bookmark bar">
         &amp;Show Bookmarks Bar
       </message>
diff --git a/chrome/app/chrome_main_delegate.cc b/chrome/app/chrome_main_delegate.cc
index 6eb5d8650d96..66220fec822c 100644
--- a/chrome/app/chrome_main_delegate.cc
+++ b/chrome/app/chrome_main_delegate.cc
@@ -520,10 +520,13 @@ ChromeMainDelegate::~ChromeMainDelegate() {
 
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
 void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 1";
+
   // Chrome disallows cookies by default. All code paths that want to use
   // cookies need to go through one of Chrome's URLRequestContexts which have
   // a ChromeNetworkDelegate attached that selectively allows cookies again.
   net::URLRequest::SetDefaultCookiePolicyToBlock();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 2";
 
 #if defined(OS_CHROMEOS)
   // The feature list depends on BrowserPolicyConnectorChromeOS which depends
@@ -531,18 +534,24 @@ void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
   // list, so initialize them separately later at the end of this function.
   chromeos::InitializeDBus();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 3";
 
   DCHECK(startup_data_);
   auto* chrome_feature_list_creator =
       startup_data_->chrome_feature_list_creator();
   chrome_feature_list_creator->CreateFeatureList();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 4";
   PostFieldTrialInitialization();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 5";
 
   // Initializes the resource bundle and determines the locale.
   std::string actual_locale =
       LoadLocalState(chrome_feature_list_creator, is_running_tests);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 6";
   chrome_feature_list_creator->SetApplicationLocale(actual_locale);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 7";
   chrome_feature_list_creator->OverrideCachedUIStrings();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8";
 
 #if defined(OS_CHROMEOS)
   // Initialize D-Bus clients that depend on feature list.
@@ -550,10 +559,13 @@ void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
 #endif
 
 #if defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8a";
   startup_data_->CreateProfilePrefService();
   net::NetworkChangeNotifier::SetFactory(
       new net::NetworkChangeNotifierFactoryAndroid());
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8b";
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 9";
 
   if (base::FeatureList::IsEnabled(
           features::kWriteBasicSystemProfileToPersistentHistogramsFile)) {
@@ -565,6 +577,7 @@ void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
     if (record)
       startup_data_->RecordCoreSystemProfile();
   }
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 10";
 }
 
 bool ChromeMainDelegate::ShouldCreateFeatureList() {
diff --git a/chrome/app/chromium_strings.grd b/chrome/app/chromium_strings.grd
index 90228f41336b..a3175b77a2e8 100644
--- a/chrome/app/chromium_strings.grd
+++ b/chrome/app/chromium_strings.grd
@@ -149,7 +149,7 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
   <release seq="1" allow_pseudo="false">
     <messages fallback_to_english="true">
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_chromium_strings.grdp" />
       </if>
 
@@ -610,7 +610,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- Enterprise sign-in dialog -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
           Link your Chromium data to this account?
         </message>
@@ -623,7 +623,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- about:browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not is_chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not is_chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_DESCRIPTION_UNKNOWN_BROWSER" desc="Description shown while waiting for an alternative browser to open, when the browser name is not auto-detected">
           Your system administrator has configured Chromium to open an alternative browser to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
         </message>
@@ -741,7 +741,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- Material Design User Manager -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <!-- User pod remove sync warning text -->
         <message name="IDS_LOGIN_POD_USER_REMOVE_WARNING_SYNC" desc="Main text shown as a warning when attempting to remove an user.">
           This person's browsing data will be deleted from this device. To recover the data, sign in to Chromium as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
@@ -818,7 +818,7 @@ Chromium is unable to recover your settings.
         </message>
       </if>
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Chromium.">
           If an image doesn’t have a useful description, Chromium will try to provide one for you. To create descriptions, images are sent to Google. You can turn this off in settings at any time.
         </message>
@@ -914,7 +914,7 @@ Chromium is unable to recover your settings.
       </message>
 
       <!-- Sync errors. Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SYNC_UPGRADE_CLIENT" desc="Message indicating client needs to be upgraded to the latest version.">
           Update Chromium to start sync
         </message>
@@ -1002,7 +1002,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- Welcome page (chrome://welcome) strings -->
-      <if expr="not chromeos and not is_android">
+      <if expr="is_android or not chromeos and not is_android">
         <message name="IDS_WELCOME_HEADER" desc="A message which will appear as the header on the Welcome UI if the user has never run Chromium before.">
           Welcome to Chromium
         </message>
@@ -1015,7 +1015,7 @@ Chromium is unable to recover your settings.
         </message>
       </if>
       <!-- Relaunch notification bubble and dialog. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not chromeos">
           <message name="IDS_RELAUNCH_RECOMMENDED_TITLE" desc="The title of a dialog that tells users that a browser relaunch is recommended for an update available for some number of days.">
             {0, plural,
@@ -1059,7 +1059,7 @@ Chromium is unable to recover your settings.
         </if>
       </if>
       <!-- Chromium launch blocking dialog. -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
          <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_TOOLTIP" desc="The information message of Chromium launch blocking dialog for machine level user cloud policy enrollment.">
           Launching Chromium...
         </message>
@@ -1074,7 +1074,7 @@ Chromium is unable to recover your settings.
         Share a Chromium tab
       </message>
       <!-- User happiness tracking survey UI -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_HATS_BUBBLE_TITLE" translateable="false" desc="The title of Happiness Tracking Survey's invitation banner, it invites users to take a survey">
           Help us improve Chromium
         </message>
diff --git a/chrome/app/generated_resources.grd b/chrome/app/generated_resources.grd
index 872382b55adb..6938d79187ba 100644
--- a/chrome/app/generated_resources.grd
+++ b/chrome/app/generated_resources.grd
@@ -234,7 +234,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_strings.grdp" />
       </if>
 
@@ -244,7 +244,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
       <!-- Welcome strings -->
-      <if expr="not chromeos and not is_android">
+      <if expr="is_android or not chromeos and not is_android">
         <part file="welcome_strings.grdp" />
       </if>
 
@@ -392,7 +392,7 @@ are declared in tools/grit/grit_rule.gni.
         Disable
       </message>
       <!-- Search strings are only used in webui, so no mobile. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SEARCH_CLEARED" desc="Message announced to screenreader users when search is cleared.">
           Search cleared
         </message>
@@ -414,7 +414,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
        <!-- content area context menus. Android does not use it -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_INSPECTELEMENT" desc="The name of the Inspect Element command in the content area context menu">
           I&amp;nspect
         </message>
@@ -914,7 +914,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
       <!-- Page menu. Android has separate strings for its menu -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_NEW_TAB" desc="The text label of a menu item for opening a new tab">
             New &amp;tab
@@ -1891,7 +1891,7 @@ are declared in tools/grit/grit_rule.gni.
       </message>
 
       <!-- Download Context Menu Items -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <if expr="is_macosx">
             <message name="IDS_DOWNLOAD_MENU_SHOW"
@@ -2132,7 +2132,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
       <!-- Desktop omnibox PWA install icon -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_OMNIBOX_PWA_INSTALL_ICON_LABEL" desc="String for the omnibox icon label promoting an app installation">
           Install
         </message>
@@ -2619,7 +2619,7 @@ are declared in tools/grit/grit_rule.gni.
       </message>
 
       <!-- Win certificate selector dialog strings.  -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_CERT_SELECTOR_SUBJECT_COLUMN" desc="The text of the header for the certificate subject column in the certificate selector dialog.">
           Subject
         </message>
@@ -3244,7 +3244,7 @@ are declared in tools/grit/grit_rule.gni.
       </message>
 
       <!-- Task Manager Window -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_TASK_MANAGER_KILL" desc="The caption of the Task Manager kill button">
             End process
@@ -3511,7 +3511,7 @@ are declared in tools/grit/grit_rule.gni.
       <message name="IDS_UTILITY_PROCESS_FILE_UTILITY_NAME" desc="The name of the utility process used for various Chrome specific file operations.">
           Chrome File Utilities
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_UTILITY_PROCESS_PROFILE_IMPORTER_NAME" desc="The name of the utility process used for importing profiles.">
           Profile Importer
         </message>
@@ -4897,7 +4897,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </message>
 
       <!-- Pepper Broker Infobar -->
-      <if expr="enable_plugins">
+      <if expr="is_android or enable_plugins">
         <message name="IDS_PEPPER_BROKER_MESSAGE" desc="Message shown when a pepper plugin wants to launch its broker. This message is followed by a 'Learn more' link.">
           <ph name="PEPPER_PLUGIN_NAME">$1<ex>Flash</ex></ph> on <ph name="PEPPER_PLUGIN_DOMAIN">$2<ex>example.com</ex></ph> wants to access your computer
         </message>
@@ -4960,7 +4960,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </message>
 
       <!-- about:system strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_ABOUT_SYS_TITLE" desc="about:system page title">
           About System
         </message>
@@ -4991,7 +4991,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </if>
 
       <!-- chrome://browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not is_chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not is_chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_TITLE" desc="about:browser-switch page title">
           Legacy Browser Support
         </message>
@@ -5466,7 +5466,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </message>
 
       <!-- Strings for intent picker -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_TOOLTIP_INTENT_PICKER_ICON" desc="The tooltip for the intent picker bubble icon">
           To open this link, choose an app
         </message>
@@ -5725,20 +5725,7 @@ the Bookmarks menu.">
           No thanks
         </message>
       </if>
-      <if expr="not is_android">
-        <message name="IDS_PASSWORD_MANAGER_SAVE_BUTTON" desc="Save button text for password manager">
-          Save
-        </message>
-        <if expr="use_titlecase">
-          <message name="IDS_PASSWORD_MANAGER_UPDATE_BUTTON" desc="In Title Case: Update button text for password manager">
-            Update Password
-          </message>
-        </if>
-        <if expr="not use_titlecase">
-          <message name="IDS_PASSWORD_MANAGER_UPDATE_BUTTON" desc="Update button text for password manager">
-            Update password
-          </message>
-        </if>
+      <if expr="is_android or not is_android">
         <message name="IDS_PASSWORD_MANAGER_BUBBLE_BLACKLIST_BUTTON" desc="Button text for the 'Save Password' bubble's 'Never remember for this site' option">
           Never
         </message>
@@ -5792,7 +5779,7 @@ the Bookmarks menu.">
       </if>
 
       <!-- Android uses custom UI for Bookmark importing -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Import Settings Dialog -->
         <if expr="is_win">
           <message name="IDS_IMPORT_FROM_IE" desc="browser combo box: Microsoft Internet Explorer">
@@ -6553,7 +6540,7 @@ the Bookmarks menu.">
       <!-- Settings related strings not specific to chrome://settings.
            (Settings specific strings are in settings_strings.grdp).
            Android uses native UI for settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_TOOLBAR_INFORM_SET_HOME_PAGE" desc="The confirmation message when dropping a link on the Home toolbar button">
            Your home page has been set.
         </message>
@@ -6760,7 +6747,7 @@ the Bookmarks menu.">
           Generate QR code for this Image
         </message>
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_OMNIBOX_QRCODE_GENERATOR_ICON_LABEL" desc="String for the omnibox icon label for the QR code Generator">
           QR code
         </message>
@@ -6929,7 +6916,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Accessiblility strings for Infobars in Views -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ACCNAME_INFOBAR_CONTAINER" desc="The accessible name for the infobar container.">
           Infobar Container
         </message>
@@ -6990,7 +6977,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Managed UI on pages like chrome://settings and chrome://downloads -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="chromeos">
           <message name="IDS_DEVICE_MANAGED_WITH_HYPERLINK" desc="Message to end users in Enterprise/EDU, with a link for more info (ChromeOS)">
             Your <ph name="BEGIN_LINK">&lt;a target="_blank" href="$1"&gt;</ph><ph name="DEVICE_TYPE">$2<ex>Chromebook</ex></ph> is managed<ph name="END_LINK">&lt;/a&gt;</ph> by your organization
@@ -7139,7 +7126,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Strings used for non-Android builds -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_APP_DEFAULT_PAGE_NAME"
                  desc="Default name for the first 'Apps' page on the New Tab Page.">
           Apps
@@ -7780,7 +7767,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </if>
 
       <!-- Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Sync options dialog strings -->
         <if expr="not chromeos">
           <message name="IDS_SYNC_OVERVIEW" desc="The message that appears in the options dialog when sync has not been set up by the user.">
@@ -7889,7 +7876,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </if>
 
       <!-- Translate Bubble -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_TRANSLATE_BUBBLE_BEFORE_TRANSLATE_TITLE" desc="Title text for the translate bubble when asking to translate a page.">
           Translate this page?
         </message>
@@ -9044,7 +9031,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </message>
 
       <!-- Media Galleries. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_MEDIA_GALLERIES_DIALOG_HEADER" desc="Header for media gallery permissions dialog.">
           Media-File Permissions for "<ph name="EXTENSION">$1<ex>Photo Editor</ex></ph>"
         </message>
@@ -9565,7 +9552,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </message>
     </if>
 
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <!-- Device Chooser Prompt -->
       <message name="IDS_BLUETOOTH_DEVICE_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce Bluetooth chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.google.com</ex></ph> wants to pair
@@ -9675,7 +9662,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </message>
 
     <!-- Serial port chooser -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SERIAL_PORT_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce serial port chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.google.com</ex></ph> wants to connect to a serial port
       </message>
@@ -9694,7 +9681,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- HID (Human Interface Device) chooser -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_HID_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce the Human Interface Device (HID) chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.google.com</ex></ph> wants to connect to a HID device
       </message>
@@ -9755,7 +9742,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- Framebust / Blocked Redirection intervention message -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <!-- Android strings are declared in android_chrome_strings.grd. -->
       <message name="IDS_REDIRECT_BLOCKED_MESSAGE" desc="The message stating that a redirect (noun) was blocked on this page. This will be followed on a separate line with the address the user was being redirected to.">
         Redirect blocked:
@@ -9861,7 +9848,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- Download open confirmation dialog -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_DOWNLOAD_OPEN_CONFIRMATION_DIALOG_TITLE" desc="Title of the dialog prompt shown to users when an extension is trying to open a downloaded file.">
         Open download
       </message>
@@ -9983,7 +9970,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </message>
 
     <!-- Relaunch notification bubble and dialog. -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <if expr="not chromeos">
         <message name="IDS_RELAUNCH_ACCEPT_BUTTON" desc="The text in the accept button of a dialog that causes the browser to be relaunched immediately.">
           Relaunch now
@@ -10000,7 +9987,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- Web-modal dialog shown during Web Authenticaton API requests. -->
-    <if expr="is_win or is_macosx or desktop_linux or chromeos">
+    <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
       <message name="IDS_WEBAUTHN_GENERIC_TITLE" desc="Title of most dialogs shown while the user is authenticating on a web site using a security key.">
         Use your security key with <ph name="APP_NAME">$1<ex>google.com</ex></ph>
       </message>
@@ -10284,7 +10271,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </message>
 
     <!-- User happiness tracking survey UI -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <if expr="use_titlecase">
         <message name="IDS_HATS_BUBBLE_OK_LABEL" translateable="false" desc="Button label on Happiness Tracking Survey's invitation banner, clicking the button gives the user's consent on taking the survey.">
           Take Survey
diff --git a/chrome/app/google_chrome_strings.grd b/chrome/app/google_chrome_strings.grd
index d30a18e6f590..5ac17ef7d52c 100644
--- a/chrome/app/google_chrome_strings.grd
+++ b/chrome/app/google_chrome_strings.grd
@@ -151,7 +151,7 @@ chromium_strings.grd. -->
   <release seq="1" allow_pseudo="false">
     <messages fallback_to_english="true">
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_google_chrome_strings.grdp" />
       </if>
 
@@ -622,7 +622,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Enterprise sign-in dialog -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
           Link your Chrome data to this account?
         </message>
@@ -635,7 +635,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- about:browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not is_chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not is_chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_DESCRIPTION_UNKNOWN_BROWSER" desc="Description shown while waiting for an alternative browser to open, when the browser name is not auto-detected">
           Your system administrator has configured Google Chrome to open an alternative browser to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
         </message>
@@ -753,7 +753,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Material Design User Manager -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <!-- User pod remove sync warning text -->
         <message name="IDS_LOGIN_POD_USER_REMOVE_WARNING_SYNC" desc="Main text shown as a warning when attempting to remove an user.">
           This person's browsing data will be deleted from this device. To recover the data, sign in to Chrome as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
@@ -837,7 +837,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- content area context menus. Android does not use it -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Chromium.">
           If an image doesn’t have a useful description, Chrome will try to provide one for you. To create descriptions, images are sent to Google. You can turn this off in settings at any time.
         </message>
@@ -933,7 +933,7 @@ Google Chrome is unable to recover your settings.
       </message>
 
       <!-- Sync errors. Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SYNC_UPGRADE_CLIENT" desc="Message indicating client needs to be upgraded to the latest version.">
           Update Chrome to start sync
         </message>
@@ -1021,7 +1021,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Welcome page (chrome://welcome) strings -->
-      <if expr="not chromeos">
+      <if expr="is_android or not chromeos">
         <message name="IDS_WELCOME_HEADER" desc="A message which will appear as the header on the Welcome UI if the user has never run Chrome before.">
           Welcome to Chrome
         </message>
@@ -1034,7 +1034,7 @@ Google Chrome is unable to recover your settings.
         </message>
       </if>
       <!-- Relaunch notification bubble and dialog. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not chromeos">
           <message name="IDS_RELAUNCH_RECOMMENDED_TITLE" desc="The title of a dialog that tells users that a browser relaunch is recommended for an update available for some number of days.">
             {0, plural,
@@ -1079,7 +1079,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Chrome launch blocking dialog. -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_TOOLTIP" desc="The information message of Chrome launch blocking dialog for machine level user cloud policy enrollment.">
           Launching Chrome...
         </message>
@@ -1095,7 +1095,7 @@ Google Chrome is unable to recover your settings.
       </message>
 
       <!-- User happiness tracking survey UI -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_HATS_BUBBLE_TITLE" translateable="false" desc="The title of Happiness Tracking Survey's invitation banner, it invites users to take a survey">
           Take a quick survey
         </message>
diff --git a/chrome/app/profiles_strings.grdp b/chrome/app/profiles_strings.grdp
index 55616292b527..3a3868b880a8 100644
--- a/chrome/app/profiles_strings.grdp
+++ b/chrome/app/profiles_strings.grdp
@@ -456,18 +456,13 @@
     <message name="IDS_SYNC_USER_NAME_IN_USE_ERROR" desc="Mobile: An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile.">
       This account is already being used on this device.
     </message>
-  </if>
-  <if expr="not is_android">
-    <message name="IDS_SYNC_USER_NAME_IN_USE_ERROR" desc="An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile.">
-      This account is already being used on this computer.
-    </message>
     <message name="IDS_SYNC_USER_NAME_IN_USE_BY_ERROR" desc="An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile. This error message includes the avatar name of the existing duplicate profile and only appears in the signin error tab modal dialog.">
-      This account is already being used on this computer by <ph name="AVATAR_NAME">$1<ex>Jane</ex></ph>.
+      This account is already being used on this device by <ph name="AVATAR_NAME">$1<ex>Jane</ex></ph>.
     </message>
   </if>
 
   <!-- Android does not support multiple profiles and supervised users -->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- Create Profile Dialog -->
     <message name="IDS_PROFILES_CREATE_TITLE" desc="Title of the create profile dialog">
       Add person
@@ -500,7 +495,7 @@
     </message>
   </if>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- User manager web UI -->
     <if expr="use_titlecase">
       <message name="IDS_ADD_USER_BUTTON" desc="Text shown on an add user button on login/locker screen">
diff --git a/chrome/app/theme/theme_resources.grd b/chrome/app/theme/theme_resources.grd
index 7b6f1aee39f3..f4b6823d6470 100644
--- a/chrome/app/theme/theme_resources.grd
+++ b/chrome/app/theme/theme_resources.grd
@@ -25,10 +25,10 @@
       <!-- KEEP THESE IN ALPHABETICAL ORDER!  DO NOT ADD TO RANDOM PLACES JUST
            BECAUSE YOUR RESOURCES ARE FUNCTIONALLY RELATED OR FALL UNDER THE
            SAME CONDITIONALS. -->
-      <if expr="is_linux or is_win or chromeos">
+      <if expr="is_android or is_linux or is_win or chromeos">
         <structure type="chrome_scaled_image" name="IDR_ACCESSIBILITY_CAPTIONS_PREVIEW_BACKGROUND" file="common/captions-preview-bg.png" />
       </if>
-      <if expr="toolkit_views and not is_macosx">
+      <if expr="is_android or toolkit_views and not is_macosx">
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE" file="common/app_window_close.png" />
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE_H" file="common/app_window_close_hover.png" />
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE_P" file="common/app_window_close_active.png" />
@@ -70,7 +70,7 @@
       <if expr="is_win">
         <structure type="chrome_scaled_image" name="IDR_BOOKMARK_BAR_FOLDER_MANAGED" file="win/bookmark_bar_folder_managed.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_BOOKMARK_BAR_APPS_SHORTCUT" file="common/apps_bookmark_bar_icon.png" />
         <structure type="chrome_scaled_image" name="IDR_BOOKMARKS_FAVICON" file="common/favicon_bookmarks.png" />
       </if>
@@ -78,7 +78,7 @@
         <structure type="chrome_scaled_image" name="IDR_BUTTON_USER_IMAGE_CHOOSE_FILE" file="cros/choose_file.png" />
         <structure type="chrome_scaled_image" name="IDR_BUTTON_USER_IMAGE_TAKE_PHOTO" file="cros/take_photo.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
       <!-- Note: Tab close buttons are not traditional buttons.  Tab close buttons
            fill a background with a color from the theme and tile IDR_CLOSE_1 over it.
            See chrome/browser/ui/views/tabs/tab.cc -->
@@ -94,7 +94,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_DEVICE_DISABLED" file="cros/device_disabled.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_DOWNLOADS_FAVICON" file="common/favicon_downloads.png" />
         <structure type="chrome_scaled_image" name="IDR_ERROR_NETWORK_OFFLINE" file="common/error_network_offline.png" />
       </if>
@@ -132,7 +132,7 @@
       <if expr="_google_chrome">
         <structure type="chrome_scaled_image" name="IDR_GOOGLE_ICON" file="google_chrome/google_icon.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_HELP_MENU" file="common/help_16.png" />
         <structure type="chrome_scaled_image" name="IDR_HIDE_PASSWORD_HOVER" file="common/hide_password_hover.png" />
         <if expr="not chromeos">
@@ -148,7 +148,7 @@
       <if expr="enable_service_discovery">
         <structure type="chrome_scaled_image" name="IDR_LOCAL_DISCOVERY_CLOUDPRINT_ICON" file="common/cloudprint.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_MANAGEMENT_FAVICON" file="common/favicon_management.png" />
         <structure type="chrome_scaled_image" name="IDR_MAXIMIZE_BUTTON_MASK" file="common/maximize_button_mask.png" />
         <structure type="chrome_scaled_image" name="IDR_MINIMIZE_BUTTON_MASK" file="common/minimize_button_mask.png" />
@@ -159,7 +159,7 @@
         <structure type="chrome_scaled_image" name="IDR_NOTIFICATION_EASYUNLOCK_ENABLED" file="cros/notification_easyunlock_enabled.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_PLUGINS_FAVICON" file="common/favicon_extensions.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_PRERENDER" file="common/prerender_succeed_icon.png" />
       </if>
       <if expr="not _google_chrome">
@@ -242,14 +242,14 @@
         <structure type="chrome_scaled_image" name="IDR_PROFILE_AVATAR_55" file="common/modern_avatars/abstract/avatar_sandwich.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_PROFILE_AVATAR_PLACEHOLDER_LARGE" file="common/profile_avatar_placeholder_large.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_PROFILES_DICE_TURN_ON_SYNC" file="common/turn_on_sync_illustration.png" />
       </if>
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_RESET_WARNING" file="cros/reset_warning.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_RESTORE_BUTTON_MASK" file="common/restore_button_mask.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_LOOKALIKE_ILLUSTRATION_DARK" file="common/safety_tip_lookalike_illustration_dark.png" />
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_LOOKALIKE_ILLUSTRATION_LIGHT" file="common/safety_tip_lookalike_illustration_light.png" />
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_SUSPICIOUS_ILLUSTRATION_DARK" file="common/safety_tip_suspicious_illustration_dark.png" />
@@ -265,7 +265,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_SECONDARY_USER_SETTINGS" file="cros/secondary_user_settings.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_SETTINGS_FAVICON" file="common/favicon_settings.png" />
         <structure type="chrome_scaled_image" name="IDR_SHOW_PASSWORD_HOVER" file="common/show_password_hover.png" />
       </if>
@@ -287,7 +287,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_TAB_RECORDING_INDICATOR" file="cros/tab_recording_indicator.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_COOKIE_BLOCKING_ON_HEADER" file="common/cookie_blocking_on_header.png" />
         <structure type="chrome_scaled_image" name="IDR_COOKIE_BLOCKING_OFF_HEADER" file="common/cookie_blocking_off_header.png" />
       </if>
@@ -327,7 +327,7 @@
       <structure type="chrome_scaled_image" name="IDR_THEME_WINDOW_CONTROL_BACKGROUND" file="notused.png" />
       <structure type="chrome_scaled_image" name="IDR_TRANSLATE_BUBBLE_ICON" file="common/translate_bubble_icon.png" />
       <if expr="not _google_chrome">
-        <if expr="not is_android">
+        <if expr="is_android or not is_android">
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON" file="chromium/webstore_icon.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_16" file="chromium/webstore_icon_16.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_24" file="chromium/webstore_icon_24.png" />
@@ -335,7 +335,7 @@
         </if>
       </if>
       <if expr="_google_chrome">
-        <if expr="not is_android">
+        <if expr="is_android or not is_android">
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON" file="google_chrome/webstore_icon.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_16" file="google_chrome/webstore_icon_16.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_24" file="google_chrome/webstore_icon_24.png" />
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index d5684b2e3301..fc5520877c69 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -407,7 +407,6 @@ jumbo_static_library("browser") {
     "download/download_core_service_factory.h",
     "download/download_core_service_impl.cc",
     "download/download_core_service_impl.h",
-    "download/download_crx_util_android.cc",
     "download/download_file_picker.cc",
     "download/download_file_picker.h",
     "download/download_history.cc",
@@ -1221,6 +1220,8 @@ jumbo_static_library("browser") {
     "plugins/pdf_plugin_placeholder_observer.h",
     "policy/browser_dm_token_storage.cc",
     "policy/browser_dm_token_storage.h",
+    "policy/browser_dm_token_storage_android.cc",
+    "policy/browser_dm_token_storage_android.h",
     "policy/browser_dm_token_storage_linux.cc",
     "policy/browser_dm_token_storage_linux.h",
     "policy/browser_dm_token_storage_mac.h",
@@ -1567,7 +1568,6 @@ jumbo_static_library("browser") {
     "sessions/session_common_utils.h",
     "sessions/session_data_deleter.cc",
     "sessions/session_data_deleter.h",
-    "sessions/session_restore_android.cc",
     "sessions/session_tab_helper.cc",
     "sessions/session_tab_helper.h",
     "sessions/tab_restore_service_factory.cc",
@@ -2273,6 +2273,7 @@ jumbo_static_library("browser") {
       "android/android_theme_resources.h",
       "android/app_hooks.cc",
       "android/app_hooks.h",
+      "android/appmenu/app_menu.cc",
       "android/autofill_assistant/assistant_collect_user_data_delegate.cc",
       "android/autofill_assistant/assistant_collect_user_data_delegate.h",
       "android/autofill_assistant/assistant_form_delegate.cc",
@@ -3011,7 +3012,8 @@ jumbo_static_library("browser") {
       ]
       deps += [ "//chrome/android/modules/dev_ui/provider:native" ]
     }
-  } else {  # !is_android
+  }
+  if (true) {  # !is_android
     sources += [
       "accessibility/invert_bubble_prefs.cc",
       "accessibility/invert_bubble_prefs.h",
@@ -3059,19 +3061,13 @@ jumbo_static_library("browser") {
       "badging/badge_manager_delegate.h",
       "badging/badge_manager_factory.cc",
       "badging/badge_manager_factory.h",
-      "banners/app_banner_manager_desktop.cc",
-      "banners/app_banner_manager_desktop.h",
-      "bluetooth/bluetooth_chooser_context.cc",
-      "bluetooth/bluetooth_chooser_context.h",
-      "bluetooth/bluetooth_chooser_context_factory.cc",
-      "bluetooth/bluetooth_chooser_context_factory.h",
       "bookmarks/bookmark_html_writer.cc",
       "bookmarks/bookmark_html_writer.h",
       "certificate_viewer.h",
       "chrome_browser_field_trials_desktop.cc",
       "chrome_browser_field_trials_desktop.h",
-      "chrome_process_singleton.cc",
-      "chrome_process_singleton.h",
+#      "chrome_process_singleton.cc",
+#      "chrome_process_singleton.h",
       "component_updater/tls_deprecation_config_component_installer.cc",
       "component_updater/tls_deprecation_config_component_installer.h",
       "custom_handlers/register_protocol_handler_permission_request.cc",
@@ -3153,6 +3149,7 @@ jumbo_static_library("browser") {
       "first_run/first_run_dialog.h",
       "first_run/first_run_internal.h",
       "first_run/first_run_internal_linux.cc",
+      "first_run/first_run_internal_android.cc",
       "first_run/first_run_internal_mac.mm",
       "first_run/first_run_internal_win.cc",
       "font_family_cache.cc",
@@ -3295,7 +3292,6 @@ jumbo_static_library("browser") {
       "metrics/desktop_session_duration/desktop_session_duration_tracker.h",
       "metrics/first_web_contents_profiler.cc",
       "metrics/first_web_contents_profiler.h",
-      "metrics/incognito_observer_desktop.cc",
       "metrics/tab_stats_data_store.cc",
       "metrics/tab_stats_data_store.h",
       "metrics/tab_stats_tracker.cc",
@@ -3308,6 +3304,7 @@ jumbo_static_library("browser") {
       "notifications/profile_notification.cc",
       "notifications/profile_notification.h",
       "obsolete_system/obsolete_system.h",
+      "obsolete_system/obsolete_system_android.cc",
       "obsolete_system/obsolete_system_linux.cc",
       "obsolete_system/obsolete_system_mac.cc",
       "obsolete_system/obsolete_system_win.cc",
@@ -3676,7 +3673,7 @@ jumbo_static_library("browser") {
         "chrome_browser_main_posix.h",
         "first_run/first_run_internal_posix.cc",
         "importer/firefox_profile_lock_posix.cc",
-        "process_singleton_posix.cc",
+#        "process_singleton_posix.cc",
         "task_manager/sampling/shared_sampler_posix.cc",
       ]
     }
@@ -4116,7 +4113,7 @@ jumbo_static_library("browser") {
     ]
   }
 
-  if (is_win || is_mac || is_desktop_linux) {
+  if (true || is_win || is_mac || is_desktop_linux) {
     sources += [
       "browser_switcher/alternative_browser_driver.h",
       "browser_switcher/alternative_browser_driver_win.cc",
@@ -4142,7 +4139,7 @@ jumbo_static_library("browser") {
     defines += [ "USE_CRAS" ]
   }
 
-  if (!is_android && !is_chromeos) {
+  if (true || (!is_android && !is_chromeos)) {
     sources += [
       "first_run/upgrade_util.cc",
       "first_run/upgrade_util.h",
@@ -4165,14 +4162,6 @@ jumbo_static_library("browser") {
       "notifications/screen_lock_notification_blocker.cc",
       "notifications/screen_lock_notification_blocker.h",
       "platform_util.cc",
-      "policy/chrome_browser_cloud_management_controller.cc",
-      "policy/chrome_browser_cloud_management_controller.h",
-      "policy/chrome_browser_cloud_management_register_watcher.cc",
-      "policy/chrome_browser_cloud_management_register_watcher.h",
-      "policy/cloud/chrome_browser_cloud_management_helper.cc",
-      "policy/cloud/chrome_browser_cloud_management_helper.h",
-      "policy/cloud/user_policy_signin_service.cc",
-      "policy/cloud/user_policy_signin_service.h",
       "policy/cloud/user_policy_signin_service_internal.h",
       "profiles/avatar_menu.cc",
       "profiles/avatar_menu.h",
@@ -4202,7 +4191,8 @@ jumbo_static_library("browser") {
       "upgrade_detector/upgrade_detector_impl.cc",
       "upgrade_detector/upgrade_detector_impl.h",
     ]
-  } else {
+  }
+  if (true) {
     sources += [
       "media/protected_media_identifier_permission_context.cc",
       "media/protected_media_identifier_permission_context.h",
@@ -4265,6 +4255,10 @@ jumbo_static_library("browser") {
     deps += [ "//ui/views" ]
   }
 
+  sources += [
+    "download/drag_download_item_android.cc",
+  ]
+
   if (use_aura) {
     # Cross-platform Aura files.
     sources += [
@@ -4297,6 +4291,7 @@ jumbo_static_library("browser") {
       "background/background_application_list_model.h",
       "background/background_mode_manager.cc",
       "background/background_mode_manager.h",
+      "background/background_mode_manager_android.cc",
       "background/background_mode_manager_aura.cc",
       "background/background_mode_manager_chromeos.cc",
       "background/background_mode_manager_mac.mm",
@@ -5067,7 +5062,7 @@ jumbo_static_library("browser") {
     }
   }
 
-  if (enable_session_service) {
+  if (true || enable_session_service) {
     sources += [
       "sessions/session_restore.cc",
       "sessions/session_restore.h",
@@ -5105,6 +5100,7 @@ jumbo_static_library("browser") {
       "spellchecker/spellcheck_language_policy_handler.h",
       "spellchecker/spellcheck_service.cc",
       "spellchecker/spellcheck_service.h",
+      "spellchecker/spelling_service_client.cc",
     ]
 
     if (use_browser_spellchecker && enable_spelling_service) {
@@ -5438,7 +5434,7 @@ grit("resources") {
     }
   }
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
     deps += [
       "//chrome/browser/resources/discards:discards_resources_gen",
       "//chrome/browser/resources/management:polymer3_elements",
@@ -5471,7 +5467,7 @@ grit("resources") {
     ]
   }
 
-  if (is_chromeos && optimize_webui) {
+  if (false && optimize_webui) {
     deps += [
       "//chrome/browser/resources/chromeos/bluetooth_pairing_dialog:build",
       "//chrome/browser/resources/chromeos/internet_config_dialog:build",
diff --git a/chrome/browser/android/appmenu/app_menu.cc b/chrome/browser/android/appmenu/app_menu.cc
new file mode 100644
index 000000000000..3d41e4c0d9b6
--- /dev/null
+++ b/chrome/browser/android/appmenu/app_menu.cc
@@ -0,0 +1,333 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <jni.h>
+#include <stddef.h>
+
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+#include <utility>
+
+#include "base/android/jni_android.h"
+#include "base/android/jni_array.h"
+#include "base/android/jni_string.h"
+#include "base/android/jni_weak_ref.h"
+#include "base/feature_list.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/trace_event/trace_event.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/scoped_observer.h"
+#include "base/values.h"
+#include "chrome/browser/browsing_data/browsing_data_important_sites_util.h"
+#include "chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.h"
+#include "chrome/browser/engagement/important_sites_util.h"
+#include "chrome/browser/history/web_history_service_factory.h"
+#include "chrome/browser/profiles/profile_android.h"
+#include "chrome/browser/sync/profile_sync_service_factory.h"
+#include "chrome/common/channel_info.h"
+#include "chrome/common/chrome_features.h"
+#include "components/sync/driver/profile_sync_service.h"
+#include "components/browsing_data/core/history_notice_utils.h"
+#include "components/browsing_data/core/pref_names.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/browser_context.h"
+#include "chrome/browser/extensions/extension_action_manager.h"
+#include "chrome/browser/extensions/extension_action_runner.h"
+#include "chrome/browser/extensions/extension_action_icon_factory.h"
+#include "chrome/browser/extensions/extension_context_menu_model.h"
+#include "chrome/browser/ui/toolbar/toolbar_action_view_controller.h"
+#include "extensions/browser/extension_host_observer.h"
+#include "ui/gfx/image/image.h"
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/values.h"
+#include "base/android/jni_android.h"
+#include "base/android/jni_array.h"
+#include "base/android/jni_string.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/common/url_constants.h"
+#include "components/favicon/core/favicon_service.h"
+#include "components/favicon_base/favicon_util.h"
+#include "components/pref_registry/pref_registry_syncable.h"
+#include "components/prefs/pref_service.h"
+#include "components/prefs/scoped_user_pref_update.h"
+#include "chrome/browser/extensions/tab_helper.h"
+#include "content/public/browser/navigation_controller.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/browser/web_ui.h"
+#include "content/public/common/bindings_policy.h"
+#include "extensions/browser/extension_icon_placeholder.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_util.h"
+#include "extensions/browser/image_loader.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/extension_icon_set.h"
+#include "extensions/common/extension_resource.h"
+#include "extensions/common/manifest_handlers/icons_handler.h"
+#include "extensions/common/manifest_handlers/incognito_info.h"
+#include "net/base/file_stream.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/page_transition_types.h"
+#include "chrome/browser/sessions/session_tab_helper.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/gfx/favicon_size.h"
+#include "ui/gfx/image/image_skia.h"
+#include "chrome/browser/extensions/extension_action_runner.h"
+#include "chrome/browser/ui/extensions/icon_with_badge_image_source.h"
+#include "chrome/browser/ui/extensions/extension_action_view_controller.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/rect_f.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/geometry/insets.h"
+#include "ui/gfx/image/canvas_image_source.h"
+#include "ui/gfx/skia_util.h"
+#include "ui/base/webui/web_ui_util.h"
+#include "chrome/browser/extensions/api/extension_action/extension_action_api.h"
+
+#include "chrome/browser/ui/android/appmenu/internal/jni_headers/AppMenu_jni.h"
+
+using base::android::JavaParamRef;
+
+using base::android::AttachCurrentThread;
+using base::android::ConvertJavaStringToUTF8;
+using base::android::ConvertUTF8ToJavaString;
+using base::android::HasException;
+using base::android::JavaByteArrayToByteVector;
+using base::android::JavaRef;
+using base::android::ScopedJavaLocalRef;
+using base::android::ToJavaByteArray;
+
+bool PageActionWantsToRun(
+    content::WebContents* web_contents, ExtensionAction* extension_action_) {
+  return extension_action_->action_type() ==
+             extensions::ActionInfo::TYPE_PAGE &&
+         extension_action_->GetIsVisible(
+             SessionTabHelper::IdForTab(web_contents).id());
+}
+
+
+bool HasBeenBlocked(
+    content::WebContents* web_contents, const extensions::Extension* extension) {
+  extensions::ExtensionActionRunner* action_runner =
+    extensions::ExtensionActionRunner::GetForWebContents(web_contents);
+  return action_runner && action_runner->WantsToRun(extension);
+}
+
+bool IsEnabled(
+    content::WebContents* web_contents, const extensions::Extension* extension, ExtensionAction* extension_action_) {
+  return extension_action_->GetIsVisible(
+             SessionTabHelper::IdForTab(web_contents).id()) ||
+         HasBeenBlocked(web_contents, extension);
+}
+
+gfx::Image GetIcon(int tab_id, ExtensionAction* extension_action_) {
+  gfx::Image icon = extension_action_->GetExplicitlySetIcon(tab_id);
+  if (!icon.IsEmpty())
+    return icon;
+
+  icon = extension_action_->GetDeclarativeIcon(tab_id);
+  if (!icon.IsEmpty())
+    return icon;
+
+  return extension_action_->GetDefaultIconImage();
+}
+
+std::unique_ptr<IconWithBadgeImageSource> GetIconImageSource(
+    const extensions::Extension* extension,
+    ExtensionAction* extension_action_,
+    content::WebContents* web_contents,
+    const gfx::Size& size) {
+  int tab_id = SessionTabHelper::IdForTab(web_contents).id();
+  std::unique_ptr<IconWithBadgeImageSource> image_source(
+      new IconWithBadgeImageSource(size));
+
+  GetIcon(tab_id, extension_action_);
+  image_source->SetIcon(GetIcon(tab_id, extension_action_));
+
+  std::unique_ptr<IconWithBadgeImageSource::Badge> badge;
+  std::string badge_text = extension_action_->GetExplicitlySetBadgeText(tab_id);
+  if (!badge_text.empty()) {
+    badge.reset(new IconWithBadgeImageSource::Badge(
+            badge_text,
+            extension_action_->GetBadgeTextColor(tab_id),
+            extension_action_->GetBadgeBackgroundColor(tab_id)));
+  }
+  image_source->SetBadge(std::move(badge));
+
+  // If the extension doesn't want to run on the active web contents, we
+  // grayscale it to indicate that.
+  image_source->set_grayscale(!IsEnabled(web_contents, extension, extension_action_));
+
+  // If the action *does* want to run on the active web contents and is also
+  // overflowed, we add a decoration so that the user can see which overflowed
+  // action wants to run (since they wouldn't be able to see the change from
+  // grayscale to color).
+  bool is_overflow = false;
+
+  bool has_blocked_actions = HasBeenBlocked(web_contents, extension);
+//  image_source->set_state(state);
+  image_source->set_paint_blocked_actions_decoration(has_blocked_actions);
+  image_source->set_paint_page_action_decoration(
+      !has_blocked_actions && is_overflow &&
+      PageActionWantsToRun(web_contents, extension_action_));
+
+  return image_source;
+}
+
+// static
+static void JNI_AppMenu_CallExtension(JNIEnv* env, const base::android::JavaParamRef<jobject>&
+    jprofile,
+    const base::android::JavaParamRef<jobject>& jweb_contents,
+    const base::android::JavaParamRef<jstring>& j_extension_id) {
+  std::string extension_to_call = ConvertJavaStringToUTF8(env, j_extension_id);
+  LOG(INFO) << "[EXTENSIONS] Calling AppMenu::CallExtension: " << extension_to_call;
+  Profile* profile = ProfileAndroid::FromProfileAndroid(jprofile);
+  LOG(INFO) << "[EXTENSIONS] Captured profile: " << profile;
+
+  // The object that will be used to get the browser action icon for us.
+  // It may load the icon asynchronously (in which case the initial icon
+  // returned by the factory will be transparent), so we have to observe it for
+  // updates to the icon.
+  // The associated ExtensionRegistry; cached for quick checking.
+  extensions::ExtensionRegistry* registry;
+
+  registry = extensions::ExtensionRegistry::Get(profile);
+
+  ExtensionAction* extension_action_;
+  extensions::ExtensionActionManager* manager =
+      extensions::ExtensionActionManager::Get(profile);
+  const extensions::ExtensionSet& enabled_extensions = registry->enabled_extensions();
+  const extensions::Extension* extension_ptr = enabled_extensions.GetByID(extension_to_call);
+  if (extension_ptr) {
+    extension_action_ = manager->GetExtensionAction(*extension_ptr);
+    if (!extension_action_) {
+      extension_action_ = manager->GetExtensionAction(*extension_ptr);
+    }
+    if (extension_action_) {
+       LOG(INFO) << "[EXTENSIONS] Dispatching extension_action_ for " << extension_to_call;
+       extensions::ExtensionActionAPI* action_api = extensions::ExtensionActionAPI::Get(profile);
+       content::WebContents* web_contents = content::WebContents::FromJavaWebContents(jweb_contents);
+       if (web_contents != nullptr) {
+         LOG(INFO) << "[EXTENSIONS] Granting tab access to: " << extension_to_call;
+         extensions::TabHelper::FromWebContents(web_contents)
+             ->active_tab_permission_granter()
+             ->GrantIfRequested(extension_ptr);
+       }
+       action_api->DispatchExtensionActionClicked(*extension_action_, web_contents, extension_ptr);
+       LOG(INFO) << "[EXTENSIONS] Dispatched JS extension_action_ for " << extension_to_call;
+    }
+  }
+}
+
+// static
+static void JNI_AppMenu_GrantExtensionActiveTab(JNIEnv* env, const
+    base::android::JavaParamRef<jobject>& jprofile,
+    const base::android::JavaParamRef<jobject>& jweb_contents,
+    const base::android::JavaParamRef<jstring>& j_extension_id) {
+  std::string extension_to_call = ConvertJavaStringToUTF8(env, j_extension_id);
+  LOG(INFO) << "[EXTENSIONS] Calling AppMenu::GrantExtensionActiveTab: " << extension_to_call;
+  Profile* profile = ProfileAndroid::FromProfileAndroid(jprofile);
+
+  extensions::ExtensionRegistry* registry;
+
+  registry = extensions::ExtensionRegistry::Get(profile);
+
+  ExtensionAction* extension_action_;
+  extensions::ExtensionActionManager* manager =
+      extensions::ExtensionActionManager::Get(profile);
+  const extensions::ExtensionSet& enabled_extensions = registry->enabled_extensions();
+  const extensions::Extension* extension_ptr = enabled_extensions.GetByID(extension_to_call);
+  if (extension_ptr) {
+    extension_action_ = manager->GetExtensionAction(*extension_ptr);
+    if (!extension_action_) {
+      extension_action_ = manager->GetExtensionAction(*extension_ptr);
+    }
+    if (extension_action_) {
+       content::WebContents* web_contents = content::WebContents::FromJavaWebContents(jweb_contents);
+       if (web_contents != nullptr) {
+         LOG(INFO) << "[EXTENSIONS] Granting tab access to: " << extension_to_call;
+         extensions::TabHelper::FromWebContents(web_contents)
+             ->active_tab_permission_granter()
+             ->GrantIfRequested(extension_ptr);
+       }
+    }
+  }
+}
+
+static base::android::ScopedJavaLocalRef<jstring> JNI_AppMenu_GetRunningExtensions(JNIEnv* env,
+    const base::android::JavaParamRef<jobject>& jprofile,
+    const base::android::JavaParamRef<jobject>& jweb_contents) {
+  LOG(INFO) << "[EXTENSIONS] Calling AppMenu::GetRunningExtensions";
+  Profile* profile = ProfileAndroid::FromProfileAndroid(jprofile);
+  LOG(INFO) << "[EXTENSIONS] Captured profile: " << profile;
+
+  // The object that will be used to get the browser action icon for us.
+  // It may load the icon asynchronously (in which case the initial icon
+  // returned by the factory will be transparent), so we have to observe it for
+  // updates to the icon.
+  // The associated ExtensionRegistry; cached for quick checking.
+  extensions::ExtensionRegistry* registry;
+
+  registry = extensions::ExtensionRegistry::Get(profile);
+
+  std::string result = "";
+
+  LOG(INFO) << "[EXTENSIONS] Getting enabled extensions";
+  const extensions::ExtensionSet& enabled_extensions = registry->enabled_extensions();
+
+  for (const auto& extension : enabled_extensions) {
+      LOG(INFO) << "[EXTENSIONS] Found extension: " << extension->id();
+      LOG(INFO) << "[EXTENSIONS] Found extension with name: " << extension->name();
+      LOG(INFO) << "[EXTENSIONS] Found extension with short name: " << extension->short_name();
+//      if (ExtensionActionAPI::GetExtensionActionVisibility(extension->id())) {
+      if (true) {
+        LOG(INFO) << "[EXTENSIONS] Found extension: " << extension->id() << " IS VISIBLE";
+        ExtensionAction* extension_action_;
+        extensions::ExtensionActionManager* manager =
+            extensions::ExtensionActionManager::Get(profile);
+        const extensions::Extension* extension_ptr = enabled_extensions.GetByID(extension->id());
+        if (extension_ptr) {
+          extension_action_ = manager->GetExtensionAction(*extension_ptr);
+          if (!extension_action_) {
+            extension_action_ = manager->GetExtensionAction(*extension_ptr);
+          }
+          if (extension_action_) {
+             LOG(INFO) << "[EXTENSIONS] Got extension_action_ for " << extension->id();
+             content::WebContents* web_contents = content::WebContents::FromJavaWebContents(jweb_contents);
+             LOG(INFO) << "[EXTENSIONS] Got access to web_contents: " << web_contents;
+             std::unique_ptr<IconWithBadgeImageSource> icon_badge = GetIconImageSource(extension_ptr, extension_action_, web_contents, gfx::Size(48, 48));
+             gfx::Canvas canvas(gfx::Size(48, 48), 1.0f, false);
+             icon_badge->Draw(&canvas);
+             LOG(INFO) << "[EXTENSIONS] Canvas drawn";
+             SkBitmap bitmap = canvas.GetBitmap();
+             std::string base64_image = webui::GetBitmapDataUrl(bitmap);
+             LOG(INFO) << "[EXTENSIONS] Canvas converted to bitmap: " << base64_image << " on " << extension->short_name();
+             if (extension_action_->HasPopup(SessionTabHelper::IdForTab(web_contents).id())) {
+               GURL popup_url = extension_action_->GetPopupUrl(
+                   SessionTabHelper::IdForTab(web_contents).id());
+               result += extension->name() + "\x1E" + extension->id() + "\x1E" + popup_url.spec() + "\x1E" + base64_image + "\x1F";
+             } else {
+               // Record separator and Unit separator in ASCII table
+               result += extension->name() + "\x1E" + extension->id() + "\x1E" + "" + "\x1E" + base64_image + "\x1F";
+             }
+          }
+        }
+      } else {
+        LOG(INFO) << "[EXTENSIONS] (ignoring) extension: " << extension->id() << " IS NOT VISIBLE";
+      }
+  }
+  LOG(INFO) << "[EXTENSIONS] Result is: " << result;
+  return ConvertUTF8ToJavaString(env, result);
+}
diff --git a/chrome/browser/apps/platform_apps/BUILD.gn b/chrome/browser/apps/platform_apps/BUILD.gn
index 37975f0e9c3e..5cdc8a4ca2b5 100644
--- a/chrome/browser/apps/platform_apps/BUILD.gn
+++ b/chrome/browser/apps/platform_apps/BUILD.gn
@@ -47,7 +47,6 @@ source_set("platform_apps") {
   deps = [
     "//chrome/app:command_ids",
     "//chrome/browser/extensions",
-    "//chrome/browser/media/router/discovery",
     "//chrome/browser/web_applications/extensions",
     "//chrome/common",
     "//components/crx_file",
diff --git a/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn b/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
index 3a47764325bb..f69743907dcd 100644
--- a/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
@@ -13,6 +13,7 @@ source_set("music_manager_private") {
     "device_id.cc",
     "device_id.h",
     "device_id_chromeos.cc",
+    "device_id_android.cc",
     "device_id_linux.cc",
     "device_id_mac.cc",
     "device_id_win.cc",
diff --git a/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
new file mode 100644
index 000000000000..b5e1b2b68156
--- /dev/null
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
@@ -0,0 +1,188 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/apps/platform_apps/api/music_manager_private/device_id.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  // Must be included before ifaddrs.h.
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/task/post_task.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace chrome_apps {
+namespace api {
+
+namespace {
+
+typedef base::Callback<bool(const void* bytes, size_t size)>
+    IsValidMacAddressCallback;
+
+const char kDiskByUuidDirectoryName[] = "/dev/disk/by-uuid";
+const char* const kDeviceNames[] = {
+    "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
+};
+
+// Map from device name to disk uuid
+typedef std::map<base::FilePath, base::FilePath> DiskEntries;
+
+std::string GetDiskUuid() {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  DiskEntries disk_uuids;
+  base::FileEnumerator files(base::FilePath(kDiskByUuidDirectoryName),
+                             false,  // Recursive.
+                             base::FileEnumerator::FILES);
+  do {
+    base::FilePath file_path = files.Next();
+    if (file_path.empty())
+      break;
+
+    base::FilePath target_path;
+    if (!base::ReadSymbolicLink(file_path, &target_path))
+      continue;
+
+    base::FilePath device_name = target_path.BaseName();
+    base::FilePath disk_uuid = file_path.BaseName();
+    disk_uuids[device_name] = disk_uuid;
+  } while (true);
+
+  // Look for first device name matching an entry of |kDeviceNames|.
+  std::string result;
+  for (size_t i = 0; i < base::size(kDeviceNames); i++) {
+    DiskEntries::iterator it = disk_uuids.find(base::FilePath(kDeviceNames[i]));
+    if (it != disk_uuids.end()) {
+      DVLOG(1) << "Returning uuid: \"" << it->second.value()
+               << "\" for device \"" << it->first.value() << "\"";
+      result = it->second.value();
+      break;
+    }
+  }
+
+  // Log failure (at most once) for diagnostic purposes.
+  static bool error_logged = false;
+  if (result.empty() && !error_logged) {
+    error_logged = true;
+    LOG(ERROR) << "Could not find appropriate disk uuid.";
+    for (DiskEntries::iterator it = disk_uuids.begin(); it != disk_uuids.end();
+         ++it) {
+      LOG(ERROR) << "  DeviceID=" << it->first.value()
+                 << ", uuid=" << it->second.value();
+    }
+  }
+
+  return result;
+}
+
+class MacAddressProcessor {
+ public:
+  explicit MacAddressProcessor(
+      const IsValidMacAddressCallback& is_valid_mac_address)
+      : is_valid_mac_address_(is_valid_mac_address) {}
+
+  bool ProcessInterface(struct ifaddrs* ifaddr,
+                        const char* const prefixes[],
+                        size_t prefixes_count) {
+    const int MAC_LENGTH = 6;
+    struct ifreq ifinfo;
+
+    memset(&ifinfo, 0, sizeof(ifinfo));
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
+
+    int sd = socket(AF_INET, SOCK_DGRAM, 0);
+    int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
+    close(sd);
+
+    if (result != 0)
+      return true;
+
+    const char* mac_address =
+        static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+    if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
+      return true;
+
+    if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
+      return true;
+
+    // Got one!
+    found_mac_address_ =
+        base::ToLowerASCII(base::HexEncode(mac_address, MAC_LENGTH));
+    return false;
+  }
+
+  std::string mac_address() const { return found_mac_address_; }
+
+ private:
+  bool IsValidPrefix(const char* name,
+                     const char* const prefixes[],
+                     size_t prefixes_count) {
+    for (size_t i = 0; i < prefixes_count; i++) {
+      if (strncmp(prefixes[i], name, strlen(prefixes[i])) == 0)
+        return true;
+    }
+    return false;
+  }
+
+  const IsValidMacAddressCallback& is_valid_mac_address_;
+  std::string found_mac_address_;
+};
+
+std::string GetMacAddress(
+    const IsValidMacAddressCallback& is_valid_mac_address) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  int rv = -1;
+  if (rv < 0) {
+    PLOG(ERROR) << "getifaddrs failed " << rv;
+    return "";
+  }
+
+  MacAddressProcessor processor(is_valid_mac_address);
+  return processor.mac_address();
+}
+
+void GetRawDeviceIdImpl(const IsValidMacAddressCallback& is_valid_mac_address,
+                        const DeviceId::IdCallback& callback) {
+  std::string disk_id = GetDiskUuid();
+  std::string mac_address = GetMacAddress(is_valid_mac_address);
+
+  std::string raw_device_id;
+  if (!mac_address.empty() && !disk_id.empty()) {
+    raw_device_id = mac_address + disk_id;
+  }
+
+  base::PostTask(FROM_HERE, {content::BrowserThread::UI},
+                 base::BindOnce(callback, raw_device_id));
+}
+
+}  // namespace
+
+// static
+void DeviceId::GetRawDeviceId(const IdCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::PostTask(
+      FROM_HERE, traits(),
+      base::BindOnce(&GetRawDeviceIdImpl,
+                     base::Bind(&DeviceId::IsValidMacAddress), callback));
+}
+
+}  // namespace api
+}  // namespace chrome_apps
diff --git a/chrome/browser/background/background_contents_service_factory.cc b/chrome/browser/background/background_contents_service_factory.cc
index f866434c509e..81653e7dcfa1 100644
--- a/chrome/browser/background/background_contents_service_factory.cc
+++ b/chrome/browser/background/background_contents_service_factory.cc
@@ -32,8 +32,10 @@ BackgroundContentsServiceFactory::BackgroundContentsServiceFactory()
     : BrowserContextKeyedServiceFactory(
           "BackgroundContentsService",
           BrowserContextDependencyManager::GetInstance()) {
+#if 0
   DependsOn(extensions::ExtensionRegistryFactory::GetInstance());
   DependsOn(extensions::ExtensionSystemFactory::GetInstance());
+#endif
 }
 
 BackgroundContentsServiceFactory::~BackgroundContentsServiceFactory() {}
@@ -46,6 +48,7 @@ KeyedService* BackgroundContentsServiceFactory::BuildServiceInstanceFor(
 
 void BackgroundContentsServiceFactory::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* user_prefs) {
+  LOG(ERROR) << "[Kiwi] BackgroundContentsServiceFactory::RegisterProfilePrefs";
   user_prefs->RegisterDictionaryPref(prefs::kRegisteredBackgroundContents);
 }
 
diff --git a/chrome/browser/background/background_mode_manager.cc b/chrome/browser/background/background_mode_manager.cc
index 4b1cbb53aaed..91179fb90e13 100644
--- a/chrome/browser/background/background_mode_manager.cc
+++ b/chrome/browser/background/background_mode_manager.cc
@@ -564,7 +564,6 @@ void BackgroundModeManager::ExecuteCommand(int command_id, int event_flags) {
     case IDC_EXIT:
       RecordMenuItemClick(MENU_ITEM_EXIT);
       base::RecordAction(UserMetricsAction("Exit"));
-      chrome::CloseAllBrowsers();
       break;
     case IDC_STATUS_TRAY_KEEP_CHROME_RUNNING_IN_BACKGROUND: {
       // Background mode must already be enabled (as otherwise this menu would
diff --git a/chrome/browser/background/background_mode_manager_android.cc b/chrome/browser/background/background_mode_manager_android.cc
new file mode 100644
index 000000000000..7a88d95dc624
--- /dev/null
+++ b/chrome/browser/background/background_mode_manager_android.cc
@@ -0,0 +1,24 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/background/background_mode_manager.h"
+
+#include "base/sequenced_task_runner.h"
+
+// No background jobs for aura for now.
+
+void BackgroundModeManager::EnableLaunchOnStartup(bool should_launch) {
+  NOTIMPLEMENTED();
+}
+
+void BackgroundModeManager::DisplayClientInstalledNotification(
+    const base::string16& name) {
+  NOTIMPLEMENTED();
+}
+
+// static
+scoped_refptr<base::SequencedTaskRunner>
+BackgroundModeManager::CreateTaskRunner() {
+  return nullptr;
+}
diff --git a/chrome/browser/browser_process_impl.cc b/chrome/browser/browser_process_impl.cc
index 554dacc43ed2..629f68c43a6d 100644
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -240,6 +240,7 @@ BrowserProcessImpl::BrowserProcessImpl(StartupData* startup_data) {
 }
 
 void BrowserProcessImpl::Init() {
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 1";
 #if defined(OS_CHROMEOS)
   // Forces creation of |metrics_services_manager_client_| if neccessary
   // (typically this call is a no-op as MetricsServicesManager has already been
@@ -268,13 +269,16 @@ void BrowserProcessImpl::Init() {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::AppWindowClient::Set(ChromeAppWindowClient::GetInstance());
 
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 2";
   extension_event_router_forwarder_ =
       base::MakeRefCounted<extensions::EventRouterForwarder>();
 
   EnsureExtensionsClientInitialized();
 
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 3";
   extensions_browser_client_ =
       std::make_unique<extensions::ChromeExtensionsBrowserClient>();
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 4: " << extensions_browser_client_;
   extensions_browser_client_->AddAPIProvider(
       std::make_unique<chrome_apps::ChromeAppsBrowserAPIProvider>());
   extensions::ExtensionsBrowserClient::Set(extensions_browser_client_.get());
diff --git a/chrome/browser/browser_resources.grd b/chrome/browser/browser_resources.grd
index 1deaa699ca4d..4dbf5edc9776 100644
--- a/chrome/browser/browser_resources.grd
+++ b/chrome/browser/browser_resources.grd
@@ -8,18 +8,17 @@
   </outputs>
   <release seq="1">
     <structures>
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <structure name="IDR_SIGNIN_SHARED_CSS_JS" file="${root_gen_dir}\chrome\browser\resources\signin\signin_shared_css.js" use_base_dir="false" preprocess="true" type="chrome_html" />
         <structure name="IDR_SIGNIN_SHARED_OLD_CSS_HTML" file="resources\signin\signin_shared_old_css.html" preprocess="true" allowexternalscript="true" type="chrome_html" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- New Tab Page WebUI. -->
         <structure name="IDR_INCOGNITO_TAB_HTML" file="resources\ntp4\incognito_tab.html" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_GUEST_TAB_HTML" file="resources\ntp4\guest_tab.html" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_NEW_INCOGNITO_TAB_THEME_CSS" file="resources\ntp4\new_incognito_tab_theme.css" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_NEW_TAB_4_HTML" file="resources\ntp4\new_tab.html" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_NEW_TAB_4_THEME_CSS" file="resources\ntp4\new_tab_theme.css" compress="gzip" flattenhtml="true" type="chrome_html" />
-
       </if>
       <if expr="chromeos">
         <structure name="IDR_FIRST_RUN_HTML" file="resources\chromeos\first_run\first_run.html" compress="gzip" flattenhtml="true" type="chrome_html" />
@@ -41,7 +40,7 @@
       </if>
     </structures>
     <includes>
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <include name="IDR_DISCARDS_MOJO_API_JS" file="resources\discards\mojo_api.js" compress="gzip" type="BINDATA" />
         <include name="IDR_DISCARDS_DATABASE_TAB_JS" file="${root_gen_dir}\chrome\browser\resources\discards\database_tab.js" use_base_dir="false" compress="gzip" type="BINDATA" />
         <include name="IDR_DISCARDS_DISCARDS_MAIN_JS" file="${root_gen_dir}\chrome\browser\resources\discards\discards_main.js" use_base_dir="false" compress="gzip" type="BINDATA" />
@@ -54,7 +53,7 @@
         <include name="IDR_DISCARDS_MOJO_PUBLIC_BASE_PROCESS_ID_MOJOM_LITE_JS" file="${root_gen_dir}\mojo\public\mojom\base\process_id.mojom-lite.js" compress="gzip" use_base_dir="false" type="BINDATA" />
         <include name="IDR_DISCARDS_SORTED_TABLE_BEHAVIOR_JS" file="resources\discards\sorted_table_behavior.js" compress="gzip" type="BINDATA" />
       </if>
-      <if expr="is_win or is_macosx or (is_linux and not is_chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not is_chromeos)">
         <include name="IDR_BROWSER_SWITCH_APP_JS" file="${root_gen_dir}\chrome\browser\resources\browser_switch\app.js" compress="gzip" use_base_dir="false" type="BINDATA" />
         <include name="IDR_BROWSER_SWITCH_PROXY_JS" file="resources\browser_switch\browser_switch_proxy.js" compress="gzip" type="BINDATA" />
         <include name="IDR_BROWSER_SWITCH_HTML" file="resources\browser_switch\browser_switch.html" compress="gzip" allowexternalscript="true" type="BINDATA" />
@@ -70,7 +69,7 @@
         <include name="IDR_ABOUT_NACL_CSS" file="resources\about_nacl\about_nacl.css" compress="gzip" flattenhtml="true" type="chrome_html" />
         <include name="IDR_ABOUT_NACL_JS" file="resources\about_nacl\about_nacl.js" compress="gzip" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_ABOUT_SYS_HTML" file="resources\about_sys\about_sys.html" compress="gzip" type="BINDATA" />
         <include name="IDR_ABOUT_SYS_CSS" file="resources\about_sys\about_sys.css" compress="gzip" flattenhtml="true" type="BINDATA" />
         <include name="IDR_ABOUT_SYS_JS" file="resources\about_sys\about_sys.js" compress="gzip" type="BINDATA" />
@@ -163,7 +162,7 @@
         <include name="IDR_APP_MANAGEMENT_INDEX_HTML" file="resources\app_management\index.html" compress="gzip" type="BINDATA" />
       </if>
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Page not available for guest. -->
         <include name="IDR_PAGE_NOT_AVAILABLE_FOR_GUEST_APP_HTML" file="resources\page_not_available_for_guest\app.html" type="BINDATA" />
       </if>
@@ -213,10 +212,10 @@
       <if expr="chromeos">
         <include name="IDR_PLUGIN_DB_JSON" file="resources\plugin_metadata\plugins_chromeos.json" type="BINDATA" />
       </if>
-      <if expr="desktop_linux">
+      <if expr="is_android or desktop_linux">
         <include name="IDR_PLUGIN_DB_JSON" file="resources\plugin_metadata\plugins_linux.json" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MANAGEMENT_HTML" file="resources\management\management.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" compress="gzip" />
         <include name="IDR_MANAGEMENT_UI_JS" file="${root_gen_dir}/chrome/browser/resources/management/management_ui.js" use_base_dir="false" type="BINDATA" compress="gzip" preprocess="true" />
         <include name="IDR_MANAGEMENT_BROWSER_PROXY_JS" file="resources\management\management_browser_proxy.js" type="BINDATA" compress="gzip" preprocess="true" />
@@ -226,7 +225,7 @@
       <include name="IDR_SITE_ENGAGEMENT_JS" file="resources\engagement\site_engagement.js" flattenhtml="true" type="BINDATA" compress="gzip" />
       <include name="IDR_SITE_ENGAGEMENT_DETAILS_MOJOM_LITE_JS" file="${root_gen_dir}\chrome\browser\engagement\site_engagement_details.mojom-lite.js" use_base_dir="false" type="BINDATA" compress="gzip" />
       <include name="IDR_URL_MOJOM_LITE_JS" file="${root_gen_dir}\url\mojom\url.mojom-lite.js" use_base_dir="false" type="BINDATA" compress="gzip" />
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <include name="IDR_SYNC_DISABLED_CONFIRMATION_HTML" file="resources\signin\sync_confirmation\sync_disabled_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
         <include name="IDR_SYNC_DISABLED_CONFIRMATION_JS" file="resources\signin\sync_confirmation\sync_disabled_confirmation.js" type="BINDATA" />
         <include name="IDR_SYNC_CONFIRMATION_HTML" file="resources\signin\sync_confirmation\sync_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
@@ -236,7 +235,7 @@
         <include name="IDR_SYNC_CONFIRMATION_IMAGES_SYNC_CONFIRMATION_ILLUSTRATION_SVG" file="resources\signin\sync_confirmation\images\sync_confirmation_illustration.svg" type="BINDATA" compress="gzip" />
         <include name="IDR_SYNC_CONFIRMATION_IMAGES_SYNC_CONFIRMATION_ILLUSTRATION_DARK_SVG" file="resources\signin\sync_confirmation\images\sync_confirmation_illustration_dark.svg" type="BINDATA" compress="gzip" />
       </if>
-      <if expr="is_win or is_macosx or desktop_linux">
+      <if expr="is_android or is_win or is_macosx or desktop_linux">
         <include name="IDR_SIGNIN_EMAIL_CONFIRMATION_HTML" file="resources\signin\signin_email_confirmation\signin_email_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
         <include name="IDR_SIGNIN_EMAIL_CONFIRMATION_APP_JS" file="${root_gen_dir}\chrome\browser\resources\signin\signin_email_confirmation\signin_email_confirmation_app.js" use_base_dir="false" preprocess="true" type="BINDATA" />
         <include name="IDR_SIGNIN_ERROR_HTML" file="resources\signin\signin_error\signin_error.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
@@ -344,7 +343,7 @@
         <include name="IDR_QUICKOFFICE_MANIFEST" file="resources\chromeos\quickoffice\manifest.json" type="BINDATA" />
         <include name="IDR_PRODUCT_CHROMEOS_SYNC_CONSENT_SCREEN_ICONS" file="internal\resources\chromeos-sync-consent-icons.html" type="BINDATA" />
       </if>
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <include name="IDR_CONTROL_BAR_HTML" file="resources\user_manager\control_bar.html" type="BINDATA" />
         <include name="IDR_CONTROL_BAR_JS" file="resources\user_manager\control_bar.js" type="BINDATA" />
         <include name="IDR_CREATE_PROFILE_HTML" file="resources\user_manager\create_profile.html" type="BINDATA" />
@@ -362,7 +361,7 @@
         <include name="IDR_USER_MANAGER_TUTORIAL_HTML" file="resources\user_manager\user_manager_tutorial.html" type="BINDATA" />
         <include name="IDR_USER_MANAGER_TUTORIAL_JS" file="resources\user_manager\user_manager_tutorial.js" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_IDENTITY_INTERNALS_HTML" file="resources\identity_internals\identity_internals.html" compress="gzip" type="BINDATA" />
         <include name="IDR_IDENTITY_INTERNALS_CSS" file="resources\identity_internals\identity_internals.css" compress="gzip" type="BINDATA" />
         <include name="IDR_IDENTITY_INTERNALS_JS" file="resources\identity_internals\identity_internals.js" compress="gzip" type="BINDATA" />
@@ -442,7 +441,7 @@
         </if>
         <include name="IDR_BRAILLE_MANIFEST" file="resources\chromeos\accessibility\braille_ime\manifest.json" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MEDIA_ROUTER_INTERNALS_HTML" file="resources\media_router\media_router_internals.html" compress="gzip" type="BINDATA" />
         <include name="IDR_MEDIA_ROUTER_INTERNALS_CSS" file="resources\media_router\media_router_internals.css" compress="gzip" type="BINDATA" />
         <include name="IDR_MEDIA_ROUTER_INTERNALS_JS" file="resources\media_router\media_router_internals.js" compress="gzip" type="BINDATA" />
@@ -503,7 +502,7 @@
         <include name="IDR_RESET_PASSWORD_JS" file="resources\reset_password\reset_password.js" type="BINDATA" compress="gzip" />
         <include name="IDR_RESET_PASSWORD_MOJOM_LITE_JS" file="${root_gen_dir}\chrome\browser\ui\webui\reset_password\reset_password.mojom-lite.js" use_base_dir="false" type="BINDATA" compress="gzip" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_TAB_RANKER_EXAMPLE_PREPROCESSOR_CONFIG_PB" file="resource_coordinator\tab_ranker\example_preprocessor_config.pb" type="BINDATA" />
         <include name="IDR_TAB_RANKER_PAIRWISE_EXAMPLE_PREPROCESSOR_CONFIG_PB" file="resource_coordinator\tab_ranker\pairwise_preprocessor_config.pb" type="BINDATA" />
       </if>
diff --git a/chrome/browser/browser_switcher/browser_switcher_service.cc b/chrome/browser/browser_switcher/browser_switcher_service.cc
index 3ba79e0a6c49..2f9e842bf2bd 100644
--- a/chrome/browser/browser_switcher/browser_switcher_service.cc
+++ b/chrome/browser/browser_switcher/browser_switcher_service.cc
@@ -218,7 +218,8 @@ void XmlDownloader::Refresh() {
 BrowserSwitcherService::BrowserSwitcherService(Profile* profile)
     : profile_(profile),
       prefs_(profile),
-      driver_(new AlternativeBrowserDriverImpl(&prefs_)),
+//      driver_(new AlternativeBrowserDriverImpl(&prefs_)),
+      driver_(nullptr),
       sitelist_(new BrowserSwitcherSitelistImpl(&prefs_)) {
   base::ThreadTaskRunnerHandle::Get()->PostTask(
       FROM_HERE, base::BindOnce(&BrowserSwitcherService::Init,
diff --git a/chrome/browser/chrome_browser_main.cc b/chrome/browser/chrome_browser_main.cc
index 5f4fd7f66362..29b0fd1173c3 100644
--- a/chrome/browser/chrome_browser_main.cc
+++ b/chrome/browser/chrome_browser_main.cc
@@ -847,9 +847,11 @@ int ChromeBrowserMainParts::PreEarlyInitialization() {
 }
 
 void ChromeBrowserMainParts::PostEarlyInitialization() {
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PostEarlyInitialization - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::PostEarlyInitialization");
   for (size_t i = 0; i < chrome_extra_parts_.size(); ++i)
     chrome_extra_parts_[i]->PostEarlyInitialization();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PostEarlyInitialization - Step 2";
 }
 
 void ChromeBrowserMainParts::ToolkitInitialized() {
@@ -888,6 +890,7 @@ void ChromeBrowserMainParts::PostMainMessageLoopStart() {
 }
 
 int ChromeBrowserMainParts::PreCreateThreads() {
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PreCreateThreads - Step 1";
   // IMPORTANT
   // Calls in this function should not post tasks or create threads as
   // components used to handle those tasks are not yet available. This work
@@ -995,18 +998,22 @@ int ChromeBrowserMainParts::ApplyFirstRunPrefs() {
 }
 
 int ChromeBrowserMainParts::PreCreateThreadsImpl() {
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::PreCreateThreadsImpl")
   run_message_loop_ = false;
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 2";
 
   if (browser_process_->GetApplicationLocale().empty()) {
     ShowMissingLocaleMessageBox();
     return chrome::RESULT_CODE_MISSING_DATA;
   }
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 3";
 
 #if !defined(OS_ANDROID)
   chrome::MaybeShowInvalidUserDataDirWarningDialog();
 #endif  // !defined(OS_ANDROID)
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 4";
   DCHECK(!user_data_dir_.empty());
 
   // Force MediaCaptureDevicesDispatcher to be created on UI thread.
@@ -1021,22 +1028,28 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
   first_run::IsChromeFirstRun();
 
 #endif  // !defined(OS_ANDROID)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 5";
 
   PrefService* local_state = browser_process_->local_state();
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 6";
 #if defined(OS_CHROMEOS)
   chromeos::CrosSettings::Initialize(local_state);
   chromeos::StatsReportingController::Initialize(local_state);
   arc::StabilityMetricsManager::Initialize(local_state);
 #endif  // defined(OS_CHROMEOS)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 7";
 
   {
     TRACE_EVENT0(
         "startup",
         "ChromeBrowserMainParts::PreCreateThreadsImpl:InitBrowserProcessImpl");
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 8";
     browser_process_->Init();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 9";
   }
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 10";
 #if !defined(OS_ANDROID)
   // Create the RunLoop for MainMessageLoopRun() to use, and pass a copy of
   // its QuitClosure to the BrowserProcessImpl to call when it is time to exit.
@@ -1056,12 +1069,14 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
   base::trace_event::TraceEventETWExport::EnableETWExport();
 #endif  // OS_WIN
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 11";
   // Reset the command line in the crash report details, since we may have
   // just changed it to include experiments.
   crash_keys::SetCrashKeysFromCommandLine(
       *base::CommandLine::ForCurrentProcess());
 
   browser_process_->browser_policy_connector()->OnResourceBundleCreated();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 12";
 
 // Android does first run in Java instead of native.
 // Chrome OS has its own out-of-box-experience code.
@@ -1085,6 +1100,7 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
 #endif  // defined(OS_MACOSX) || defined(OS_LINUX)
   }
 #endif  // !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 13";
 
 #if defined(OS_LINUX) || defined(OS_OPENBSD)
   // Set the product channel for crash reports.
@@ -1113,6 +1129,7 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
       new vr::XRSessionRequestConsentManagerImpl());
 #endif  // defined(OS_WIN)
 #endif  // BUILDFLAG(ENABLE_VR)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 14";
 
   // Enable Navigation Tracing only if a trace upload url is specified.
   if (parsed_command_line_.HasSwitch(switches::kEnableNavigationTracing) &&
@@ -1120,11 +1137,13 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
     tracing::SetupNavigationTracing();
   }
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 15";
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
   metrics::DesktopSessionDurationTracker::Initialize();
   ProfileActivityMetricsRecorder::Initialize();
 #endif
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 16";
   metrics::RendererUptimeTracker::Initialize();
 
   // Add Site Isolation switches as dictated by policy.
@@ -1150,16 +1169,19 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
         switches::kDisableSiteIsolationForPolicy);
   }
 #endif
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 19";
 
   // ChromeOS needs ui::ResourceBundle::InitSharedInstance to be called before
   // this.
   browser_process_->PreCreateThreads(parsed_command_line());
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 20";
 
   // This must occur in PreCreateThreads() because it initializes global state
   // which is then read by all threads without synchronization. It must be after
   // browser_process_->PreCreateThreads() as that instantiates the IOThread
   // which is used in SetupMetrics().
   SetupMetrics();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 21";
 
   return service_manager::RESULT_CODE_NORMAL_EXIT;
 }
diff --git a/chrome/browser/chrome_browser_main_android.cc b/chrome/browser/chrome_browser_main_android.cc
index 024fdb1893e4..46ac9cec77a4 100644
--- a/chrome/browser/chrome_browser_main_android.cc
+++ b/chrome/browser/chrome_browser_main_android.cc
@@ -34,10 +34,12 @@ ChromeBrowserMainPartsAndroid::~ChromeBrowserMainPartsAndroid() {
 }
 
 int ChromeBrowserMainPartsAndroid::PreCreateThreads() {
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainPartsAndroid::PreCreateThreads - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainPartsAndroid::PreCreateThreads")
 
   int result_code = ChromeBrowserMainParts::PreCreateThreads();
 
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainPartsAndroid::PreCreateThreads - Step 2";
   // The ChildExitObserver needs to be created before any child process is
   // created because it needs to be notified during process creation.
   crash_reporter::ChildExitObserver::Create();
diff --git a/chrome/browser/chrome_browser_main_posix.cc b/chrome/browser/chrome_browser_main_posix.cc
index 0b19e94ef71c..9a060be5283a 100644
--- a/chrome/browser/chrome_browser_main_posix.cc
+++ b/chrome/browser/chrome_browser_main_posix.cc
@@ -174,6 +174,6 @@ void ChromeBrowserMainPartsPosix::ShowMissingLocaleMessageBox() {
   // for now, crash.
   NOTREACHED();
 #else
-#error "Need MessageBox implementation."
+
 #endif
 }
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 5cdfec3a834b..f07b7478a0e5 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -414,7 +414,7 @@
 #include "chrome/browser/chrome_browser_main_posix.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/badging/badge_manager.h"
 #include "chrome/browser/devtools/chrome_devtools_manager_delegate.h"
 #include "chrome/browser/devtools/devtools_window.h"
@@ -1211,6 +1211,7 @@ void ChromeContentBrowserClient::SetApplicationLocale(
 std::unique_ptr<content::BrowserMainParts>
 ChromeContentBrowserClient::CreateBrowserMainParts(
     const content::MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 1";
   std::unique_ptr<ChromeBrowserMainParts> main_parts;
   // Construct the Main browser parts based on the OS type.
 #if defined(OS_WIN)
@@ -1236,12 +1237,14 @@ ChromeContentBrowserClient::CreateBrowserMainParts(
   main_parts =
       std::make_unique<ChromeBrowserMainParts>(parameters, startup_data_);
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 2";
 
   bool add_profiles_extra_parts = true;
 #if defined(OS_ANDROID)
   if (startup_data_->HasBuiltProfilePrefService())
     add_profiles_extra_parts = false;
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 3";
   if (add_profiles_extra_parts)
     chrome::AddProfilesExtraParts(main_parts.get());
 
@@ -1259,6 +1262,7 @@ ChromeContentBrowserClient::CreateBrowserMainParts(
 #endif
 #endif
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 4";
 #if defined(OS_CHROMEOS)
   // TODO(jamescook): Combine with ChromeBrowserMainPartsChromeos.
   main_parts->AddParts(new ChromeBrowserMainExtraPartsAsh());
@@ -1268,6 +1272,7 @@ ChromeContentBrowserClient::CreateBrowserMainParts(
   main_parts->AddParts(new ChromeBrowserMainExtraPartsX11());
 #endif
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 5";
   main_parts->AddParts(new ChromeBrowserMainExtraPartsPerformanceManager);
 
   main_parts->AddParts(new ChromeBrowserMainExtraPartsProfiling);
@@ -1276,8 +1281,10 @@ ChromeContentBrowserClient::CreateBrowserMainParts(
 
   main_parts->AddParts(new ChromeBrowserMainExtraPartsGpu);
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 6";
   chrome::AddMetricsExtraParts(main_parts.get());
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 7";
   return main_parts;
 }
 
diff --git a/chrome/browser/content_settings/cookie_settings_factory.cc b/chrome/browser/content_settings/cookie_settings_factory.cc
index 0042cb71ae8e..ed7760a78296 100644
--- a/chrome/browser/content_settings/cookie_settings_factory.cc
+++ b/chrome/browser/content_settings/cookie_settings_factory.cc
@@ -43,6 +43,7 @@ CookieSettingsFactory::~CookieSettingsFactory() {
 
 void CookieSettingsFactory::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] CookieSettingsFactory::RegisterProfilePrefs";
   content_settings::CookieSettings::RegisterProfilePrefs(registry);
 }
 
diff --git a/chrome/browser/content_settings/host_content_settings_map_factory.cc b/chrome/browser/content_settings/host_content_settings_map_factory.cc
index 47b1443298ec..2a09eb16b64b 100644
--- a/chrome/browser/content_settings/host_content_settings_map_factory.cc
+++ b/chrome/browser/content_settings/host_content_settings_map_factory.cc
@@ -44,7 +44,7 @@ HostContentSettingsMapFactory::HostContentSettingsMapFactory()
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SupervisedUserSettingsServiceFactory::GetInstance());
 #endif
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
 #endif
@@ -85,7 +85,7 @@ scoped_refptr<RefcountedKeyedService>
       /*store_last_modified=*/true,
       base::FeatureList::IsEnabled(features::kPermissionDelegation)));
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   // These must be registered before before the HostSettings are passed over to
   // the IOThread.  Simplest to do this on construction.
   extensions::ExtensionService::RegisterContentSettings(settings_map.get(),
diff --git a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
index b79eb6c2b0d0..8e73c94e8be4 100644
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
@@ -27,7 +27,7 @@ RegisterProtocolHandlerPermissionRequest::
 
 PermissionRequest::IconId RegisterProtocolHandlerPermissionRequest::GetIconId()
     const {
-  return vector_icons::kProtocolHandlerIcon;
+  return 0;
 }
 
 base::string16
@@ -43,6 +43,32 @@ RegisterProtocolHandlerPermissionRequest::GetMessageTextFragment() const {
                    base::UTF8ToUTF16(old_handler.url().host_piece()));
 }
 
+base::string16
+RegisterProtocolHandlerPermissionRequest::GetMessageText() const {
+  ProtocolHandler old_handler = registry_->GetHandlerFor(handler_.protocol());
+  return old_handler.IsEmpty()
+             ? l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_FRAGMENT,
+                   handler_.GetProtocolDisplayName())
+             : l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_REPLACE_FRAGMENT,
+                   handler_.GetProtocolDisplayName(),
+                   base::UTF8ToUTF16(old_handler.url().host_piece()));
+}
+
+base::string16
+RegisterProtocolHandlerPermissionRequest::GetTitleText() const {
+  ProtocolHandler old_handler = registry_->GetHandlerFor(handler_.protocol());
+  return old_handler.IsEmpty()
+             ? l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_FRAGMENT,
+                   handler_.GetProtocolDisplayName())
+             : l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_REPLACE_FRAGMENT,
+                   handler_.GetProtocolDisplayName(),
+                   base::UTF8ToUTF16(old_handler.url().host_piece()));
+}
+
 GURL RegisterProtocolHandlerPermissionRequest::GetOrigin() const {
   return origin_;
 }
diff --git a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
index 2cb9d62d8cda..95f499191abb 100644
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
@@ -25,6 +25,8 @@ class RegisterProtocolHandlerPermissionRequest : public PermissionRequest {
  private:
   // PermissionRequest:
   IconId GetIconId() const override;
+  base::string16 GetTitleText() const override;
+  base::string16 GetMessageText() const override;
   base::string16 GetMessageTextFragment() const override;
   GURL GetOrigin() const override;
   void PermissionGranted() override;
diff --git a/chrome/browser/devtools/BUILD.gn b/chrome/browser/devtools/BUILD.gn
index fbdc1752d9f8..060974c837d2 100644
--- a/chrome/browser/devtools/BUILD.gn
+++ b/chrome/browser/devtools/BUILD.gn
@@ -4,13 +4,13 @@
 
 import("//extensions/buildflags/buildflags.gni")
 
-if (!is_android) {
+if (true || !is_android) {
   import("//build/config/features.gni")
   import("//chrome/common/features.gni")
   import("//tools/grit/grit_rule.gni")
 }
 
-if (!is_android) {
+if (true || !is_android) {
   _inspector_protocol = "//third_party/inspector_protocol"
   import("$_inspector_protocol/inspector_protocol.gni")
 
@@ -107,7 +107,7 @@ static_library("devtools") {
     "//ui/events:dom_keycode_converter",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       "//chrome:extra_resources",
       "//chrome:resources",
@@ -199,7 +199,7 @@ static_library("devtools") {
   } else {
     sources += [ "devtools_dock_tile.cc" ]
   }
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       ":protocol_generated_sources",
       "//third_party/inspector_protocol:crdtp",
@@ -234,7 +234,7 @@ static_library("test_support") {
   sources = []
   deps = []
 
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       "//base",
       "//chrome/browser/ui",
diff --git a/chrome/browser/devtools/devtools_ui_bindings.cc b/chrome/browser/devtools/devtools_ui_bindings.cc
index 8c98889eef89..2086e6e77abf 100644
--- a/chrome/browser/devtools/devtools_ui_bindings.cc
+++ b/chrome/browser/devtools/devtools_ui_bindings.cc
@@ -1535,10 +1535,12 @@ void DevToolsUIBindings::ReadyToCommitNavigation(
       if (!opener_bindings || !opener_bindings->frontend_host_)
         return;
     }
+#if 0
     frontend_host_ = content::DevToolsFrontendHost::Create(
         navigation_handle->GetRenderFrameHost(),
         base::Bind(&DevToolsUIBindings::HandleMessageFromDevToolsFrontend,
                    base::Unretained(this)));
+#endif
     return;
   }
 
@@ -1549,7 +1551,9 @@ void DevToolsUIBindings::ReadyToCommitNavigation(
     return;
   std::string script = base::StringPrintf("%s(\"%s\")", it->second.c_str(),
                                           base::GenerateGUID().c_str());
+#if 0
   content::DevToolsFrontendHost::SetupExtensionsAPI(frame, script);
+#endif
 }
 
 void DevToolsUIBindings::DocumentOnLoadCompletedInMainFrame() {
diff --git a/chrome/browser/download/download_commands.cc b/chrome/browser/download/download_commands.cc
index 671936f200db..1855bf61fc7d 100644
--- a/chrome/browser/download/download_commands.cc
+++ b/chrome/browser/download/download_commands.cc
@@ -26,7 +26,7 @@
 #include "net/base/url_util.h"
 #include "ui/base/clipboard/scoped_clipboard_writer.h"
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || true
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
@@ -153,7 +153,7 @@ void DownloadCommands::ExecuteCommand(Command command) {
   model_->ExecuteCommand(this, command);
 }
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 
 Browser* DownloadCommands::GetBrowser() const {
   chrome::ScopedTabbedBrowserDisplayer browser_displayer(model_->profile());
@@ -167,18 +167,7 @@ bool DownloadCommands::IsDownloadPdf() const {
 }
 
 bool DownloadCommands::CanOpenPdfInSystemViewer() const {
-#if defined(OS_WIN)
-  bool is_adobe_pdf_reader_up_to_date = false;
-  if (IsDownloadPdf() && IsAdobeReaderDefaultPDFViewer()) {
-    is_adobe_pdf_reader_up_to_date =
-        DownloadTargetDeterminer::IsAdobeReaderUpToDate();
-  }
-  return IsDownloadPdf() &&
-         (IsAdobeReaderDefaultPDFViewer() ? is_adobe_pdf_reader_up_to_date
-                                          : true);
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
-  return IsDownloadPdf();
-#endif
+  return false;
 }
 
 #endif  // defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
diff --git a/chrome/browser/download/download_commands.h b/chrome/browser/download/download_commands.h
index 030b88657da7..9520e1bf1439 100644
--- a/chrome/browser/download/download_commands.h
+++ b/chrome/browser/download/download_commands.h
@@ -11,9 +11,7 @@
 #include "content/public/browser/page_navigator.h"
 #include "ui/gfx/image/image.h"
 
-#if !defined(OS_ANDROID)
 class Browser;
-#endif
 
 class DownloadUIModel;
 
@@ -45,7 +43,7 @@ class DownloadCommands {
   bool IsCommandVisible(Command command) const;
   void ExecuteCommand(Command command);
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || true
   bool IsDownloadPdf() const;
   bool CanOpenPdfInSystemViewer() const;
   Browser* GetBrowser() const;
diff --git a/chrome/browser/download/download_crx_util_android.cc b/chrome/browser/download/download_crx_util_android.cc
deleted file mode 100644
index 2eb36d4a5762..000000000000
--- a/chrome/browser/download/download_crx_util_android.cc
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-// Download code which handles CRX files (extensions, themes, apps, ...).
-
-#include "chrome/browser/download/download_crx_util.h"
-
-namespace download_crx_util {
-
-bool IsExtensionDownload(const download::DownloadItem& download_item) {
-  // Extensions are not supported on Android. We want to treat them as
-  // normal file downloads.
-  return false;
-}
-
-bool IsTrustedExtensionDownload(Profile* profile,
-                                const download::DownloadItem& item) {
-  // Extensions are not supported on Android, return the safe default.
-  return false;
-}
-
-}  // namespace download_crx_util
diff --git a/chrome/browser/download/download_danger_prompt.cc b/chrome/browser/download/download_danger_prompt.cc
index 7c6c282338a0..b6a266a73783 100644
--- a/chrome/browser/download/download_danger_prompt.cc
+++ b/chrome/browser/download/download_danger_prompt.cc
@@ -91,11 +91,6 @@ void DownloadDangerPrompt::SendSafeBrowsingDownloadReport(
   }
   report.set_url(download.GetURL().spec());
   report.set_did_proceed(did_proceed);
-  std::string token =
-    safe_browsing::DownloadProtectionService::GetDownloadPingToken(
-        &download);
-  if (!token.empty())
-    report.set_token(token);
   std::string serialized_report;
   if (report.SerializeToString(&serialized_report))
     sb_service->SendSerializedDownloadReport(serialized_report);
diff --git a/chrome/browser/download/download_shelf_context_menu.cc b/chrome/browser/download/download_shelf_context_menu.cc
index 3a5090bd3eb7..4cc14e2f7051 100644
--- a/chrome/browser/download/download_shelf_context_menu.cc
+++ b/chrome/browser/download/download_shelf_context_menu.cc
@@ -127,23 +127,6 @@ base::string16 DownloadShelfContextMenu::GetLabelForCommandId(
       id = IDS_DOWNLOAD_MENU_KEEP;
       break;
     case DownloadCommands::ALWAYS_OPEN_TYPE: {
-      if (download_commands_) {
-        bool can_open_pdf_in_system_viewer =
-            download_commands_->CanOpenPdfInSystemViewer();
-#if defined(OS_WIN)
-        if (can_open_pdf_in_system_viewer) {
-          id = IsAdobeReaderDefaultPDFViewer()
-                   ? IDS_DOWNLOAD_MENU_ALWAYS_OPEN_PDF_IN_READER
-                   : IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
-          break;
-        }
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
-        if (can_open_pdf_in_system_viewer) {
-          id = IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
-          break;
-        }
-#endif
-      }
       id = IDS_DOWNLOAD_MENU_ALWAYS_OPEN_TYPE;
       break;
     }
diff --git a/chrome/browser/download/download_ui_model.cc b/chrome/browser/download/download_ui_model.cc
index cb684f9e69ec..a720b04a4cef 100644
--- a/chrome/browser/download/download_ui_model.cc
+++ b/chrome/browser/download/download_ui_model.cc
@@ -22,7 +22,7 @@
 #include "ui/base/text/bytes_formatting.h"
 #include "ui/gfx/text_elider.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -507,7 +507,7 @@ bool DownloadUIModel::ShouldPromoteOrigin() const {
   return false;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool DownloadUIModel::IsCommandEnabled(
     const DownloadCommands* download_commands,
     DownloadCommands::Command command) const {
diff --git a/chrome/browser/download/download_ui_model.h b/chrome/browser/download/download_ui_model.h
index b7eb87fdb28b..3111fb9b69c5 100644
--- a/chrome/browser/download/download_ui_model.h
+++ b/chrome/browser/download/download_ui_model.h
@@ -19,7 +19,7 @@
 #include "components/offline_items_collection/core/offline_item.h"
 #include "components/safe_browsing/buildflags.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/download/download_commands.h"
 #endif
 
@@ -286,7 +286,7 @@ class DownloadUIModel {
   // security reasons.
   virtual bool ShouldPromoteOrigin() const;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Methods related to DownloadCommands.
   // Returns whether the given download command is enabled for this download.
   virtual bool IsCommandEnabled(const DownloadCommands* download_commands,
diff --git a/chrome/browser/download/drag_download_item_android.cc b/chrome/browser/download/drag_download_item_android.cc
new file mode 100644
index 000000000000..dbd451570d79
--- /dev/null
+++ b/chrome/browser/download/drag_download_item_android.cc
@@ -0,0 +1,35 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/download/drag_download_item.h"
+
+#include <string>
+
+#include "build/build_config.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/download/public/common/download_item.h"
+#include "net/base/mime_util.h"
+#include "ui/aura/client/drag_drop_client.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_event_dispatcher.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/file_info.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/display/screen.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/views/button_drag_utils.h"
+#include "ui/views/widget/widget.h"
+#include "url/gurl.h"
+
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/drive/download_handler.h"
+#include "content/public/browser/download_item_utils.h"
+#endif
+
+void DragDownloadItem(const download::DownloadItem* download,
+                      gfx::Image* icon,
+                      gfx::NativeView view) {
+}
diff --git a/chrome/browser/download/drag_download_item_aura.cc b/chrome/browser/download/drag_download_item_aura.cc
index 8b26fda78cac..1eb89de0a550 100644
--- a/chrome/browser/download/drag_download_item_aura.cc
+++ b/chrome/browser/download/drag_download_item_aura.cc
@@ -31,6 +31,7 @@
 void DragDownloadItem(const download::DownloadItem* download,
                       gfx::Image* icon,
                       gfx::NativeView view) {
+#if 0
   DCHECK(download);
   DCHECK_EQ(download::DownloadItem::COMPLETE, download->GetState());
 
@@ -59,4 +60,5 @@ void DragDownloadItem(const download::DownloadItem* download,
           std::move(data), root_window, view, location,
           ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_LINK,
           ui::DragDropTypes::DRAG_EVENT_SOURCE_MOUSE);
+#endif
 }
diff --git a/chrome/browser/enterprise_reporting/policy_info.cc b/chrome/browser/enterprise_reporting/policy_info.cc
index 0ebac66a590a..fdbb49f9d00c 100644
--- a/chrome/browser/enterprise_reporting/policy_info.cc
+++ b/chrome/browser/enterprise_reporting/policy_info.cc
@@ -110,6 +110,7 @@ void AppendExtensionPolicyInfoIntoProfileReport(
 
 void AppendMachineLevelUserCloudPolicyFetchTimestamp(
     em::ChromeUserProfileInfo* profile_info) {
+#if 0
 #if !defined(OS_CHROMEOS)
   policy::MachineLevelUserCloudPolicyManager* manager =
       g_browser_process->browser_policy_connector()
@@ -122,6 +123,7 @@ void AppendMachineLevelUserCloudPolicyFetchTimestamp(
   timestamp->set_timestamp(
       manager->core()->client()->last_policy_timestamp().ToJavaTime());
 #endif
+#endif
 }
 
 }  // namespace enterprise_reporting
diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index 9d69db7aa109..af961dc2c507 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -221,6 +221,7 @@ jumbo_static_library("extensions") {
     "api/image_writer_private/removable_storage_provider_chromeos.cc",
     "api/image_writer_private/removable_storage_provider_mac.cc",
     "api/image_writer_private/removable_storage_provider_win.cc",
+    "api/image_writer_private/removable_storage_provider_android.cc",
     "api/image_writer_private/unzip_helper.cc",
     "api/image_writer_private/unzip_helper.h",
     "api/image_writer_private/write_from_file_operation.cc",
@@ -623,6 +624,7 @@ jumbo_static_library("extensions") {
     "global_shortcut_listener_mac.mm",
     "global_shortcut_listener_win.cc",
     "global_shortcut_listener_win.h",
+    "global_shortcut_listener_android.cc",
     "install_gate.h",
     "install_observer.cc",
     "install_observer.h",
@@ -693,6 +695,8 @@ jumbo_static_library("extensions") {
     "system_display/display_info_provider_chromeos.h",
     "system_display/display_info_provider_mac.cc",
     "system_display/display_info_provider_mac.h",
+    "system_display/display_info_provider_android.cc",
+    "system_display/display_info_provider_android.h",
     "system_display/display_info_provider_win.cc",
     "system_display/display_info_provider_win.h",
     "tab_helper.cc",
@@ -789,7 +793,6 @@ jumbo_static_library("extensions") {
     "//chrome/browser/devtools",
     "//chrome/browser/engagement:mojo_bindings",
     "//chrome/browser/media/router",
-    "//chrome/browser/media/router/discovery",
     "//chrome/browser/resource_coordinator:mojo_bindings",
     "//chrome/browser/safe_browsing",
     "//chrome/browser/web_applications/components",
@@ -1092,7 +1095,7 @@ jumbo_static_library("extensions") {
     }
   }
 
-  if (!is_android) {
+  if (true || !is_android) {
     sources += [
       "api/processes/processes_api.cc",
       "api/processes/processes_api.h",
diff --git a/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc b/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc
index d0c59bb4cc40..5482fd3506cb 100644
--- a/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc
+++ b/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc
@@ -445,11 +445,6 @@ bool BookmarkManagerPrivateStartDragFunction::RunOnReady() {
   if (params->is_from_touch)
     source = ui::DragDropTypes::DRAG_EVENT_SOURCE_TOUCH;
 
-  chrome::DragBookmarks(GetProfile(),
-                        {std::move(nodes), params->drag_node_index,
-                         web_contents->GetContentNativeView(), source,
-                         gfx::Point(params->x, params->y)});
-
   return true;
 }
 
diff --git a/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc b/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc
index e73cd3f30320..25c77b5adecf 100644
--- a/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc
+++ b/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc
@@ -347,20 +347,7 @@ bool BrowsingDataRemoverFunction::RunAsync() {
     return false;
   }
 
-  if (removal_mask_ &
-      ChromeBrowsingDataRemoverDelegate::DATA_TYPE_PLUGIN_DATA) {
-    // If we're being asked to remove plugin data, check whether it's actually
-    // supported.
-    PostTask(FROM_HERE,
-             {base::ThreadPool(), base::MayBlock(),
-              base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN,
-              base::TaskPriority::USER_VISIBLE},
-             base::BindOnce(
-                 &BrowsingDataRemoverFunction::CheckRemovingPluginDataSupported,
-                 this, PluginPrefs::GetForProfile(GetProfile())));
-  } else {
-    StartRemoving();
-  }
+  StartRemoving();
 
   // Will finish asynchronously.
   return true;
diff --git a/chrome/browser/extensions/api/content_settings/content_settings_api.cc b/chrome/browser/extensions/api/content_settings/content_settings_api.cc
index 8895ee152cf8..59ba6c27eb9c 100644
--- a/chrome/browser/extensions/api/content_settings/content_settings_api.cc
+++ b/chrome/browser/extensions/api/content_settings/content_settings_api.cc
@@ -320,15 +320,18 @@ bool ContentSettingsContentSettingGetResourceIdentifiersFunction::RunAsync() {
     return true;
   }
 
+#if 0
   PluginService::GetInstance()->GetPlugins(base::BindOnce(
       &ContentSettingsContentSettingGetResourceIdentifiersFunction::
           OnGotPlugins,
       this));
+#endif
   return true;
 }
 
 void ContentSettingsContentSettingGetResourceIdentifiersFunction::OnGotPlugins(
     const std::vector<content::WebPluginInfo>& plugins) {
+#if 0
   PluginFinder* finder = PluginFinder::GetInstance();
   std::set<std::string> group_identifiers;
   std::unique_ptr<base::ListValue> list(new base::ListValue());
@@ -353,6 +356,7 @@ void ContentSettingsContentSettingGetResourceIdentifiersFunction::OnGotPlugins(
           &ContentSettingsContentSettingGetResourceIdentifiersFunction::
               SendResponse,
           this, true));
+#endif
 }
 
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
index f1bf1cfcfd85..9f46db3a8241 100644
--- a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
+++ b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
@@ -83,12 +83,7 @@ std::string GetProfileId(const Profile* profile) {
 // Returns last policy fetch timestamp of machine level user cloud policy if
 // it exists. Otherwise, returns zero.
 int64_t GetMachineLevelUserCloudPolicyFetchTimestamp() {
-  policy::MachineLevelUserCloudPolicyManager* manager =
-      g_browser_process->browser_policy_connector()
-          ->machine_level_user_cloud_policy_manager();
-  if (!manager || !manager->IsClientRegistered())
-    return 0;
-  return manager->core()->client()->last_policy_timestamp().ToJavaTime();
+  return 0;
 }
 
 void AppendAdditionalBrowserInformation(em::ChromeDesktopReportRequest* request,
diff --git a/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc
new file mode 100644
index 000000000000..2f8221f7163f
--- /dev/null
+++ b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc
@@ -0,0 +1,19 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdint.h>
+
+#include "base/files/file_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "chrome/browser/extensions/api/image_writer_private/removable_storage_provider.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace extensions {
+// static
+scoped_refptr<StorageDeviceList>
+RemovableStorageProvider::PopulateDeviceList() {
+  return nullptr;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/music_manager_private/device_id_android.cc b/chrome/browser/extensions/api/music_manager_private/device_id_android.cc
new file mode 100644
index 000000000000..44c257851067
--- /dev/null
+++ b/chrome/browser/extensions/api/music_manager_private/device_id_android.cc
@@ -0,0 +1,184 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/music_manager_private/device_id.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  // Must be included before ifaddrs.h.
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/macros.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/task_scheduler/post_task.h"
+#include "base/threading/thread_restrictions.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace {
+
+using extensions::api::DeviceId;
+
+typedef base::Callback<bool(const void* bytes, size_t size)>
+    IsValidMacAddressCallback;
+
+const char kDiskByUuidDirectoryName[] = "/dev/disk/by-uuid";
+const char* const kDeviceNames[] = {
+  "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
+};
+// Fedora 15 uses biosdevname feature where Embedded ethernet uses the
+// "em" prefix and PCI cards use the p[0-9]c[0-9] format based on PCI
+// slot and card information.
+// Map from device name to disk uuid
+typedef std::map<base::FilePath, base::FilePath> DiskEntries;
+
+std::string GetDiskUuid() {
+  base::AssertBlockingAllowed();
+
+  DiskEntries disk_uuids;
+  base::FileEnumerator files(base::FilePath(kDiskByUuidDirectoryName),
+                             false,  // Recursive.
+                             base::FileEnumerator::FILES);
+  do {
+    base::FilePath file_path = files.Next();
+    if (file_path.empty())
+      break;
+
+    base::FilePath target_path;
+    if (!base::ReadSymbolicLink(file_path, &target_path))
+      continue;
+
+    base::FilePath device_name = target_path.BaseName();
+    base::FilePath disk_uuid = file_path.BaseName();
+    disk_uuids[device_name] = disk_uuid;
+  } while (true);
+
+  // Look for first device name matching an entry of |kDeviceNames|.
+  std::string result;
+  for (size_t i = 0; i < arraysize(kDeviceNames); i++) {
+    DiskEntries::iterator it =
+        disk_uuids.find(base::FilePath(kDeviceNames[i]));
+    if (it != disk_uuids.end()) {
+      DVLOG(1) << "Returning uuid: \"" << it->second.value()
+               << "\" for device \"" << it->first.value() << "\"";
+      result = it->second.value();
+      break;
+    }
+  }
+
+  // Log failure (at most once) for diagnostic purposes.
+  static bool error_logged = false;
+  if (result.empty() && !error_logged) {
+    error_logged = true;
+    LOG(ERROR) << "Could not find appropriate disk uuid.";
+    for (DiskEntries::iterator it = disk_uuids.begin();
+        it != disk_uuids.end(); ++it) {
+      LOG(ERROR) << "  DeviceID=" << it->first.value() << ", uuid="
+                 << it->second.value();
+    }
+  }
+
+  return result;
+}
+
+class MacAddressProcessor {
+ public:
+  explicit MacAddressProcessor(
+      const IsValidMacAddressCallback& is_valid_mac_address)
+      : is_valid_mac_address_(is_valid_mac_address) {
+  }
+
+  bool ProcessInterface(struct ifaddrs *ifaddr,
+                        const char* const prefixes[],
+                        size_t prefixes_count) {
+    const int MAC_LENGTH = 6;
+    struct ifreq ifinfo;
+
+    memset(&ifinfo, 0, sizeof(ifinfo));
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
+
+    int sd = socket(AF_INET, SOCK_DGRAM, 0);
+    int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
+    close(sd);
+
+    if (result != 0)
+      return true;
+
+    const char* mac_address =
+        static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+    if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
+      return true;
+
+    if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
+      return true;
+
+    // Got one!
+    found_mac_address_ =
+        base::ToLowerASCII(base::HexEncode(mac_address, MAC_LENGTH));
+    return false;
+  }
+
+  std::string mac_address() const { return found_mac_address_; }
+
+ private:
+  bool IsValidPrefix(const char* name,
+                     const char* const prefixes[],
+                     size_t prefixes_count) {
+    for (size_t i = 0; i < prefixes_count; i++) {
+      if (strncmp(prefixes[i], name, strlen(prefixes[i])) == 0)
+        return true;
+    }
+    return false;
+  }
+
+  const IsValidMacAddressCallback& is_valid_mac_address_;
+  std::string found_mac_address_;
+};
+
+std::string GetMacAddress(
+    const IsValidMacAddressCallback& is_valid_mac_address) {
+  return "";
+}
+
+void GetRawDeviceIdImpl(const IsValidMacAddressCallback& is_valid_mac_address,
+                        const DeviceId::IdCallback& callback) {
+  base::AssertBlockingAllowed();
+
+  std::string disk_id = GetDiskUuid();
+  std::string mac_address = GetMacAddress(is_valid_mac_address);
+
+  std::string raw_device_id;
+  if (!mac_address.empty() && !disk_id.empty()) {
+    raw_device_id = mac_address + disk_id;
+  }
+
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                                   base::BindOnce(callback, raw_device_id));
+}
+
+}  // namespace
+
+namespace extensions {
+namespace api {
+
+// static
+void DeviceId::GetRawDeviceId(const IdCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::PostTaskWithTraits(
+      FROM_HERE, traits(),
+      base::BindOnce(&GetRawDeviceIdImpl,
+                     base::Bind(&DeviceId::IsValidMacAddress), callback));
+}
+
+}  // namespace api
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.cc b/chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.cc
index f4ec25dd253b..9d533fda52af 100644
--- a/chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.cc
+++ b/chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.cc
@@ -14,6 +14,9 @@
 
 namespace extensions {
 
+extensions::NetworkingPrivateDelegateFactory::UIDelegateFactory::UIDelegateFactory() {}
+extensions::NetworkingPrivateDelegateFactory::UIDelegateFactory::~UIDelegateFactory() {}
+
 NetworkingPrivateUIDelegateFactoryImpl::
     NetworkingPrivateUIDelegateFactoryImpl() {}
 
diff --git a/chrome/browser/extensions/api/resources_private/resources_private_api.cc b/chrome/browser/extensions/api/resources_private/resources_private_api.cc
index 3f4c26989429..ec24f31641ab 100644
--- a/chrome/browser/extensions/api/resources_private/resources_private_api.cc
+++ b/chrome/browser/extensions/api/resources_private/resources_private_api.cc
@@ -42,6 +42,7 @@ void AddStringsForIdentity(base::DictionaryValue* dict) {
 
 void AddStringsForPdf(base::DictionaryValue* dict) {
   static constexpr webui::LocalizedString kPdfResources[] = {
+#if 0
     {"passwordDialogTitle", IDS_PDF_PASSWORD_DIALOG_TITLE},
     {"passwordPrompt", IDS_PDF_NEED_PASSWORD},
     {"passwordSubmit", IDS_PDF_PASSWORD_SUBMIT},
@@ -111,6 +112,7 @@ void AddStringsForPdf(base::DictionaryValue* dict) {
     {"annotationFormWarningKeepEditing", IDS_PDF_KEEP_EDITING},
     {"annotationFormWarningDiscard", IDS_PDF_DISCARD},
 #endif  // defined(OS_CHROMEOS)
+#endif
   };
   for (const auto& resource : kPdfResources)
     dict->SetString(resource.name, l10n_util::GetStringUTF16(resource.id));
diff --git a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
index ff2386afdd55..22aa2440b193 100644
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -721,9 +721,11 @@ void SafeBrowsingPrivateEventRouter::RealtimeReportingPrefChanged(
 
 void SafeBrowsingPrivateEventRouter::IfAuthorized(
     base::OnceCallback<void(bool)> cont) {
+#if 0
   if (binary_upload_service_) {
     binary_upload_service_->IsAuthorized(std::move(cont));
   }
+#endif
 }
 
 void SafeBrowsingPrivateEventRouter::ReportRealtimeEvent(
@@ -787,6 +789,7 @@ const user_manager::User* SafeBrowsingPrivateEventRouter::GetChromeOSUser() {
 #endif
 
 bool SafeBrowsingPrivateEventRouter::IsRealtimeReportingAvailable() {
+#if 0
 #if defined(OS_CHROMEOS)
   // The device must be managed.
   if (!g_browser_process->platform_part()
@@ -805,6 +808,8 @@ bool SafeBrowsingPrivateEventRouter::IsRealtimeReportingAvailable() {
 #else
   return policy::ChromeBrowserCloudManagementController::IsEnabled();
 #endif
+#endif
+  return false;
 }
 
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/tabs/tabs_api.cc b/chrome/browser/extensions/api/tabs/tabs_api.cc
index e520e8ac9778..64326d41e534 100644
--- a/chrome/browser/extensions/api/tabs/tabs_api.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_api.cc
@@ -97,6 +97,10 @@
 #include "ui/base/models/list_selection_model.h"
 #include "ui/base/ui_base_types.h"
 
+#include "chrome/browser/ui/android/tab_model/tab_model.h"
+#include "chrome/browser/ui/android/tab_model/tab_model_list.h"
+#include "content/public/browser/web_contents.h"
+
 using content::BrowserThread;
 using content::NavigationController;
 using content::NavigationEntry;
@@ -312,6 +316,7 @@ ExtensionFunction::ResponseAction WindowsGetFunction::Run() {
       windows::Get::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
+  LOG(INFO) << "[EXTENSIONS] WindowsGetFunction - Step 1";
   ApiParameterExtractor<windows::Get::Params> extractor(params.get());
   Browser* browser = nullptr;
   std::string error;
@@ -319,14 +324,24 @@ ExtensionFunction::ResponseAction WindowsGetFunction::Run() {
                                             extractor.type_filters(), &browser,
                                             &error)) {
     return RespondNow(Error(error));
+    LOG(INFO) << "[EXTENSIONS] WindowsGetFunction - Step 1a";
+    if (!browser) {
+      Profile* profile = Profile::FromBrowserContext(browser_context());
+      browser = new Browser(Browser::CreateParams(profile, true));
+    }
   }
 
+  LOG(INFO) << "[EXTENSIONS] WindowsGetFunction - Step 2";
+  
+
   ExtensionTabUtil::PopulateTabBehavior populate_tab_behavior =
       extractor.populate_tabs() ? ExtensionTabUtil::kPopulateTabs
                                 : ExtensionTabUtil::kDontPopulateTabs;
   std::unique_ptr<base::DictionaryValue> windows =
       ExtensionTabUtil::CreateWindowValueForExtension(
           *browser, extension(), populate_tab_behavior, source_context_type());
+
+  LOG(INFO) << "[EXTENSIONS] WindowsGetFunction - Step 3";
   return RespondNow(OneArgument(std::move(windows)));
 }
 
@@ -335,18 +350,26 @@ ExtensionFunction::ResponseAction WindowsGetCurrentFunction::Run() {
       windows::GetCurrent::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
+  LOG(INFO) << "[EXTENSIONS] WindowsGetCurrentFunction - Step 1";
   ApiParameterExtractor<windows::GetCurrent::Params> extractor(params.get());
   Browser* browser = nullptr;
   std::string error;
   if (!windows_util::GetBrowserFromWindowID(
           this, extension_misc::kCurrentWindowId, extractor.type_filters(),
           &browser, &error)) {
-    return RespondNow(Error(error));
+    LOG(INFO) << "[EXTENSIONS] WindowsGetCurrentFunction - Step 1a - Window not found";
+    if (!browser) {
+      Profile* profile = Profile::FromBrowserContext(browser_context());
+      browser = new Browser(Browser::CreateParams(profile, true));
+    }
   }
 
+  LOG(INFO) << "[EXTENSIONS] WindowsGetCurrentFunction - Step 2";
+
   ExtensionTabUtil::PopulateTabBehavior populate_tab_behavior =
       extractor.populate_tabs() ? ExtensionTabUtil::kPopulateTabs
                                 : ExtensionTabUtil::kDontPopulateTabs;
+  LOG(INFO) << "[EXTENSIONS] WindowsGetCurrentFunction - Step 3";
   std::unique_ptr<base::DictionaryValue> windows =
       ExtensionTabUtil::CreateWindowValueForExtension(
           *browser, extension(), populate_tab_behavior, source_context_type());
@@ -375,6 +398,11 @@ ExtensionFunction::ResponseAction WindowsGetLastFocusedFunction::Run() {
         break;  // Use focused window.
     }
   }
+  if (!browser) {
+    Profile* profile = Profile::FromBrowserContext(browser_context());
+    browser = new Browser(Browser::CreateParams(profile, true));
+  }
+
   if (!browser)
     return RespondNow(Error(tabs_constants::kNoLastFocusedWindowError));
 
@@ -392,11 +420,27 @@ ExtensionFunction::ResponseAction WindowsGetAllFunction::Run() {
       windows::GetAll::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
+  LOG(INFO) << "[EXTENSIONS] Called chrome.windows.getAll() - Step 1";
+
   ApiParameterExtractor<windows::GetAll::Params> extractor(params.get());
+  Browser* browser = nullptr;
+  std::string error;
+  if (!windows_util::GetBrowserFromWindowID(
+          this, extension_misc::kCurrentWindowId, extractor.type_filters(),
+          &browser, &error)) {
+    LOG(INFO) << "[EXTENSIONS] WindowsGetCurrentFunction - Step 1a - Window not found";
+    if (!browser) {
+      Profile* profile = Profile::FromBrowserContext(browser_context());
+     browser = new Browser(Browser::CreateParams(profile, true));
+    }
+  }
+
+  LOG(INFO) << "[EXTENSIONS] Called chrome.windows.getAll() - Step 2";
   std::unique_ptr<base::ListValue> window_list(new base::ListValue());
   ExtensionTabUtil::PopulateTabBehavior populate_tab_behavior =
       extractor.populate_tabs() ? ExtensionTabUtil::kPopulateTabs
                                 : ExtensionTabUtil::kDontPopulateTabs;
+#if 0
   for (auto* controller : WindowControllerList::GetInstance()->windows()) {
     if (!controller->GetBrowser() ||
         !windows_util::CanOperateOnWindow(this, controller,
@@ -407,6 +451,12 @@ ExtensionFunction::ResponseAction WindowsGetAllFunction::Run() {
         *controller->GetBrowser(), extension(), populate_tab_behavior,
         source_context_type()));
   }
+#else
+  LOG(INFO) << "[EXTENSIONS] Called chrome.windows.getAll() - Step 3";
+  window_list->Append(ExtensionTabUtil::CreateWindowValueForExtension(
+      *browser, extension(), populate_tab_behavior, source_context_type()));
+  LOG(INFO) << "[EXTENSIONS] Called chrome.windows.getAll() - Step 4";
+#endif
 
   return RespondNow(OneArgument(std::move(window_list)));
 }
@@ -510,13 +560,14 @@ ExtensionFunction::ResponseAction WindowsCreateFunction::Run() {
                     &source_tab_strip, nullptr, &tab_index, &error)) {
       return RespondNow(Error(error));
     }
-
+#if 0
     if (!source_browser->window()->IsTabStripEditable())
       return RespondNow(Error(tabs_constants::kTabStripNotEditableError));
 
     if (source_browser->profile() != window_profile)
       return RespondNow(
           Error(tabs_constants::kCanOnlyMoveTabsWithinSameProfileError));
+#endif
   }
 
   if (!IsValidStateForWindowsCreateFunction(create_data))
@@ -674,6 +725,7 @@ ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
       windows::Update::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params);
 
+#if 0
   Browser* browser = nullptr;
   std::string error;
   if (!windows_util::GetBrowserFromWindowID(
@@ -795,6 +847,9 @@ ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
   return RespondNow(OneArgument(ExtensionTabUtil::CreateWindowValueForExtension(
       *browser, extension(), ExtensionTabUtil::kDontPopulateTabs,
       source_context_type())));
+#else
+  return RespondNow(Error(kUnknownErrorDoNotUse));
+#endif
 }
 
 ExtensionFunction::ResponseAction WindowsRemoveFunction::Run() {
@@ -802,6 +857,7 @@ ExtensionFunction::ResponseAction WindowsRemoveFunction::Run() {
       windows::Remove::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params);
 
+#if 0
   Browser* browser = nullptr;
   std::string error;
   if (!windows_util::GetBrowserFromWindowID(this, params->window_id,
@@ -825,17 +881,23 @@ ExtensionFunction::ResponseAction WindowsRemoveFunction::Run() {
   }
   controller->window()->Close();
   return RespondNow(NoArguments());
+#else
+  return RespondNow(Error(kUnknownErrorDoNotUse));
+#endif
 }
 
 // Tabs ------------------------------------------------------------------------
 
 ExtensionFunction::ResponseAction TabsGetSelectedFunction::Run() {
+#if 0
   // windowId defaults to "current" window.
   int window_id = extension_misc::kCurrentWindowId;
+#endif
 
   std::unique_ptr<tabs::GetSelected::Params> params(
       tabs::GetSelected::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
+#if 0
   if (params->window_id.get())
     window_id = *params->window_id;
 
@@ -851,12 +913,63 @@ ExtensionFunction::ResponseAction TabsGetSelectedFunction::Run() {
   return RespondNow(ArgumentList(tabs::Get::Results::Create(
       *CreateTabObjectHelper(contents, extension(), source_context_type(),
                              tab_strip, tab_strip->active_index()))));
+#else
+//  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 1";
+
+  std::unique_ptr<base::ListValue> result(new base::ListValue());
+//  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 4";
+//  Profile* profile = Profile::FromBrowserContext(browser_context());
+//  Browser* last_active_browser =
+//      chrome::FindAnyBrowser(profile, include_incognito());
+//  Browser* current_browser =
+//      ChromeExtensionFunctionDetails(this).GetCurrentBrowser();
+//  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 5: " << profile;
+//  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 5-1: " << last_active_browser;
+//  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 5-2: " << current_browser;
+//  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - IsOffTheRecordSessionActive: " << TabModelList::IsOffTheRecordSessionActive();
+  TabModel *tab_strip = nullptr;
+  if (!TabModelList::empty())
+    tab_strip = *(TabModelList::begin());
+//  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - TabModel: " << tab_strip;
+  if (tab_strip) {
+  //  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - TabModel - Open tabs: " << tab_strip->GetTabCount();
+  //  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - TabModel - Active index: " << tab_strip->GetActiveIndex();
+  //  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - TabModel - Last user-interacted active index: " << tab_strip->GetLastNonExtensionActiveIndex();
+    for (int i = 0; i < tab_strip->GetTabCount(); ++i) {
+      WebContents* web_contents = tab_strip->GetWebContentsAt(i);
+    //  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 5d-1 (tab loop)";
+
+      int openingTab = (tab_strip->GetLastNonExtensionActiveIndex());
+      if (openingTab == -1)
+        openingTab = 0;
+
+      if (i != openingTab)
+        continue;
+
+      if (!web_contents) {
+      //  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 5d-1b (there is no webcontents)";
+        continue;
+      }
+
+    //  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 5d-2";
+
+    //  LOG(INFO) << "[EXTENSIONS] TabsGetSelectedFunction::Run - Step 5d-5";
+
+      return RespondNow(ArgumentList(
+          tabs::Get::Results::Create(*CreateTabObjectHelper(
+              web_contents, extension(), source_context_type(), nullptr, i))));
+
+    }
+  }
+  return RespondNow(Error(tabs_constants::kNoSelectedTabError));
+#endif
 }
 
 ExtensionFunction::ResponseAction TabsGetAllInWindowFunction::Run() {
   std::unique_ptr<tabs::GetAllInWindow::Params> params(
       tabs::GetAllInWindow::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
+#if 0
   // windowId defaults to "current" window.
   int window_id = extension_misc::kCurrentWindowId;
   if (params->window_id.get())
@@ -869,6 +982,49 @@ ExtensionFunction::ResponseAction TabsGetAllInWindowFunction::Run() {
 
   return RespondNow(OneArgument(ExtensionTabUtil::CreateTabList(
       browser, extension(), source_context_type())));
+#else
+  LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 1";
+
+  std::unique_ptr<base::ListValue> result(new base::ListValue());
+  LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 2";
+  Profile* profile = Profile::FromBrowserContext(browser_context());
+  Browser* last_active_browser =
+      chrome::FindAnyBrowser(profile, include_incognito_information());
+  Browser* current_browser =
+      ChromeExtensionFunctionDetails(this).GetCurrentBrowser();
+  LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 3: " << profile;
+  LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 3-1: " << last_active_browser;
+  LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 3-2: " << current_browser;
+  LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - IsOffTheRecordSessionActive: " << TabModelList::IsOffTheRecordSessionActive();
+  TabModel *tab_strip = nullptr;
+  if (!TabModelList::empty())
+    tab_strip = *(TabModelList::begin());
+  LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - TabModel: " << tab_strip;
+  if (tab_strip) {
+    LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - TabModel - Open tabs: " << tab_strip->GetTabCount();
+    LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - TabModel - Active index: " << tab_strip->GetActiveIndex();
+    LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - TabModel - Last user-interacted active index: " << tab_strip->GetLastNonExtensionActiveIndex();
+    for (int i = 0; i < tab_strip->GetTabCount(); ++i) {
+      WebContents* web_contents = tab_strip->GetWebContentsAt(i);
+      LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 4d-1 (tab loop)";
+
+      if (!web_contents) {
+        LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 4d-1b (there is no webcontents)";
+        continue;
+      }
+
+      LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 4d-2";
+
+      result->Append(CreateTabObjectHelper(
+                         web_contents, extension(), source_context_type(),
+                         nullptr, i)
+                         ->ToValue());
+    }
+  }
+  LOG(INFO) << "[EXTENSIONS] TabsGetAllInWindowFunction::Run - Step 6";
+
+  return RespondNow(OneArgument(std::move(result)));
+#endif
 }
 
 ExtensionFunction::ResponseAction TabsQueryFunction::Run() {
@@ -876,10 +1032,13 @@ ExtensionFunction::ResponseAction TabsQueryFunction::Run() {
       tabs::Query::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 1";
+
   bool loading_status_set = params->query_info.status != tabs::TAB_STATUS_NONE;
   bool loading = params->query_info.status == tabs::TAB_STATUS_LOADING;
 
   URLPatternSet url_patterns;
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 2";
   if (params->query_info.url.get()) {
     std::vector<std::string> url_pattern_strings;
     if (params->query_info.url->as_string)
@@ -896,6 +1055,8 @@ ExtensionFunction::ResponseAction TabsQueryFunction::Run() {
     }
   }
 
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 3";
+
   std::string title;
   if (params->query_info.title.get())
     title = *params->query_info.title;
@@ -913,6 +1074,7 @@ ExtensionFunction::ResponseAction TabsQueryFunction::Run() {
     window_type = tabs::ToString(params->query_info.window_type);
 
   std::unique_ptr<base::ListValue> result(new base::ListValue());
+#if 0
   Profile* profile = Profile::FromBrowserContext(browser_context());
   Browser* last_active_browser =
       chrome::FindAnyBrowser(profile, include_incognito_information());
@@ -1008,7 +1170,51 @@ ExtensionFunction::ResponseAction TabsQueryFunction::Run() {
                        web_contents->IsAudioMuted())) {
         continue;
       }
+#else
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 4";
+//  Profile* profile = Profile::FromBrowserContext(browser_context());
+//  Browser* last_active_browser =
+//      chrome::FindAnyBrowser(profile, include_incognito());
+//  Browser* current_browser =
+//      ChromeExtensionFunctionDetails(this).GetCurrentBrowser();
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5: " << profile;
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5-1: " << last_active_browser;
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5-2: " << current_browser;
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - IsOffTheRecordSessionActive: " << TabModelList::IsOffTheRecordSessionActive();
+  TabModel *tab_strip = nullptr;
+  if (!TabModelList::empty())
+    tab_strip = *(TabModelList::begin());
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - TabModel: " << tab_strip;
+  if (tab_strip) {
+//    LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - TabModel - Open tabs: " << tab_strip->GetTabCount();
+//    LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - TabModel - Active index: " << tab_strip->GetActiveIndex();
+//    LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - TabModel - Last user-interacted active index: " << tab_strip->GetLastNonExtensionActiveIndex();
+    for (int i = 0; i < tab_strip->GetTabCount(); ++i) {
+       WebContents* web_contents = tab_strip->GetWebContentsAt(i);
+//      LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5d-1 (tab loop)";
+
+      if (index > -1 && i != index) {
+//        LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5d-1a (oob-index): " << i << " vs " << index;
+         continue;
+       }
+
+      int openingTab = (tab_strip->GetLastNonExtensionActiveIndex());
+      if (openingTab == -1)
+        openingTab = 0;
+
+       if (!MatchesBool(params->query_info.active.get(),
+       
+                       i == openingTab)) {
+         continue;
+       }
 
+      if (!web_contents) {
+//        LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5d-1b (there is no webcontents)";
+         continue;
+       }
+
+//      LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5d-2";
+#endif
       if (!title.empty() || !url_patterns.is_empty()) {
         // "title" and "url" properties are considered privileged data and can
         // only be checked if the extension has the "tabs" permission or it has
@@ -1034,14 +1240,23 @@ ExtensionFunction::ResponseAction TabsQueryFunction::Run() {
         }
       }
 
+//      LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5d-4";
+
       if (loading_status_set && loading != web_contents->IsLoading())
         continue;
-
+//      LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 5d-5";
+#if 0
       result->Append(CreateTabObjectHelper(web_contents, extension(),
                                            source_context_type(), tab_strip, i)
                          ->ToValue());
+#else
+      result->Append(CreateTabObjectHelper(web_contents, extension(),
+                                           source_context_type(), nullptr, i)
+                         ->ToValue());
+#endif
     }
   }
+//  LOG(INFO) << "[EXTENSIONS] TabsQueryFunction::Run - Step 6";
 
   return RespondNow(OneArgument(std::move(result)));
 }
@@ -1051,6 +1266,8 @@ ExtensionFunction::ResponseAction TabsCreateFunction::Run() {
       tabs::Create::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
+  LOG(INFO) << "[EXTENSIONS] Called chrome.tabs.create()";
+
   ExtensionTabUtil::OpenTabParams options;
   AssignOptionalValue(params->create_properties.window_id, &options.window_id);
   AssignOptionalValue(params->create_properties.opener_tab_id,
@@ -1130,14 +1347,23 @@ ExtensionFunction::ResponseAction TabsGetFunction::Run() {
 ExtensionFunction::ResponseAction TabsGetCurrentFunction::Run() {
   DCHECK(dispatcher());
 
+  LOG(INFO) << "[EXTENSIONS] TabsGetCurrentFunction - Step 1";
+
   // Return the caller, if it's a tab. If not the result isn't an error but an
   // empty tab (hence returning true).
   WebContents* caller_contents = GetSenderWebContents();
   std::unique_ptr<base::ListValue> results;
+  LOG(INFO) << "[EXTENSIONS] TabsGetCurrentFunction - Step 2";
   if (caller_contents && ExtensionTabUtil::GetTabId(caller_contents) >= 0) {
+    LOG(INFO) << "[EXTENSIONS] TabsGetCurrentFunction - Step 3";
     results = tabs::Get::Results::Create(*CreateTabObjectHelper(
         caller_contents, extension(), source_context_type(), nullptr, -1));
   }
+
+  if (results)
+    LOG(INFO) << "[EXTENSIONS] TabsGetCurrentFunction - Step 4 has results";
+  else
+    LOG(INFO) << "[EXTENSIONS] TabsGetCurrentFunction - Step 4 has no results";
   return RespondNow(results ? ArgumentList(std::move(results)) : NoArguments());
 }
 
@@ -1218,11 +1444,29 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
 
   int tab_id = -1;
   WebContents* contents = NULL;
+  TabModel *tab_strip = nullptr;
   if (!params->tab_id.get()) {
+#if 0
     Browser* browser = ChromeExtensionFunctionDetails(this).GetCurrentBrowser();
     if (!browser)
       return RespondNow(Error(tabs_constants::kNoCurrentWindowError));
     contents = browser->tab_strip_model()->GetActiveWebContents();
+#else
+    if (!TabModelList::empty())
+      tab_strip = *(TabModelList::begin());
+    if (tab_strip) {
+       for (int i = 0; i < tab_strip->GetTabCount(); ++i) {
+          int openingTab = (tab_strip->GetLastNonExtensionActiveIndex());
+          if (openingTab == -1)
+            openingTab = 0;
+
+          if (i != openingTab)
+            continue;
+
+          contents = tab_strip->GetWebContentsAt(i);
+       }
+    }
+#endif
     if (!contents)
       return RespondNow(Error(tabs_constants::kNoSelectedTabError));
     tab_id = SessionTabHelper::IdForTab(contents).id();
@@ -1231,9 +1475,12 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
   }
 
   int tab_index = -1;
+#if 0
   TabStripModel* tab_strip = NULL;
+#endif
   Browser* browser = nullptr;
   std::string error;
+#if 0
   if (!GetTabById(tab_id, browser_context(), include_incognito_information(),
                   &browser, &tab_strip, &contents, &tab_index, &error)) {
     return RespondNow(Error(error));
@@ -1241,7 +1488,12 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
 
   if (!ExtensionTabUtil::BrowserSupportsTabs(browser))
     return RespondNow(Error(tabs_constants::kNoCurrentWindowError));
-
+#else
+  if (!GetTabById(tab_id, browser_context(), include_incognito_information(),
+                  &browser, nullptr, &contents, &tab_index, &error)) {
+    return RespondNow(Error(error));
+  }
+#endif
   web_contents_ = contents;
 
   // TODO(rafaelw): handle setting remaining tab properties:
@@ -1251,11 +1503,13 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
   // Navigate the tab to a new location if the url is different.
   if (params->update_properties.url.get()) {
     std::string updated_url = *params->update_properties.url;
+#if 0
     if (browser->profile()->IsIncognitoProfile() &&
         !IsURLAllowedInIncognito(GURL(updated_url), browser->profile())) {
       return RespondNow(Error(ErrorUtils::FormatErrorMessage(
           tabs_constants::kURLsNotAllowedInIncognitoError, updated_url)));
     }
+#endif
     if (!UpdateURL(updated_url, tab_id, &error))
       return RespondNow(Error(error));
   }
@@ -1270,6 +1524,7 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
   if (params->update_properties.active.get())
     active = *params->update_properties.active;
 
+#if 0
   if (active) {
     if (tab_strip->active_index() != tab_index) {
       tab_strip->ActivateTabAt(tab_index);
@@ -1290,6 +1545,7 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
     // Update the tab index because it may move when being pinned.
     tab_index = tab_strip->GetIndexOfWebContents(contents);
   }
+#endif
 
   if (params->update_properties.muted.get() &&
       !chrome::SetTabAudioMuted(contents, *params->update_properties.muted,
@@ -1299,6 +1555,7 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
         base::NumberToString(tab_id))));
   }
 
+#if 0
   if (params->update_properties.opener_tab_id.get()) {
     int opener_id = *params->update_properties.opener_tab_id;
     WebContents* opener_contents = NULL;
@@ -1325,6 +1582,7 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
         web_contents_)
         ->SetAutoDiscardable(state);
   }
+#endif
 
   return RespondNow(GetResult());
 }
@@ -1462,7 +1720,11 @@ bool TabsMoveFunction::MoveTab(int tab_id,
   }
 
   // Don't let the extension move the tab if the user is dragging tabs.
+#if 0
   if (!source_browser->window()->IsTabStripEditable()) {
+#else
+  if (true) {
+#endif
     *error = tabs_constants::kTabStripNotEditableError;
     return false;
   }
@@ -1605,6 +1867,8 @@ ExtensionFunction::ResponseAction TabsRemoveFunction::Run() {
       tabs::Remove::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
+  LOG(INFO) << "[EXTENSIONS] Calling chrome.tabs.remove()";
+
   std::string error;
   if (params->tab_ids.as_integers) {
     std::vector<int>& tab_ids = *params->tab_ids.as_integers;
@@ -1629,10 +1893,13 @@ bool TabsRemoveFunction::RemoveTab(int tab_id, std::string* error) {
   }
 
   // Don't let the extension remove a tab if the user is dragging tabs around.
+#if 0
   if (!browser->window()->IsTabStripEditable()) {
     *error = tabs_constants::kTabStripNotEditableError;
     return false;
   }
+#endif
+
   // There's a chance that the tab is being dragged, or we're in some other
   // nested event loop. This code path ensures that the tab is safely closed
   // under such circumstances, whereas |TabStripModel::CloseWebContentsAt()|
@@ -1860,6 +2127,7 @@ ExecuteCodeInTabFunction::ExecuteCodeInTabFunction()
 ExecuteCodeInTabFunction::~ExecuteCodeInTabFunction() {}
 
 ExecuteCodeFunction::InitResult ExecuteCodeInTabFunction::Init() {
+  LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - Step 1";
   if (init_result_)
     return init_result_.value();
 
@@ -1876,9 +2144,11 @@ ExecuteCodeFunction::InitResult ExecuteCodeInTabFunction::Init() {
   if (!InjectDetails::Populate(*details_value, details.get()))
     return set_init_result(VALIDATION_FAILURE);
 
+  LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - Step 2";
   // If the tab ID wasn't given then it needs to be converted to the
   // currently active tab's ID.
   if (tab_id == -1) {
+#if 0
     Browser* browser = chrome_details_.GetCurrentBrowser();
     // Can happen during shutdown.
     if (!browser)
@@ -1888,10 +2158,48 @@ ExecuteCodeFunction::InitResult ExecuteCodeInTabFunction::Init() {
     if (!ExtensionTabUtil::GetDefaultTab(browser, &web_contents, &tab_id))
       return set_init_result_error(tabs_constants::kNoTabInBrowserWindowError);
   }
+#else
+    LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - Step 2a";
+    TabModel *tab_strip = nullptr;
+    if (!TabModelList::empty())
+      tab_strip = *(TabModelList::begin());
+    LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - TabModel: " << tab_strip;
+    if (tab_strip) {
+      LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - TabModel - Open tabs: " << tab_strip->GetTabCount();
+      LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - TabModel - Active index: " << tab_strip->GetActiveIndex();
+      LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - TabModel - Last user-interacted active index: " << tab_strip->GetLastNonExtensionActiveIndex();
+      for (int i = 0; i < tab_strip->GetTabCount(); ++i) {
+        WebContents* web_contents = tab_strip->GetWebContentsAt(i);
+        LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - Step 2aa-1 (tab loop)";
+
+        int openingTab = (tab_strip->GetLastNonExtensionActiveIndex());
+        if (openingTab == -1)
+          openingTab = 0;
+
+        if (i != openingTab)
+          continue;
+
+        if (web_contents && ExtensionTabUtil::GetTabId(web_contents) >= 0) {
+          tab_id = ExtensionTabUtil::GetTabId(web_contents);
+          LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - Step 2a (found) with id: " << tab_id;
+          break;
+        }
+      }
+    }
+  }
+  if (tab_id == -1) {
+    LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - Step 2b";
+    return set_init_result_error(tabs_constants::kNoCurrentWindowError);
+  }
+
+  LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - Step 3";
+#endif
 
   execute_tab_id_ = tab_id;
   details_ = std::move(details);
   set_host_id(HostID(HostID::EXTENSIONS, extension()->id()));
+
+  LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::Init - Step 4";
   return set_init_result(SUCCESS);
 }
 
@@ -1959,14 +2267,25 @@ ScriptExecutor* ExecuteCodeInTabFunction::GetScriptExecutor(
   Browser* browser = nullptr;
   content::WebContents* contents = nullptr;
 
+  LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::GetScriptExecutor - Step 1";
+
+#if 0
   bool success = GetTabById(execute_tab_id_, browser_context(),
                             include_incognito_information(), &browser, nullptr,
                             &contents, nullptr, error) &&
                  contents && browser;
+#else
+  bool success = GetTabById(execute_tab_id_, browser_context(),
+                            include_incognito_information(), &browser, nullptr,
+                            &contents, nullptr, error) &&
+                 contents;
 
+  LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::GetScriptExecutor - Step 2: " << contents << " - " << browser;
+#endif
   if (!success)
     return nullptr;
-
+  
+  LOG(INFO) << "[EXTENSIONS] ExecuteCodeInTabFunction::GetScriptExecutor - Step 3";
   return TabHelper::FromWebContents(contents)->script_executor();
 }
 
diff --git a/chrome/browser/extensions/api/tabs/tabs_event_router.cc b/chrome/browser/extensions/api/tabs/tabs_event_router.cc
index bc7b34ca36bf..0031fb3ca578 100644
--- a/chrome/browser/extensions/api/tabs/tabs_event_router.cc
+++ b/chrome/browser/extensions/api/tabs/tabs_event_router.cc
@@ -317,6 +317,7 @@ void TabsEventRouter::DispatchTabInsertedAt(TabStripModel* tab_strip_model,
                                             WebContents* contents,
                                             int index,
                                             bool active) {
+  LOG(INFO) << "[EXTENSIONS] TabsEventRouter::DispatchTabInsertedAt - Step 1";
   if (!GetTabEntry(contents)) {
     // We've never seen this tab, send create event as long as we're not in the
     // constructor.
@@ -344,6 +345,7 @@ void TabsEventRouter::DispatchTabInsertedAt(TabStripModel* tab_strip_model,
   DispatchEvent(profile, events::TABS_ON_ATTACHED,
                 api::tabs::OnAttached::kEventName, std::move(args),
                 EventRouter::USER_GESTURE_UNKNOWN);
+  LOG(INFO) << "[EXTENSIONS] TabsEventRouter::TabInsertedAt - Step 2";
 }
 
 void TabsEventRouter::DispatchTabClosingAt(TabStripModel* tab_strip_model,
@@ -359,7 +361,7 @@ void TabsEventRouter::DispatchTabClosingAt(TabStripModel* tab_strip_model,
   object_args->SetInteger(tabs_constants::kWindowIdKey,
                           ExtensionTabUtil::GetWindowIdOfTab(contents));
   object_args->SetBoolean(tabs_constants::kWindowClosing,
-                          tab_strip_model->closing_all());
+                          true);
   args->Append(std::move(object_args));
 
   Profile* profile = Profile::FromBrowserContext(contents->GetBrowserContext());
@@ -370,6 +372,31 @@ void TabsEventRouter::DispatchTabClosingAt(TabStripModel* tab_strip_model,
   UnregisterForTabNotifications(contents);
 }
 
+void TabsEventRouter::DispatchTabClosedAt(TabStripModel* tab_strip_model,
+                                   WebContents* contents,
+                                   int index, Profile *profile) {
+  int tab_id = ExtensionTabUtil::GetTabId(contents);
+
+  std::unique_ptr<base::ListValue> args(new base::ListValue);
+  args->AppendInteger(tab_id);
+
+  std::unique_ptr<base::DictionaryValue> object_args(
+      new base::DictionaryValue());
+  object_args->SetInteger(tabs_constants::kWindowIdKey,
+                          ExtensionTabUtil::GetWindowIdOfTab(contents));
+  object_args->SetBoolean(tabs_constants::kWindowClosing,
+                          true);
+  args->Append(std::move(object_args));
+
+  if (!profile)
+    profile = Profile::FromBrowserContext(contents->GetBrowserContext());
+  DispatchEvent(profile, events::TABS_ON_REMOVED, api::tabs::OnRemoved::kEventName,
+                std::move(args), EventRouter::USER_GESTURE_UNKNOWN);
+
+  UnregisterForTabNotifications(contents);
+}
+
+
 void TabsEventRouter::DispatchTabDetachedAt(WebContents* contents,
                                             int index,
                                             bool was_active) {
@@ -517,8 +544,9 @@ void TabsEventRouter::DispatchTabReplacedAt(WebContents* old_contents,
 
 void TabsEventRouter::TabCreatedAt(WebContents* contents,
                                    int index,
-                                   bool active) {
-  Profile* profile = Profile::FromBrowserContext(contents->GetBrowserContext());
+                                   bool active, Profile *profile) {
+  if (!profile)
+    profile = Profile::FromBrowserContext(contents->GetBrowserContext());
   std::unique_ptr<base::ListValue> args(new base::ListValue);
   auto event = std::make_unique<Event>(events::TABS_ON_CREATED,
                                        api::tabs::OnCreated::kEventName,
@@ -552,12 +580,14 @@ void TabsEventRouter::TabUpdated(TabEntry* entry,
 }
 
 void TabsEventRouter::FaviconUrlUpdated(WebContents* contents) {
+#if 0
   content::NavigationEntry* entry = contents->GetController().GetVisibleEntry();
   if (!entry || !entry->GetFavicon().valid)
     return;
   std::set<std::string> changed_property_names;
   changed_property_names.insert(tabs_constants::kFaviconUrlKey);
   DispatchTabUpdatedEvent(contents, std::move(changed_property_names));
+#endif
 }
 
 void TabsEventRouter::DispatchEvent(
@@ -608,6 +638,8 @@ void TabsEventRouter::DispatchTabUpdatedEvent(
 }
 
 void TabsEventRouter::RegisterForTabNotifications(WebContents* contents) {
+  if (true)
+    return;
   favicon_scoped_observer_.Add(
       favicon::ContentFaviconDriver::FromWebContents(contents));
 
@@ -619,6 +651,8 @@ void TabsEventRouter::RegisterForTabNotifications(WebContents* contents) {
 }
 
 void TabsEventRouter::UnregisterForTabNotifications(WebContents* contents) {
+  if (true)
+    return;
   favicon_scoped_observer_.Remove(
       favicon::ContentFaviconDriver::FromWebContents(contents));
 
diff --git a/chrome/browser/extensions/api/tabs/tabs_event_router.h b/chrome/browser/extensions/api/tabs/tabs_event_router.h
index e7335a902ae8..c6ff11ae978f 100644
--- a/chrome/browser/extensions/api/tabs/tabs_event_router.h
+++ b/chrome/browser/extensions/api/tabs/tabs_event_router.h
@@ -81,7 +81,9 @@ class TabsEventRouter : public TabStripModelObserver,
   void OnAutoDiscardableStateChange(content::WebContents* contents,
                                     bool is_auto_discardable) override;
 
+#if 0
  private:
+#endif
   // Methods called from OnTabStripModelChanged.
   void DispatchTabInsertedAt(TabStripModel* tab_strip_model,
                              content::WebContents* contents,
@@ -108,7 +110,10 @@ class TabsEventRouter : public TabStripModelObserver,
 
   // "Synthetic" event. Called from DispatchTabInsertedAt if new tab is
   // detected.
-  void TabCreatedAt(content::WebContents* contents, int index, bool active);
+  void TabCreatedAt(content::WebContents* contents, int index, bool active, Profile* profile = nullptr);
+  void DispatchTabClosedAt(TabStripModel* tab_strip_model,
+                           content::WebContents* contents,
+                           int index, Profile* profile);
 
   // Internal processing of tab updated events. Intended to be called when
   // there's any changed property.
diff --git a/chrome/browser/extensions/api/tabs/windows_event_router.cc b/chrome/browser/extensions/api/tabs/windows_event_router.cc
index 5f41fa24c34b..7c3a75fe261c 100644
--- a/chrome/browser/extensions/api/tabs/windows_event_router.cc
+++ b/chrome/browser/extensions/api/tabs/windows_event_router.cc
@@ -164,8 +164,6 @@ WindowsEventRouter::WindowsEventRouter(Profile* profile)
                  content::NotificationService::AllSources());
 #elif defined(TOOLKIT_VIEWS)
   views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
-#else
-#error Unsupported
 #endif
 
   AppWindowRegistry* registry = AppWindowRegistry::Get(profile_);
diff --git a/chrome/browser/extensions/bookmark_app_helper.cc b/chrome/browser/extensions/bookmark_app_helper.cc
new file mode 100644
index 000000000000..6929527c18c4
--- /dev/null
+++ b/chrome/browser/extensions/bookmark_app_helper.cc
@@ -0,0 +1,868 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/bookmark_app_helper.h"
+
+#include <stddef.h>
+
+#include <cctype>
+#include <string>
+#include <utility>
+
+#include "base/command_line.h"
+#include "base/feature_list.h"
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/time/time.h"
+#include "build/build_config.h"
+#include "chrome/browser/banners/app_banner_manager.h"
+#include "chrome/browser/banners/app_banner_manager_desktop.h"
+#include "chrome/browser/banners/app_banner_settings_helper.h"
+#include "chrome/browser/bitmap_fetcher/bitmap_fetcher.h"
+#include "chrome/browser/bitmap_fetcher/bitmap_fetcher_delegate.h"
+#include "chrome/browser/chrome_notification_types.h"
+#include "chrome/browser/extensions/convert_web_app.h"
+#include "chrome/browser/extensions/crx_installer.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/favicon_downloader.h"
+#include "chrome/browser/extensions/launch_util.h"
+#include "chrome/browser/extensions/tab_helper.h"
+#include "chrome/browser/installable/installable_data.h"
+#include "chrome/browser/installable/installable_manager.h"
+#include "chrome/browser/installable/installable_params.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/app_list/app_list_util.h"
+#include "chrome/browser/ui/browser_commands.h"
+#include "chrome/browser/ui/browser_dialogs.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/extensions/application_launch.h"
+#include "chrome/browser/web_applications/web_app.h"
+#include "chrome/browser/webshare/share_target_pref_helper.h"
+#include "chrome/common/chrome_features.h"
+#include "chrome/common/extensions/api/url_handlers/url_handlers_parser.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/common/extensions/manifest_handlers/app_launch_info.h"
+#include "chrome/common/origin_trials/chrome_origin_trial_policy.h"
+#include "chrome/common/url_constants.h"
+#include "chrome/grit/platform_locale_settings.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/navigation_controller.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/notification_source.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/content_switches.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/notification_types.h"
+#include "extensions/browser/pref_names.h"
+#include "extensions/common/constants.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/url_pattern.h"
+#include "net/base/load_flags.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+#include "net/url_request/url_request.h"
+#include "skia/ext/image_operations.h"
+#include "skia/ext/platform_canvas.h"
+#include "third_party/blink/public/common/manifest/web_display_mode.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/color_analysis.h"
+#include "ui/gfx/color_utils.h"
+#include "ui/gfx/font.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/image/canvas_image_source.h"
+#include "ui/gfx/image/image.h"
+
+#if defined(OS_MACOSX)
+#include "chrome/browser/web_applications/web_app_mac.h"
+#include "chrome/common/chrome_switches.h"
+#endif
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif  // defined(OS_WIN)
+
+#if defined(OS_CHROMEOS)
+// gn check complains on Linux Ozone.
+#include "ash/public/cpp/shelf_model.h"  // nogncheck
+#include "chrome/browser/ui/ash/launcher/chrome_launcher_controller.h"
+#endif
+
+namespace {
+
+using extensions::BookmarkAppHelper;
+
+// Overlays a shortcut icon over the bottom left corner of a given image.
+class GeneratedIconImageSource : public gfx::CanvasImageSource {
+ public:
+  explicit GeneratedIconImageSource(char letter, SkColor color, int output_size)
+      : gfx::CanvasImageSource(gfx::Size(output_size, output_size), false),
+        letter_(letter),
+        color_(color),
+        output_size_(output_size) {}
+  ~GeneratedIconImageSource() override {}
+
+ private:
+  // gfx::CanvasImageSource overrides:
+  void Draw(gfx::Canvas* canvas) override {
+    const uint8_t kLumaThreshold = 190;
+    const int icon_size = output_size_ * 3 / 4;
+    const int icon_inset = output_size_ / 8;
+    const size_t border_radius = output_size_ / 16;
+    const size_t font_size = output_size_ * 7 / 16;
+
+    std::string font_name =
+        l10n_util::GetStringUTF8(IDS_SANS_SERIF_FONT_FAMILY);
+#if defined(OS_CHROMEOS)
+    const std::string kChromeOSFontFamily = "Noto Sans";
+    font_name = kChromeOSFontFamily;
+#endif
+
+    // Draw a rounded rect of the given |color|.
+    cc::PaintFlags background_flags;
+    background_flags.setAntiAlias(true);
+    background_flags.setColor(color_);
+
+    gfx::Rect icon_rect(icon_inset, icon_inset, icon_size, icon_size);
+    canvas->DrawRoundRect(icon_rect, border_radius, background_flags);
+
+    // The text rect's size needs to be odd to center the text correctly.
+    gfx::Rect text_rect(icon_inset, icon_inset, icon_size + 1, icon_size + 1);
+    // Draw the letter onto the rounded rect. The letter's color depends on the
+    // luma of |color|.
+    const uint8_t luma = color_utils::GetLuma(color_);
+    canvas->DrawStringRectWithFlags(
+        base::string16(1, std::toupper(letter_)),
+        gfx::FontList(gfx::Font(font_name, font_size)),
+        (luma > kLumaThreshold) ? SK_ColorBLACK : SK_ColorWHITE,
+        text_rect,
+        gfx::Canvas::TEXT_ALIGN_CENTER);
+  }
+
+  char letter_;
+
+  SkColor color_;
+
+  int output_size_;
+
+  DISALLOW_COPY_AND_ASSIGN(GeneratedIconImageSource);
+};
+
+std::set<int> SizesToGenerate() {
+  // Generate container icons from smaller icons.
+  const int kIconSizesToGenerate[] = {
+      extension_misc::EXTENSION_ICON_SMALL,
+      extension_misc::EXTENSION_ICON_SMALL * 2,
+      extension_misc::EXTENSION_ICON_MEDIUM,
+      extension_misc::EXTENSION_ICON_MEDIUM * 2,
+      extension_misc::EXTENSION_ICON_LARGE,
+      extension_misc::EXTENSION_ICON_LARGE * 2,
+  };
+  return std::set<int>(kIconSizesToGenerate,
+                       kIconSizesToGenerate + arraysize(kIconSizesToGenerate));
+}
+
+void GenerateIcons(
+    std::set<int> generate_sizes,
+    const GURL& app_url,
+    SkColor generated_icon_color,
+    std::map<int, BookmarkAppHelper::BitmapAndSource>* bitmap_map) {
+  // The letter that will be painted on the generated icon.
+  char icon_letter = ' ';
+  std::string domain_and_registry(
+      net::registry_controlled_domains::GetDomainAndRegistry(
+          app_url,
+          net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES));
+  if (!domain_and_registry.empty()) {
+    icon_letter = domain_and_registry[0];
+  } else if (app_url.has_host()) {
+    icon_letter = app_url.host_piece()[0];
+  }
+
+  // If no color has been specified, use a dark gray so it will stand out on the
+  // black shelf.
+  if (generated_icon_color == SK_ColorTRANSPARENT)
+    generated_icon_color = SK_ColorDKGRAY;
+
+  for (int size : generate_sizes) {
+    extensions::BookmarkAppHelper::GenerateIcon(
+        bitmap_map, size, generated_icon_color, icon_letter);
+  }
+}
+
+void ReplaceWebAppIcons(
+    std::map<int, BookmarkAppHelper::BitmapAndSource> bitmap_map,
+    WebApplicationInfo* web_app_info) {
+  web_app_info->icons.clear();
+
+  // Populate the icon data into the WebApplicationInfo we are using to
+  // install the bookmark app.
+  for (const auto& pair : bitmap_map) {
+    WebApplicationInfo::IconInfo icon_info;
+    icon_info.data = pair.second.bitmap;
+    icon_info.url = pair.second.source_url;
+    icon_info.width = icon_info.data.width();
+    icon_info.height = icon_info.data.height();
+    web_app_info->icons.push_back(icon_info);
+  }
+}
+
+// Class to handle installing a bookmark app after it has synced. Handles
+// downloading and decoding the icons.
+class BookmarkAppInstaller : public base::RefCounted<BookmarkAppInstaller>,
+                             public content::WebContentsObserver {
+ public:
+  BookmarkAppInstaller(ExtensionService* service,
+                       const WebApplicationInfo& web_app_info)
+      : service_(service),
+        web_app_info_(web_app_info) {}
+
+  void Run() {
+    for (const auto& icon : web_app_info_.icons) {
+      if (icon.url.is_valid())
+        urls_to_download_.push_back(icon.url);
+    }
+
+    if (urls_to_download_.size()) {
+      // Matched in OnIconsDownloaded.
+      AddRef();
+      SetupWebContents();
+
+      return;
+    }
+
+    FinishInstallation();
+  }
+
+  void SetupWebContents() {
+    // Spin up a web contents process so we can use FaviconDownloader.
+    // This is necessary to make sure we pick up all of the images provided
+    // in favicon URLs. Without this, bookmark app sync can fail due to
+    // missing icons which are not correctly extracted from a favicon.
+    // (The eventual error indicates that there are missing files, which
+    // are the not-extracted favicon images).
+    //
+    // TODO(dominickn): refactor bookmark app syncing to reuse one web
+    // contents for all pending synced bookmark apps. This will avoid
+    // pathological cases where n renderers for n bookmark apps are spun up on
+    // first sign-in to a new machine.
+    web_contents_ = content::WebContents::Create(
+        content::WebContents::CreateParams(service_->profile()));
+    Observe(web_contents_.get());
+
+    // Load about:blank so that the process actually starts.
+    // Image download continues in DidFinishLoad.
+    content::NavigationController::LoadURLParams load_params(
+        GURL("about:blank"));
+    load_params.transition_type = ui::PAGE_TRANSITION_GENERATED;
+    web_contents_->GetController().LoadURLWithParams(load_params);
+  }
+
+  void DidFinishLoad(content::RenderFrameHost* render_frame_host,
+                     const GURL& validated_url) override {
+    favicon_downloader_.reset(new FaviconDownloader(
+        web_contents_.get(), urls_to_download_,
+        "Extensions.BookmarkApp.Icon.HttpStatusCodeClassOnSync",
+        base::BindOnce(&BookmarkAppInstaller::OnIconsDownloaded,
+                       base::Unretained(this))));
+
+    // Skip downloading the page favicons as everything in is the URL list.
+    favicon_downloader_->SkipPageFavicons();
+    favicon_downloader_->Start();
+  }
+
+ private:
+  friend class base::RefCounted<BookmarkAppInstaller>;
+  ~BookmarkAppInstaller() override {}
+
+  void OnIconsDownloaded(bool success,
+                         const std::map<GURL, std::vector<SkBitmap>>& bitmaps) {
+    // Ignore the unsuccessful case, as the necessary icons will be generated.
+    if (success) {
+      for (const auto& url_bitmaps : bitmaps) {
+        for (const auto& bitmap : url_bitmaps.second) {
+          // Only accept square icons.
+          if (bitmap.empty() || bitmap.width() != bitmap.height())
+            continue;
+
+          downloaded_bitmaps_.push_back(
+              BookmarkAppHelper::BitmapAndSource(url_bitmaps.first, bitmap));
+        }
+      }
+    }
+    FinishInstallation();
+    Release();
+  }
+
+  void FinishInstallation() {
+    // Ensure that all icons that are in web_app_info are present, by generating
+    // icons for any sizes which have failed to download. This ensures that the
+    // created manifest for the bookmark app does not contain links to icons
+    // which are not actually created and linked on disk.
+
+    // Ensure that all icon widths in the web app info icon array are present in
+    // the sizes to generate set. This ensures that we will have all of the
+    // icon sizes from when the app was originally added, even if icon URLs are
+    // no longer accessible.
+    std::set<int> sizes_to_generate = SizesToGenerate();
+    for (const auto& icon : web_app_info_.icons)
+      sizes_to_generate.insert(icon.width);
+
+    std::map<int, BookmarkAppHelper::BitmapAndSource> size_map =
+        BookmarkAppHelper::ResizeIconsAndGenerateMissing(
+            downloaded_bitmaps_, sizes_to_generate, &web_app_info_);
+    BookmarkAppHelper::UpdateWebAppIconsWithoutChangingLinks(size_map,
+                                                             &web_app_info_);
+    scoped_refptr<extensions::CrxInstaller> installer(
+        extensions::CrxInstaller::CreateSilent(service_));
+    installer->set_error_on_unsupported_requirements(true);
+    installer->InstallWebApp(web_app_info_);
+  }
+
+  ExtensionService* service_;
+  WebApplicationInfo web_app_info_;
+
+  std::unique_ptr<content::WebContents> web_contents_;
+  std::unique_ptr<FaviconDownloader> favicon_downloader_;
+  std::vector<GURL> urls_to_download_;
+  std::vector<BookmarkAppHelper::BitmapAndSource> downloaded_bitmaps_;
+};
+
+}  // namespace
+
+namespace extensions {
+
+// static
+void BookmarkAppHelper::UpdateWebAppInfoFromManifest(
+    const blink::Manifest& manifest,
+    WebApplicationInfo* web_app_info,
+    ForInstallableSite for_installable_site) {
+  if (!manifest.short_name.is_null())
+    web_app_info->title = manifest.short_name.string();
+
+  // Give the full length name priority.
+  if (!manifest.name.is_null())
+    web_app_info->title = manifest.name.string();
+
+  // Set the url based on the manifest value, if any.
+  if (manifest.start_url.is_valid())
+    web_app_info->app_url = manifest.start_url;
+
+  if (for_installable_site == ForInstallableSite::kYes) {
+    // If there is no scope present, use 'start_url' without the filename as the
+    // scope. This does not match the spec but it matches what we do on Android.
+    // See: https://github.com/w3c/manifest/issues/550
+    if (!manifest.scope.is_empty())
+      web_app_info->scope = manifest.scope;
+    else if (manifest.start_url.is_valid())
+      web_app_info->scope = manifest.start_url.Resolve(".");
+  }
+
+  if (manifest.theme_color)
+    web_app_info->theme_color = *manifest.theme_color;
+
+  // If any icons are specified in the manifest, they take precedence over any
+  // we picked up from the web_app stuff.
+  if (!manifest.icons.empty()) {
+    web_app_info->icons.clear();
+    for (const auto& icon : manifest.icons) {
+      // TODO(benwells): Take the declared icon density and sizes into account.
+      WebApplicationInfo::IconInfo info;
+      info.url = icon.src;
+      web_app_info->icons.push_back(info);
+    }
+  }
+}
+
+// static
+std::map<int, BookmarkAppHelper::BitmapAndSource>
+BookmarkAppHelper::ConstrainBitmapsToSizes(
+    const std::vector<BookmarkAppHelper::BitmapAndSource>& bitmaps,
+    const std::set<int>& sizes) {
+  std::map<int, BitmapAndSource> output_bitmaps;
+  std::map<int, BitmapAndSource> ordered_bitmaps;
+  for (const BitmapAndSource& bitmap_and_source : bitmaps) {
+    const SkBitmap& bitmap = bitmap_and_source.bitmap;
+    DCHECK(bitmap.width() == bitmap.height());
+    ordered_bitmaps[bitmap.width()] = bitmap_and_source;
+  }
+
+  if (ordered_bitmaps.size() > 0) {
+    for (const auto& size : sizes) {
+      // Find the closest not-smaller bitmap, or failing that use the largest
+      // icon available.
+      auto bitmaps_it = ordered_bitmaps.lower_bound(size);
+      if (bitmaps_it != ordered_bitmaps.end())
+        output_bitmaps[size] = bitmaps_it->second;
+      else
+        output_bitmaps[size] = ordered_bitmaps.rbegin()->second;
+
+      // Resize the bitmap if it does not exactly match the desired size.
+      if (output_bitmaps[size].bitmap.width() != size) {
+        output_bitmaps[size].bitmap = skia::ImageOperations::Resize(
+            output_bitmaps[size].bitmap, skia::ImageOperations::RESIZE_LANCZOS3,
+            size, size);
+      }
+    }
+  }
+
+  return output_bitmaps;
+}
+
+// static
+void BookmarkAppHelper::GenerateIcon(
+    std::map<int, BookmarkAppHelper::BitmapAndSource>* bitmaps,
+    int output_size,
+    SkColor color,
+    char letter) {
+  // Do nothing if there is already an icon of |output_size|.
+  if (bitmaps->count(output_size))
+    return;
+
+  gfx::ImageSkia icon_image(
+      std::make_unique<GeneratedIconImageSource>(letter, color, output_size),
+      gfx::Size(output_size, output_size));
+  SkBitmap& dst = (*bitmaps)[output_size].bitmap;
+  if (dst.tryAllocPixels(icon_image.bitmap()->info())) {
+    icon_image.bitmap()->readPixels(dst.info(), dst.getPixels(), dst.rowBytes(),
+                                    0, 0);
+  }
+}
+
+// static
+bool BookmarkAppHelper::BookmarkOrHostedAppInstalled(
+    content::BrowserContext* browser_context,
+    const GURL& url) {
+  ExtensionRegistry* registry = ExtensionRegistry::Get(browser_context);
+  const ExtensionSet& extensions = registry->enabled_extensions();
+
+  // Iterate through the extensions and extract the LaunchWebUrl (bookmark apps)
+  // or check the web extent (hosted apps).
+  for (const scoped_refptr<const Extension>& extension : extensions) {
+    if (!extension->is_hosted_app())
+      continue;
+
+    if (extension->web_extent().MatchesURL(url) ||
+        AppLaunchInfo::GetLaunchWebURL(extension.get()) == url) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// static
+std::map<int, BookmarkAppHelper::BitmapAndSource>
+BookmarkAppHelper::ResizeIconsAndGenerateMissing(
+    std::vector<BookmarkAppHelper::BitmapAndSource> icons,
+    std::set<int> sizes_to_generate,
+    WebApplicationInfo* web_app_info) {
+  // Resize provided icons to make sure we have versions for each size in
+  // |sizes_to_generate|.
+  std::map<int, BitmapAndSource> resized_bitmaps(
+      ConstrainBitmapsToSizes(icons, sizes_to_generate));
+
+  // Also add all provided icon sizes.
+  for (const BitmapAndSource& icon : icons) {
+    if (resized_bitmaps.find(icon.bitmap.width()) == resized_bitmaps.end())
+      resized_bitmaps.insert(std::make_pair(icon.bitmap.width(), icon));
+  }
+
+  // Determine the color that will be used for the icon's background. For this
+  // the dominant color of the first icon found is used.
+  if (resized_bitmaps.size()) {
+    color_utils::GridSampler sampler;
+    web_app_info->generated_icon_color =
+        color_utils::CalculateKMeanColorOfBitmap(
+            resized_bitmaps.begin()->second.bitmap);
+  }
+
+  // Work out what icons we need to generate here. Icons are only generated if
+  // there is no icon in the required size.
+  std::set<int> generate_sizes;
+  for (int size : sizes_to_generate) {
+    if (resized_bitmaps.find(size) == resized_bitmaps.end())
+      generate_sizes.insert(size);
+  }
+  GenerateIcons(generate_sizes, web_app_info->app_url,
+                web_app_info->generated_icon_color, &resized_bitmaps);
+
+  return resized_bitmaps;
+}
+
+// static
+void BookmarkAppHelper::UpdateWebAppIconsWithoutChangingLinks(
+    std::map<int, BookmarkAppHelper::BitmapAndSource> bitmap_map,
+    WebApplicationInfo* web_app_info) {
+  // First add in the icon data that have urls with the url / size data from the
+  // original web app info, and the data from the new icons (if any).
+  for (auto& icon : web_app_info->icons) {
+    if (!icon.url.is_empty() && icon.data.empty()) {
+      const auto& it = bitmap_map.find(icon.width);
+      if (it != bitmap_map.end() && it->second.source_url == icon.url)
+        icon.data = it->second.bitmap;
+    }
+  }
+
+  // Now add in any icons from the updated list that don't have URLs.
+  for (const auto& pair : bitmap_map) {
+    if (pair.second.source_url.is_empty()) {
+      WebApplicationInfo::IconInfo icon_info;
+      icon_info.data = pair.second.bitmap;
+      icon_info.width = pair.first;
+      icon_info.height = pair.first;
+      web_app_info->icons.push_back(icon_info);
+    }
+  }
+}
+
+BookmarkAppHelper::BitmapAndSource::BitmapAndSource() {
+}
+
+BookmarkAppHelper::BitmapAndSource::BitmapAndSource(const GURL& source_url_p,
+                                                    const SkBitmap& bitmap_p)
+    : source_url(source_url_p),
+      bitmap(bitmap_p) {
+}
+
+BookmarkAppHelper::BitmapAndSource::~BitmapAndSource() {
+}
+
+BookmarkAppHelper::BookmarkAppHelper(Profile* profile,
+                                     WebApplicationInfo web_app_info,
+                                     content::WebContents* contents,
+                                     WebappInstallSource install_source)
+    : profile_(profile),
+      contents_(contents),
+      web_app_info_(web_app_info),
+      crx_installer_(extensions::CrxInstaller::CreateSilent(
+          ExtensionSystem::Get(profile)->extension_service())),
+      install_source_(install_source),
+      weak_factory_(this) {
+  if (contents)
+    installable_manager_ = InstallableManager::FromWebContents(contents);
+
+  // Use the last bookmark app creation type. The launch container is decided by
+  // the system for desktop PWAs.
+  if (!base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {
+    web_app_info_.open_as_window =
+        profile_->GetPrefs()->GetInteger(
+            extensions::pref_names::kBookmarkAppCreationLaunchType) ==
+        extensions::LAUNCH_TYPE_WINDOW;
+  }
+
+  // The default app title is the page title, which can be quite long. Limit the
+  // default name used to something sensible.
+  const int kMaxDefaultTitle = 40;
+  if (web_app_info_.title.length() > kMaxDefaultTitle) {
+    web_app_info_.title = web_app_info_.title.substr(0, kMaxDefaultTitle - 3) +
+                          base::UTF8ToUTF16("...");
+  }
+
+  registrar_.Add(this,
+                 extensions::NOTIFICATION_CRX_INSTALLER_DONE,
+                 content::Source<CrxInstaller>(crx_installer_.get()));
+
+  registrar_.Add(this,
+                 extensions::NOTIFICATION_EXTENSION_INSTALL_ERROR,
+                 content::Source<CrxInstaller>(crx_installer_.get()));
+
+  crx_installer_->set_error_on_unsupported_requirements(true);
+}
+
+BookmarkAppHelper::~BookmarkAppHelper() {}
+
+void BookmarkAppHelper::Create(const CreateBookmarkAppCallback& callback) {
+  callback_ = callback;
+
+  // Do not fetch the manifest for extension URLs.
+  if (contents_ &&
+      !contents_->GetVisibleURL().SchemeIs(extensions::kExtensionScheme)) {
+    // Null in tests. OnDidPerformInstallableCheck is called via a testing API.
+    // TODO(crbug.com/829232) ensure this is consistent with other calls to
+    // GetData.
+    if (installable_manager_) {
+      InstallableParams params;
+      params.check_eligibility = true;
+      params.valid_primary_icon = true;
+      params.valid_manifest = true;
+      // Do not wait for a service worker if it doesn't exist.
+      params.has_worker = true;
+      installable_manager_->GetData(
+          params, base::Bind(&BookmarkAppHelper::OnDidPerformInstallableCheck,
+                             weak_factory_.GetWeakPtr()));
+    }
+  } else {
+    for_installable_site_ = ForInstallableSite::kNo;
+    OnIconsDownloaded(true, std::map<GURL, std::vector<SkBitmap>>());
+  }
+}
+
+void BookmarkAppHelper::OnDidPerformInstallableCheck(
+    const InstallableData& data) {
+  DCHECK(data.manifest_url.is_valid() || data.manifest->IsEmpty());
+
+  if (contents_->IsBeingDestroyed())
+    return;
+
+  for_installable_site_ = data.error_code == NO_ERROR_DETECTED
+                              ? ForInstallableSite::kYes
+                              : ForInstallableSite::kNo;
+
+  UpdateWebAppInfoFromManifest(*data.manifest, &web_app_info_,
+                               for_installable_site_);
+
+  // TODO(mgiuca): Web Share Target should have its own flag, rather than using
+  // the experimental-web-platform-features flag. https://crbug.com/736178.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kEnableExperimentalWebPlatformFeatures)) {
+    UpdateShareTargetInPrefs(data.manifest_url, *data.manifest,
+                             profile_->GetPrefs());
+  }
+
+  // Add icon urls to download from the WebApplicationInfo.
+  std::vector<GURL> web_app_info_icon_urls;
+  for (auto& info : web_app_info_.icons) {
+    if (!info.url.is_valid())
+      continue;
+
+    // Skip downloading icon if we already have it from the InstallableManager.
+    if (info.url == data.primary_icon_url && data.primary_icon)
+      continue;
+
+    web_app_info_icon_urls.push_back(info.url);
+  }
+
+  // Add the primary icon to the final bookmark app creation data.
+  if (data.primary_icon_url.is_valid()) {
+    WebApplicationInfo::IconInfo primary_icon_info;
+    const SkBitmap& icon = *data.primary_icon;
+    primary_icon_info.url = data.primary_icon_url;
+    primary_icon_info.data = icon;
+    primary_icon_info.width = icon.width();
+    primary_icon_info.height = icon.height();
+    web_app_info_.icons.push_back(primary_icon_info);
+  }
+
+  favicon_downloader_.reset(new FaviconDownloader(
+      contents_, web_app_info_icon_urls,
+      "Extensions.BookmarkApp.Icon.HttpStatusCodeClassOnCreate",
+      base::BindOnce(&BookmarkAppHelper::OnIconsDownloaded,
+                     weak_factory_.GetWeakPtr())));
+
+  // If the manifest specified icons, don't use the page icons.
+  if (!data.manifest->icons.empty())
+    favicon_downloader_->SkipPageFavicons();
+
+  favicon_downloader_->Start();
+}
+
+void BookmarkAppHelper::OnIconsDownloaded(
+    bool success,
+    const std::map<GURL, std::vector<SkBitmap>>& bitmaps) {
+  // The tab has navigated away during the icon download. Cancel the bookmark
+  // app creation.
+  if (!success) {
+    favicon_downloader_.reset();
+    callback_.Run(nullptr, web_app_info_);
+    return;
+  }
+
+  std::vector<BitmapAndSource> downloaded_icons;
+  for (const std::pair<GURL, std::vector<SkBitmap>>& url_bitmap : bitmaps) {
+    for (const SkBitmap& bitmap : url_bitmap.second) {
+      if (bitmap.empty() || bitmap.width() != bitmap.height())
+        continue;
+
+      downloaded_icons.push_back(BitmapAndSource(url_bitmap.first, bitmap));
+    }
+  }
+
+  // Add all existing icons from WebApplicationInfo.
+  for (const WebApplicationInfo::IconInfo& icon_info : web_app_info_.icons) {
+    const SkBitmap& icon = icon_info.data;
+    if (!icon.drawsNothing() && icon.width() == icon.height()) {
+      downloaded_icons.push_back(BitmapAndSource(icon_info.url, icon));
+    }
+  }
+
+  // Ensure that the necessary-sized icons are available by resizing larger
+  // icons down to smaller sizes, and generating icons for sizes where resizing
+  // is not possible.
+  web_app_info_.generated_icon_color = SK_ColorTRANSPARENT;
+  std::map<int, BitmapAndSource> size_to_icons = ResizeIconsAndGenerateMissing(
+      downloaded_icons, SizesToGenerate(), &web_app_info_);
+  ReplaceWebAppIcons(size_to_icons, &web_app_info_);
+  favicon_downloader_.reset();
+
+  if (!contents_) {
+    // The web contents can be null in tests.
+    OnBubbleCompleted(true, web_app_info_);
+    return;
+  }
+
+  Browser* browser = chrome::FindBrowserWithWebContents(contents_);
+  if (!browser) {
+    // The browser can be null in tests.
+    OnBubbleCompleted(true, web_app_info_);
+    return;
+  }
+
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing) &&
+      for_installable_site_ == ForInstallableSite::kYes) {
+    web_app_info_.open_as_window = true;
+    chrome::ShowPWAInstallDialog(
+        contents_, web_app_info_,
+        base::BindOnce(&BookmarkAppHelper::OnBubbleCompleted,
+                       weak_factory_.GetWeakPtr()));
+  } else {
+    chrome::ShowBookmarkAppDialog(
+        contents_, web_app_info_,
+        base::BindOnce(&BookmarkAppHelper::OnBubbleCompleted,
+                       weak_factory_.GetWeakPtr()));
+  }
+}
+
+void BookmarkAppHelper::OnBubbleCompleted(
+    bool user_accepted,
+    const WebApplicationInfo& web_app_info) {
+  if (user_accepted) {
+    web_app_info_ = web_app_info;
+    crx_installer_->InstallWebApp(web_app_info_);
+
+    if (InstallableMetrics::IsReportableInstallSource(install_source_) &&
+        for_installable_site_ == ForInstallableSite::kYes) {
+      InstallableMetrics::TrackInstallEvent(install_source_);
+    }
+  } else {
+    callback_.Run(nullptr, web_app_info_);
+  }
+}
+
+void BookmarkAppHelper::FinishInstallation(const Extension* extension) {
+  // Set the default 'open as' preference for use next time the dialog is
+  // shown.
+  extensions::LaunchType launch_type = web_app_info_.open_as_window
+                                           ? extensions::LAUNCH_TYPE_WINDOW
+                                           : extensions::LAUNCH_TYPE_REGULAR;
+
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {
+    DCHECK_NE(ForInstallableSite::kUnknown, for_installable_site_);
+    launch_type = for_installable_site_ == ForInstallableSite::kYes
+                      ? extensions::LAUNCH_TYPE_WINDOW
+                      : extensions::LAUNCH_TYPE_REGULAR;
+  }
+  profile_->GetPrefs()->SetInteger(
+      extensions::pref_names::kBookmarkAppCreationLaunchType, launch_type);
+
+  // Set the launcher type for the app.
+  extensions::SetLaunchType(profile_, extension->id(), launch_type);
+
+  if (!contents_) {
+    // The web contents can be null in tests.
+    callback_.Run(extension, web_app_info_);
+    return;
+  }
+
+  // Record an app banner added to homescreen event to ensure banners are not
+  // shown for this app.
+  AppBannerSettingsHelper::RecordBannerEvent(
+      contents_, web_app_info_.app_url, web_app_info_.app_url.spec(),
+      AppBannerSettingsHelper::APP_BANNER_EVENT_DID_ADD_TO_HOMESCREEN,
+      base::Time::Now());
+
+  Browser* browser = chrome::FindBrowserWithWebContents(contents_);
+  if (!browser) {
+    // The browser can be null in tests.
+    callback_.Run(extension, web_app_info_);
+    return;
+  }
+
+#if !defined(OS_CHROMEOS)
+  // Pin the app to the relevant launcher depending on the OS.
+  Profile* current_profile = profile_->GetOriginalProfile();
+#endif  // !defined(OS_CHROMEOS)
+
+// On Mac, shortcuts are automatically created for hosted apps when they are
+// installed, so there is no need to create them again.
+#if !defined(OS_MACOSX)
+#if !defined(OS_CHROMEOS)
+  web_app::ShortcutLocations creation_locations;
+#if defined(OS_LINUX) || defined(OS_WIN)
+  creation_locations.on_desktop = true;
+#else
+  creation_locations.on_desktop = false;
+#endif
+  creation_locations.applications_menu_location =
+      web_app::APP_MENU_LOCATION_SUBDIR_CHROMEAPPS;
+  creation_locations.in_quick_launch_bar = false;
+  web_app::CreateShortcuts(web_app::SHORTCUT_CREATION_BY_USER,
+                           creation_locations, current_profile, extension);
+#else
+  ChromeLauncherController::instance()->shelf_model()->PinAppWithID(
+      extension->id());
+#endif  // !defined(OS_CHROMEOS)
+
+  // Reparent the tab into an app window immediately when opening as a window.
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing) &&
+      launch_type == extensions::LAUNCH_TYPE_WINDOW &&
+      !profile_->IsOffTheRecord()) {
+    ReparentWebContentsIntoAppBrowser(contents_, extension);
+  }
+#endif  // !defined(OS_MACOSX)
+
+#if defined(OS_MACOSX)
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+                 switches::kDisableHostedAppShimCreation)) {
+    web_app::RevealAppShimInFinderForApp(current_profile, extension);
+  }
+#endif
+
+  callback_.Run(extension, web_app_info_);
+}
+
+void BookmarkAppHelper::Observe(int type,
+                                const content::NotificationSource& source,
+                                const content::NotificationDetails& details) {
+  // TODO(dominickn): bookmark app creation fails when extensions cannot be
+  // created (e.g. due to management policies). Add to shelf visibility should
+  // be gated on whether extensions can be created - see crbug.com/545541.
+  switch (type) {
+    case extensions::NOTIFICATION_CRX_INSTALLER_DONE: {
+      const Extension* extension =
+          content::Details<const Extension>(details).ptr();
+      if (extension) {
+        DCHECK_EQ(AppLaunchInfo::GetLaunchWebURL(extension),
+                  web_app_info_.app_url);
+        FinishInstallation(extension);
+      } else {
+        callback_.Run(nullptr, web_app_info_);
+      }
+      break;
+    }
+    case extensions::NOTIFICATION_EXTENSION_INSTALL_ERROR:
+      callback_.Run(nullptr, web_app_info_);
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+}
+
+void CreateOrUpdateBookmarkApp(ExtensionService* service,
+                               WebApplicationInfo* web_app_info) {
+  scoped_refptr<BookmarkAppInstaller> installer(
+      new BookmarkAppInstaller(service, *web_app_info));
+  installer->Run();
+}
+
+bool IsValidBookmarkAppUrl(const GURL& url) {
+  URLPattern origin_only_pattern(Extension::kValidBookmarkAppSchemes);
+  origin_only_pattern.SetMatchAllURLs(true);
+  return url.is_valid() && origin_only_pattern.MatchesURL(url);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/chrome_extensions_browser_client.cc b/chrome/browser/extensions/chrome_extensions_browser_client.cc
index d756f63cbc39..a343a02cd764 100644
--- a/chrome/browser/extensions/chrome_extensions_browser_client.cc
+++ b/chrome/browser/extensions/chrome_extensions_browser_client.cc
@@ -90,13 +90,20 @@ bool ExtensionsDisabled(const base::CommandLine& command_line) {
 }  // namespace
 
 ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient() {
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 1";
   AddAPIProvider(std::make_unique<CoreExtensionsBrowserAPIProvider>());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 2";
   AddAPIProvider(std::make_unique<ChromeExtensionsBrowserAPIProvider>());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 3";
 
   process_manager_delegate_.reset(new ChromeProcessManagerDelegate);
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 4";
   api_client_.reset(new ChromeExtensionsAPIClient);
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 5";
   SetCurrentChannel(chrome::GetChannel());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 6";
   resource_manager_.reset(new ChromeComponentExtensionResourceManager());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 7";
 }
 
 ChromeExtensionsBrowserClient::~ChromeExtensionsBrowserClient() {}
diff --git a/chrome/browser/extensions/chrome_process_manager_delegate.cc b/chrome/browser/extensions/chrome_process_manager_delegate.cc
index 2cfdb3380c10..3a94e6568f3d 100644
--- a/chrome/browser/extensions/chrome_process_manager_delegate.cc
+++ b/chrome/browser/extensions/chrome_process_manager_delegate.cc
@@ -30,6 +30,7 @@
 namespace extensions {
 
 ChromeProcessManagerDelegate::ChromeProcessManagerDelegate() {
+  LOG(ERROR) << "[Kiwi] ChromeProcessManagerDelegate::ChromeProcessManagerDelegate - Step 1";
   BrowserList::AddObserver(this);
   DCHECK(g_browser_process);
   // The profile manager can be null in unit tests.
diff --git a/chrome/browser/extensions/extension_install_prompt.cc b/chrome/browser/extensions/extension_install_prompt.cc
index 613f22f4fee6..3e60ccfe7234 100644
--- a/chrome/browser/extensions/extension_install_prompt.cc
+++ b/chrome/browser/extensions/extension_install_prompt.cc
@@ -20,6 +20,9 @@
 #include "chrome/browser/ui/extensions/extension_install_ui_factory.h"
 #include "chrome/grit/generated_resources.h"
 #include "chrome/grit/theme_resources.h"
+#include "components/app_modal/javascript_app_modal_dialog.h"
+#include "components/app_modal/javascript_dialog_manager.h"
+#include "components/app_modal/native_app_modal_dialog.h"
 #include "components/strings/grit/components_strings.h"
 #include "content/public/browser/web_contents.h"
 #include "extensions/browser/disable_reason.h"
@@ -379,6 +382,17 @@ base::string16 ExtensionInstallPrompt::Prompt::GetUserCount() const {
   return base::string16();
 }
 
+base::string16 ExtensionInstallPrompt::Prompt::GetPermissionsAsString() const {
+  base::string16 result = base::string16();
+  result = result + GetDialogTitle() + base::ASCIIToUTF16("\n") + base::ASCIIToUTF16("\n");
+  result = result + GetPermissionsHeading() + base::ASCIIToUTF16("\n") + base::ASCIIToUTF16("\n");
+  result = result + base::JoinString(prompt_permissions_.permissions,
+                                     base::ASCIIToUTF16("\n")) + base::ASCIIToUTF16("\n");
+  result = result + base::JoinString(prompt_permissions_.details,
+                                     base::ASCIIToUTF16("\n"));
+  return result;
+}
+
 size_t ExtensionInstallPrompt::Prompt::GetPermissionCount() const {
   return prompt_permissions_.permissions.size();
 }
@@ -488,6 +502,7 @@ ExtensionInstallPrompt::ExtensionInstallPrompt(content::WebContents* contents)
                    : nullptr),
       extension_(nullptr),
       install_ui_(extensions::CreateExtensionInstallUI(profile_)),
+      contents_(contents),
       show_params_(new ExtensionInstallPromptShowParams(contents)),
       did_call_show_dialog_(false) {}
 
@@ -609,6 +624,37 @@ void ExtensionInstallPrompt::LoadImageIfNeeded() {
                                          weak_factory_.GetWeakPtr()));
 }
 
+// Ensures that OnDialogClosed is only called once.
+class CloseDialogCallbackWrapper
+    : public base::RefCountedThreadSafe<CloseDialogCallbackWrapper> {
+ public:
+  explicit CloseDialogCallbackWrapper(ExtensionInstallPrompt::DoneCallback callback)
+      : callback_(std::move(callback)) {}
+
+  void Run(bool dialog_was_suppressed,
+           bool success,
+           const base::string16& user_input) {
+  if (success) {
+    LOG(INFO) << "[EXTENSIONS] We received result from extension dialog (ACCEPTED)";
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+         FROM_HERE, base::BindOnce(std::move(callback_),
+                                  ExtensionInstallPrompt::Result::ACCEPTED));
+  } else {
+    LOG(INFO) << "[EXTENSIONS] We received result from extension dialog (REJECTED)";
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+         FROM_HERE,
+         base::BindOnce(std::move(callback_),
+                        ExtensionInstallPrompt::Result::USER_CANCELED));
+  }
+  }
+
+ private:
+  friend class base::RefCountedThreadSafe<CloseDialogCallbackWrapper>;
+  ~CloseDialogCallbackWrapper() {}
+
+  ExtensionInstallPrompt::DoneCallback callback_;
+};
+
 void ExtensionInstallPrompt::ShowConfirmation() {
   std::unique_ptr<const PermissionSet> permissions_wrapper;
   const PermissionSet* permissions_to_display = nullptr;
@@ -659,6 +705,23 @@ void ExtensionInstallPrompt::ShowConfirmation() {
   if (AutoConfirmPromptIfEnabled())
     return;
 
+  if (contents_) {
+    LOG(INFO) << "[EXTENSIONS] contents_ is not empty, displaying prompt";
+    scoped_refptr<CloseDialogCallbackWrapper> wrapper = new CloseDialogCallbackWrapper(std::move(done_callback_));
+
+    if (permissions_to_display) {
+      bool ignored;
+      app_modal::JavaScriptDialogManager::GetInstance()->RunJavaScriptDialog(
+          contents_, contents_->GetMainFrame(), content::JAVASCRIPT_DIALOG_TYPE_CONFIRM,
+          prompt_->GetPermissionsAsString(), base::string16(),
+                   base::BindOnce(&CloseDialogCallbackWrapper::Run, wrapper, false),
+                   &ignored);
+    }
+  } else {
+    LOG(INFO) << "[EXTENSIONS] contents_ is empty, skipping prompt";
+  }
+
+#if 0
   if (show_dialog_callback_.is_null())
     show_dialog_callback_ = GetDefaultShowDialogCallback();
   // TODO(https://crbug.com/957713): Use OnceCallback and eliminate the need for
@@ -666,6 +729,7 @@ void ExtensionInstallPrompt::ShowConfirmation() {
   auto cb = std::move(done_callback_);
   std::move(show_dialog_callback_)
       .Run(show_params_.get(), cb, std::move(prompt_));
+#endif
 }
 
 bool ExtensionInstallPrompt::AutoConfirmPromptIfEnabled() {
diff --git a/chrome/browser/extensions/extension_install_prompt.h b/chrome/browser/extensions/extension_install_prompt.h
index dcea843a6d71..a0a5ecfb1162 100644
--- a/chrome/browser/extensions/extension_install_prompt.h
+++ b/chrome/browser/extensions/extension_install_prompt.h
@@ -19,6 +19,7 @@
 #include "base/strings/string16.h"
 #include "base/threading/thread_checker.h"
 #include "build/build_config.h"
+#include "components/app_modal/javascript_app_modal_dialog.h"
 #include "extensions/common/permissions/permission_message.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/gfx/image/image.h"
@@ -123,6 +124,7 @@ class ExtensionInstallPrompt {
     void AppendRatingStars(StarAppender appender, void* data) const;
     base::string16 GetRatingCount() const;
     base::string16 GetUserCount() const;
+    base::string16 GetPermissionsAsString() const;
     size_t GetPermissionCount() const;
     size_t GetPermissionsDetailsCount() const;
     base::string16 GetPermission(size_t index) const;
@@ -347,6 +349,8 @@ class ExtensionInstallPrompt {
   // The object responsible for doing the UI specific actions.
   std::unique_ptr<extensions::ExtensionInstallUI> install_ui_;
 
+  content::WebContents* contents_;
+
   // Parameters to show the confirmation UI.
   std::unique_ptr<ExtensionInstallPromptShowParams> show_params_;
 
diff --git a/chrome/browser/extensions/extension_install_prompt_show_params.cc b/chrome/browser/extensions/extension_install_prompt_show_params.cc
index 421bf95cad3d..ddcb8cd23c15 100644
--- a/chrome/browser/extensions/extension_install_prompt_show_params.cc
+++ b/chrome/browser/extensions/extension_install_prompt_show_params.cc
@@ -53,8 +53,6 @@ ExtensionInstallPromptShowParams::ExtensionInstallPromptShowParams(
     web_contents_destruction_observer_.reset(
         new WebContentsDestructionObserver(this));
   }
-  if (parent_window_)
-    native_window_tracker_ = NativeWindowTracker::Create(parent_window_);
 }
 
 ExtensionInstallPromptShowParams::ExtensionInstallPromptShowParams(
@@ -64,8 +62,6 @@ ExtensionInstallPromptShowParams::ExtensionInstallPromptShowParams(
     parent_web_contents_(nullptr),
     parent_web_contents_destroyed_(false),
     parent_window_(parent_window) {
-  if (parent_window_)
-    native_window_tracker_ = NativeWindowTracker::Create(parent_window_);
 }
 
 ExtensionInstallPromptShowParams::~ExtensionInstallPromptShowParams() {
diff --git a/chrome/browser/extensions/extension_uninstall_dialog.cc b/chrome/browser/extensions/extension_uninstall_dialog.cc
index e8953ab88e5b..87b2ef637722 100644
--- a/chrome/browser/extensions/extension_uninstall_dialog.cc
+++ b/chrome/browser/extensions/extension_uninstall_dialog.cc
@@ -71,8 +71,10 @@ ExtensionUninstallDialog::ExtensionUninstallDialog(
     gfx::NativeWindow parent,
     ExtensionUninstallDialog::Delegate* delegate)
     : profile_(profile), parent_(parent), delegate_(delegate) {
+#if 0
   if (parent)
     parent_window_tracker_ = NativeWindowTracker::Create(parent);
+#endif
 }
 
 ExtensionUninstallDialog::~ExtensionUninstallDialog() = default;
diff --git a/chrome/browser/extensions/global_shortcut_listener_android.cc b/chrome/browser/extensions/global_shortcut_listener_android.cc
new file mode 100644
index 000000000000..c1e8bbbfaa25
--- /dev/null
+++ b/chrome/browser/extensions/global_shortcut_listener_android.cc
@@ -0,0 +1,64 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/global_shortcut_listener_android.h"
+
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace extensions {
+
+// static
+GlobalShortcutListener* GlobalShortcutListener::GetInstance() {
+  CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+  static GlobalShortcutListenerAndroid* instance =
+      new GlobalShortcutListenerAndroid();
+  return instance;
+}
+
+GlobalShortcutListenerAndroid::GlobalShortcutListenerAndroid()
+    : is_listening_(false) {
+  CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  // TODO(implementor): Remove this.
+  LOG(ERROR) << "GlobalShortcutListenerAndroid object created";
+}
+
+GlobalShortcutListenerAndroid::~GlobalShortcutListenerAndroid() {
+  if (is_listening_)
+    StopListening();
+}
+
+void GlobalShortcutListenerAndroid::StartListening() {
+  DCHECK(!is_listening_);  // Don't start twice.
+  NOTIMPLEMENTED();
+  is_listening_ = true;
+}
+
+void GlobalShortcutListenerAndroid::StopListening() {
+  DCHECK(is_listening_);  // No point if we are not already listening.
+  NOTIMPLEMENTED();
+  is_listening_ = false;
+}
+
+bool GlobalShortcutListenerAndroid::RegisterAcceleratorImpl(
+    const ui::Accelerator& accelerator) {
+  NOTIMPLEMENTED();
+  // To implement:
+  // 1) Convert modifiers to platform specific modifiers.
+  // 2) Register for the hotkey.
+  // 3) If not successful, return false.
+  // 4) Else, return true.
+
+  return false;
+}
+
+void GlobalShortcutListenerAndroid::UnregisterAcceleratorImpl(
+    const ui::Accelerator& accelerator) {
+  NOTIMPLEMENTED();
+  // To implement: Unregister for the hotkey.
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/global_shortcut_listener_android.h b/chrome/browser/extensions/global_shortcut_listener_android.h
new file mode 100644
index 000000000000..8cfa82509fd2
--- /dev/null
+++ b/chrome/browser/extensions/global_shortcut_listener_android.h
@@ -0,0 +1,36 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+
+#include "base/macros.h"
+#include "chrome/browser/extensions/global_shortcut_listener.h"
+
+namespace extensions {
+
+// Android-specific implementation of the GlobalShortcutListener class that
+// listens for global shortcuts. Handles basic keyboard intercepting and
+// forwards its output to the base class for processing.
+class GlobalShortcutListenerAndroid : public GlobalShortcutListener {
+ public:
+  GlobalShortcutListenerAndroid();
+  ~GlobalShortcutListenerAndroid() override;
+
+ private:
+  // GlobalShortcutListener implementation.
+  void StartListening() override;
+  void StopListening() override;
+  bool RegisterAcceleratorImpl(const ui::Accelerator& accelerator) override;
+  void UnregisterAcceleratorImpl(const ui::Accelerator& accelerator) override;
+
+  // Whether this object is listening for global shortcuts.
+  bool is_listening_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlobalShortcutListenerAndroid);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
diff --git a/chrome/browser/extensions/system_display/display_info_provider_android.cc b/chrome/browser/extensions/system_display/display_info_provider_android.cc
new file mode 100644
index 000000000000..a2edbd695ed6
--- /dev/null
+++ b/chrome/browser/extensions/system_display/display_info_provider_android.cc
@@ -0,0 +1,17 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/system_display/display_info_provider_android.h"
+
+namespace extensions {
+
+DisplayInfoProviderAndroid::DisplayInfoProviderAndroid() = default;
+
+// static
+std::unique_ptr<DisplayInfoProvider> CreateChromeDisplayInfoProvider() {
+  return std::make_unique<DisplayInfoProviderAndroid>();
+}
+
+}  // namespace extensions
+
diff --git a/chrome/browser/extensions/system_display/display_info_provider_android.h b/chrome/browser/extensions/system_display/display_info_provider_android.h
new file mode 100644
index 000000000000..7cd339ce6d2e
--- /dev/null
+++ b/chrome/browser/extensions/system_display/display_info_provider_android.h
@@ -0,0 +1,24 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+
+#include "base/macros.h"
+#include "extensions/browser/api/system_display/display_info_provider.h"
+
+namespace extensions {
+
+class DisplayInfoProviderAndroid : public DisplayInfoProvider {
+ public:
+  DisplayInfoProviderAndroid();
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DisplayInfoProviderAndroid);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+
diff --git a/chrome/browser/first_run/first_run_dialog.h b/chrome/browser/first_run/first_run_dialog.h
index ac9e76fb6044..25c288c899b7 100644
--- a/chrome/browser/first_run/first_run_dialog.h
+++ b/chrome/browser/first_run/first_run_dialog.h
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 
 // Hide this function on platforms where the dialog does not exist.
-#if defined(OS_MACOSX) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if true || defined(OS_MACOSX) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 
 class Profile;
 
diff --git a/chrome/browser/first_run/first_run_internal_android.cc b/chrome/browser/first_run/first_run_internal_android.cc
new file mode 100644
index 000000000000..2e90a1b76983
--- /dev/null
+++ b/chrome/browser/first_run/first_run_internal_android.cc
@@ -0,0 +1,24 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/first_run/first_run_internal.h"
+
+#include "base/base_paths.h"
+#include "base/files/file_path.h"
+#include "base/path_service.h"
+#include "chrome/installer/util/master_preferences.h"
+
+namespace first_run {
+namespace internal {
+
+base::FilePath MasterPrefsPath() {
+  // The standard location of the master prefs is next to the chrome binary.
+  base::FilePath master_prefs;
+  if (!base::PathService::Get(base::DIR_EXE, &master_prefs))
+    return base::FilePath();
+  return master_prefs.AppendASCII(installer::kDefaultMasterPrefs);
+}
+
+}  // namespace internal
+}  // namespace first_run
diff --git a/chrome/browser/first_run/first_run_internal_posix.cc b/chrome/browser/first_run/first_run_internal_posix.cc
index db313b4d05f5..d57371017d2f 100644
--- a/chrome/browser/first_run/first_run_internal_posix.cc
+++ b/chrome/browser/first_run/first_run_internal_posix.cc
@@ -96,7 +96,7 @@ void ForceFirstRunDialogShownForTesting(bool shown) {
 }
 
 void DoPostImportPlatformSpecificTasks(Profile* profile) {
-#if !defined(OS_CHROMEOS)
+#if false && !defined(OS_CHROMEOS)
   if (!ShouldShowFirstRunDialog())
     return;
 
diff --git a/chrome/browser/first_run/upgrade_util.cc b/chrome/browser/first_run/upgrade_util.cc
index 68b4dfba2983..d34234f1e169 100644
--- a/chrome/browser/first_run/upgrade_util.cc
+++ b/chrome/browser/first_run/upgrade_util.cc
@@ -33,7 +33,7 @@ bool RelaunchChromeBrowser(const base::CommandLine& command_line) {
   if (relaunch_chrome_browser_callback_for_testing)
     return relaunch_chrome_browser_callback_for_testing->Run(command_line);
 
-  return RelaunchChromeBrowserImpl(command_line);
+  return false; //RelaunchChromeBrowserImpl(command_line);
 }
 
 #if !defined(OS_MACOSX)
diff --git a/chrome/browser/first_run/upgrade_util.h b/chrome/browser/first_run/upgrade_util.h
index 859b9a096342..a1705d552cb0 100644
--- a/chrome/browser/first_run/upgrade_util.h
+++ b/chrome/browser/first_run/upgrade_util.h
@@ -10,10 +10,6 @@
 #include "base/callback_forward.h"
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
-#error Not used on Android or ChromeOS
-#endif
-
 namespace base {
 class CommandLine;
 }
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 3d2c833c5bcd..7795bd08d81b 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -2853,8 +2853,6 @@ const char kAndroidNightModeDescription[] =
 
 // Non-Android -----------------------------------------------------------------
 
-#else  // !defined(OS_ANDROID)
-
 const char kShowSyncPausedReasonCookiesClearedOnExitName[] =
     "Show sync paused reason is the setup of cookie settings.";
 const char kShowSyncPausedReasonCookiesClearedOnExitDescription[] =
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index ead5a211c65a..5a07bef82a42 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1669,8 +1669,6 @@ extern const char kAndroidNightModeDescription[];
 
 // Non-Android ----------------------------------------------------------------
 
-#else  // !defined(OS_ANDROID)
-
 extern const char kShowSyncPausedReasonCookiesClearedOnExitName[];
 extern const char kShowSyncPausedReasonCookiesClearedOnExitDescription[];
 
diff --git a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc
index 95c306cc0c1a..c44940a0a4ac 100644
--- a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc
+++ b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc
@@ -87,10 +87,12 @@ void ChromeWebViewPermissionHelperDelegate::OnPermissionResponse(
     const std::string& identifier,
     bool allow,
     const std::string& input) {
+#if 0
   if (allow) {
     ChromePluginServiceFilter::GetInstance()->AuthorizeAllPlugins(
         web_contents(), true, identifier);
   }
+#endif
 }
 
 #endif  // BUILDFLAG(ENABLE_PLUGINS)
diff --git a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h
index 40ae43bedc11..b3a8ff24c293 100644
--- a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h
+++ b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h
@@ -14,7 +14,7 @@
 #include "ppapi/buildflags/buildflags.h"
 #include "third_party/blink/public/mojom/permissions/permission_status.mojom.h"
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
 #include "chrome/common/plugin.mojom.h"
 #endif
 
@@ -51,7 +51,7 @@ class ChromeWebViewPermissionHelperDelegate
       const GURL& url,
       bool allowed_by_default,
       base::OnceCallback<void(bool)> callback) override;
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
   // content::WebContentsObserver implementation.
   bool OnMessageReceived(const IPC::Message& message,
                          content::RenderFrameHost* render_frame_host) override;
diff --git a/chrome/browser/media/router/BUILD.gn b/chrome/browser/media/router/BUILD.gn
index 6ac998b85586..0c9cb12e6b30 100644
--- a/chrome/browser/media/router/BUILD.gn
+++ b/chrome/browser/media/router/BUILD.gn
@@ -209,7 +209,7 @@ static_library("test_support") {
     "test/test_helper.h",
   ]
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     deps += [
       "discovery",
       "//chrome/common/media_router/mojom:media_router",
diff --git a/chrome/browser/media/router/discovery/BUILD.gn b/chrome/browser/media/router/discovery/BUILD.gn
index c5e3bf578869..c9358cc04d0f 100644
--- a/chrome/browser/media/router/discovery/BUILD.gn
+++ b/chrome/browser/media/router/discovery/BUILD.gn
@@ -2,8 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android)
-
 static_library("discovery") {
   inputs = [
     "$root_gen_dir/chrome/grit/generated_resources.h",
@@ -77,7 +75,7 @@ static_library("discovery") {
     sources += [ "discovery_network_list_wifi_linux.cc" ]
   }
 
-  if (is_posix) {
+  if (false && is_posix) {
     sources += [ "discovery_network_list_posix.cc" ]
   }
 
diff --git a/chrome/browser/media/router/discovery/dial/dial_media_sink_service_impl.cc b/chrome/browser/media/router/discovery/dial/dial_media_sink_service_impl.cc
index 94695b9f51e4..c55f39a59b13 100644
--- a/chrome/browser/media/router/discovery/dial/dial_media_sink_service_impl.cc
+++ b/chrome/browser/media/router/discovery/dial/dial_media_sink_service_impl.cc
@@ -152,17 +152,17 @@ void DialMediaSinkServiceImpl::OnDiscoveryComplete() {
 
   // Note: calling |AddOrUpdateSink()| or |RemoveSink()| here won't cause the
   // discovery timer to fire again, since it is considered to be still running.
-  for (const auto& sink : sinks_to_update)
-    AddOrUpdateSink(sink);
+//  for (const auto& sink : sinks_to_update)
+//    AddOrUpdateSink(sink);
 
-  for (const auto& sink : sinks_to_remove)
-    RemoveSink(sink);
+//  for (const auto& sink : sinks_to_remove)
+//    RemoveSink(sink);
 
   // If discovered sinks are updated, then query results might have changed.
   for (const auto& query : sink_queries_)
     query.second->Notify(query.first);
 
-  MediaSinkServiceBase::OnDiscoveryComplete();
+  //MediaSinkServiceBase::OnDiscoveryComplete();
 }
 
 void DialMediaSinkServiceImpl::OnDialDeviceEvent(
diff --git a/chrome/browser/media/router/discovery/discovery_network_monitor.cc b/chrome/browser/media/router/discovery/discovery_network_monitor.cc
index 7b00fc90753d..1d1e69bb2ec6 100644
--- a/chrome/browser/media/router/discovery/discovery_network_monitor.cc
+++ b/chrome/browser/media/router/discovery/discovery_network_monitor.cc
@@ -89,8 +89,8 @@ void DiscoveryNetworkMonitor::GetNetworkId(NetworkIdCallback callback) {
       std::move(callback));
 }
 
-DiscoveryNetworkMonitor::DiscoveryNetworkMonitor()
-    : DiscoveryNetworkMonitor(&GetDiscoveryNetworkInfoList) {}
+DiscoveryNetworkMonitor::DiscoveryNetworkMonitor() {}
+//    : DiscoveryNetworkMonitor(&GetDiscoveryNetworkInfoList) {}
 
 DiscoveryNetworkMonitor::DiscoveryNetworkMonitor(NetworkInfoFunction strategy)
     : network_id_(kNetworkIdDisconnected),
diff --git a/chrome/browser/media/router/discovery/mdns/cast_media_sink_service_impl.cc b/chrome/browser/media/router/discovery/mdns/cast_media_sink_service_impl.cc
index 4b5f4b9741ad..7a535bd70d6f 100644
--- a/chrome/browser/media/router/discovery/mdns/cast_media_sink_service_impl.cc
+++ b/chrome/browser/media/router/discovery/mdns/cast_media_sink_service_impl.cc
@@ -343,7 +343,7 @@ void CastMediaSinkServiceImpl::OnError(const cast_channel::CastSocket& socket,
   // sink. We would set it to ERROR here. In OpenChannel(), we would check
   // create a socket only if the state is not already CONNECTED.
   MediaSinkInternal sink = sink_it->second;
-  RemoveSink(sink);
+//  RemoveSink(sink);
 
   // If socket is not opened yet, then |OnChannelOpened()| will handle the
   // retry.
@@ -470,8 +470,8 @@ void CastMediaSinkServiceImpl::OpenChannel(
     DVLOG(2) << "Updating existing sink without opening new channel: "
              << sink_id << ", name: " << cast_sink.sink().name();
     MediaSinkInternal existing_sink_copy = *existing_sink;
-    UpdateCastSink(cast_sink, &existing_sink_copy);
-    AddOrUpdateSink(existing_sink_copy);
+//    UpdateCastSink(cast_sink, &existing_sink_copy);
+//    AddOrUpdateSink(existing_sink_copy);
     return;
   }
 
@@ -600,8 +600,8 @@ void CastMediaSinkServiceImpl::OnChannelOpenSucceeded(
       metrics_.RecordCastSinkDiscoverySource(SinkSource::kDialMdns);
     }
   }
-  AddOrUpdateSink(cast_sink);
-  failure_count_map_.erase(sink_id);
+//  AddOrUpdateSink(cast_sink);
+//  failure_count_map_.erase(sink_id);
 
   // To maintain the invariant that an IPEndpoint appears in at most one entry
   // in the sink list, we will remove the sink (if any) that has the same
@@ -615,15 +615,15 @@ void CastMediaSinkServiceImpl::OnChannelOpenSucceeded(
                             entry.second.cast_data().ip_endpoint == ip_endpoint;
                    });
 
-  if (old_sink_it != sinks.end())
-    RemoveSink(old_sink_it->second);
+//  if (old_sink_it != sinks.end())
+//    RemoveSink(old_sink_it->second);
 
   // Certain classes of Cast sinks support advertising via SSDP but do not
   // properly implement the rest of the DIAL protocol. If we successfully open
   // a Cast channel to a device that came from DIAL, remove it from
   // |dial_media_sink_service_|. This ensures the device shows up as a Cast sink
   // only.
-  dial_media_sink_service_->RemoveSinkById(GetDialSinkIdFromCast(sink_id));
+//  dial_media_sink_service_->RemoveSinkById(GetDialSinkIdFromCast(sink_id));
 }
 
 void CastMediaSinkServiceImpl::OnChannelOpenFailed(
@@ -636,7 +636,7 @@ void CastMediaSinkServiceImpl::OnChannelOpenFailed(
       !(ip_endpoint == existing_sink->cast_data().ip_endpoint))
     return;
 
-  RemoveSink(sink);
+//  RemoveSink(sink);
 }
 
 void CastMediaSinkServiceImpl::OnSinkAddedOrUpdated(
@@ -668,7 +668,7 @@ void CastMediaSinkServiceImpl::TryConnectDialDiscoveredSink(
     metrics_.RecordCastSinkDiscoverySource(SinkSource::kMdnsDial);
     // Sink is a Cast device; remove from |dial_media_sink_service_| to prevent
     // duplicates.
-    dial_media_sink_service_->RemoveSink(dial_sink);
+//    dial_media_sink_service_->RemoveSink(dial_sink);
     return;
   }
 
diff --git a/chrome/browser/media/router/media_router.h b/chrome/browser/media/router/media_router.h
index 07f9eed08322..226f382fd3da 100644
--- a/chrome/browser/media/router/media_router.h
+++ b/chrome/browser/media/router/media_router.h
@@ -27,7 +27,7 @@
 #include "media/base/flinging_controller.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
@@ -198,7 +198,7 @@ class MediaRouter : public KeyedService {
   virtual std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) = 0;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Binds |controller| for sending media commands to a route. The controller
   // will notify |observer| whenever there is a change to the status of the
   // media. It may invalidate bindings from previous calls to this method.
diff --git a/chrome/browser/media/router/media_router_base.cc b/chrome/browser/media/router/media_router_base.cc
index 24d66af2167a..04a945f7dc71 100644
--- a/chrome/browser/media/router/media_router_base.cc
+++ b/chrome/browser/media/router/media_router_base.cc
@@ -88,7 +88,7 @@ MediaRouterBase::GetFlingingController(const MediaRoute::Id& route_id) {
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void MediaRouterBase::GetMediaController(
     const MediaRoute::Id& route_id,
     mojo::PendingReceiver<mojom::MediaController> controller,
diff --git a/chrome/browser/media/router/media_router_base.h b/chrome/browser/media/router/media_router_base.h
index c4338a957bed..55af77f89a1e 100644
--- a/chrome/browser/media/router/media_router_base.h
+++ b/chrome/browser/media/router/media_router_base.h
@@ -19,7 +19,7 @@
 #include "chrome/common/media_router/media_route.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
@@ -42,7 +42,7 @@ class MediaRouterBase : public MediaRouter {
   std::vector<MediaRoute> GetCurrentRoutes() const override;
   std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   void GetMediaController(
       const MediaRoute::Id& route_id,
       mojo::PendingReceiver<mojom::MediaController> controller,
diff --git a/chrome/browser/media/router/media_router_feature.cc b/chrome/browser/media/router/media_router_feature.cc
index 2d478addf60e..9095d2a30aec 100644
--- a/chrome/browser/media/router/media_router_feature.cc
+++ b/chrome/browser/media/router/media_router_feature.cc
@@ -23,13 +23,13 @@
 #include "components/user_prefs/user_prefs.h"
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "components/prefs/pref_registry_simple.h"
 #endif
 
 namespace media_router {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Controls if browser side DialMediaRouteProvider is enabled.
 const base::Feature kDialMediaRouteProvider{"DialMediaRouteProvider",
                                             base::FEATURE_ENABLED_BY_DEFAULT};
@@ -67,7 +67,7 @@ bool MediaRouterEnabled(content::BrowserContext* context) {
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void RegisterLocalStatePrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kMediaRouterCastAllowAllIPs, false,
                                 PrefRegistry::PUBLIC);
diff --git a/chrome/browser/media/router/media_router_feature.h b/chrome/browser/media/router/media_router_feature.h
index bc1d4b51e60f..1f429d03dea4 100644
--- a/chrome/browser/media/router/media_router_feature.h
+++ b/chrome/browser/media/router/media_router_feature.h
@@ -19,7 +19,7 @@ namespace media_router {
 // Returns true if Media Router is enabled for |context|.
 bool MediaRouterEnabled(content::BrowserContext* context);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 // TODO(crbug.com/1028753): Remove default-enabled kDialMediaRouteProvider after
 // tests stop disabling it.
diff --git a/chrome/browser/media/router/providers/cast/cast_activity_manager.cc b/chrome/browser/media/router/providers/cast/cast_activity_manager.cc
index 19217163e047..01d098198ac6 100644
--- a/chrome/browser/media/router/providers/cast/cast_activity_manager.cc
+++ b/chrome/browser/media/router/providers/cast/cast_activity_manager.cc
@@ -38,6 +38,7 @@ CastActivityManager::CastActivityManager(
   DCHECK(media_router_);
   DCHECK(session_tracker_);
   message_handler_->AddObserver(this);
+#if 0
   for (const auto& sink_id_session : session_tracker_->GetSessions()) {
     const MediaSinkInternal* sink =
         media_sink_service_->GetSinkById(sink_id_session.first);
@@ -45,6 +46,7 @@ CastActivityManager::CastActivityManager(
       break;
     AddNonLocalActivityRecord(*sink, *sink_id_session.second);
   }
+#endif
   session_tracker_->AddObserver(this);
 }
 
@@ -119,8 +121,9 @@ void CastActivityManager::DoLaunchSession(DoLaunchSessionParams params) {
 
   // TODO(crbug.com/904995): In the case of multiple app IDs (e.g. mirroring),
   // we need to choose an appropriate app ID to launch based on capabilities.
-  std::string app_id = cast_source.GetAppIds()[0];
-
+  std::string app_id = "";//cast_source.GetAppIds()[0];
+  return;
+#if 0
   DVLOG(2) << "Launching session with route ID = " << route_id
            << ", source ID = " << cast_source.source_id()
            << ", sink ID = " << sink.sink().id() << ", app ID = " << app_id
@@ -155,6 +158,7 @@ void CastActivityManager::DoLaunchSession(DoLaunchSessionParams params) {
   std::move(params.callback)
       .Run(route, std::move(presentation_connection),
            /* error_text */ base::nullopt, RouteRequestResult::ResultCode::OK);
+#endif
 }
 
 void CastActivityManager::LaunchSessionAfterTerminatingExisting(
@@ -178,7 +182,7 @@ void CastActivityManager::LaunchSessionAfterTerminatingExisting(
 bool CastActivityManager::CanJoinSession(const ActivityRecord& activity,
                                          const CastMediaSource& cast_source,
                                          bool incognito) const {
-  if (!cast_source.ContainsApp(activity.app_id()))
+//  if (!cast_source.ContainsApp(activity.app_id()))
     return false;
 
   if (base::Contains(activity.connected_clients(), cast_source.client_id()))
@@ -234,8 +238,9 @@ ActivityRecord* CastActivityManager::FindActivityForAutoJoin(
         const ActivityRecord* record = activity.second.get();
         if (!record->route().is_local())
           return false;
-        if (!cast_source.ContainsApp(record->app_id()))
+//        if (!cast_source.ContainsApp(record->app_id()))
           return false;
+#if 0
         const auto& clients = record->connected_clients();
         return std::any_of(clients.begin(), clients.end(),
                            [policy, &origin, tab_id](const auto& client) {
@@ -243,6 +248,7 @@ ActivityRecord* CastActivityManager::FindActivityForAutoJoin(
                                                       client.second->origin(),
                                                       client.second->tab_id());
                            });
+#endif
       });
   return it == activities_.end() ? nullptr : it->second.get();
 }
@@ -286,16 +292,19 @@ void CastActivityManager::JoinSession(
   // RouteRequestResult::ResultCode.  The check is currently performed inside
   // CanJoinSession(), and the behavior is consistent with the old
   // implementation, which never reports an INCOGNITO_MISMATCH error.
-
+#if 0
   const MediaSinkInternal* sink =
       media_sink_service_->GetSinkById(activity->route().media_sink_id());
   if (!sink) {
+#else
+  {
+#endif
     std::move(callback).Run(base::nullopt, nullptr,
                             std::string("Sink not found"),
                             RouteRequestResult::ResultCode::SINK_NOT_FOUND);
     return;
   }
-
+#if 0
   mojom::RoutePresentationConnectionPtr presentation_connection =
       activity->AddClient(cast_source, origin, tab_id);
 
@@ -313,6 +322,7 @@ void CastActivityManager::JoinSession(
   NotifyAllOnRoutesUpdated();
   std::move(callback).Run(activity->route(), std::move(presentation_connection),
                           base::nullopt, RouteRequestResult::ResultCode::OK);
+#endif
 }
 
 // TODO(jrw): Can this be merged with HandleStopSessionResponse?
@@ -377,7 +387,7 @@ void CastActivityManager::TerminateSession(
     return;
   }
 
-  const MediaSinkInternal* sink = media_sink_service_->GetSinkByRoute(route);
+  const MediaSinkInternal* sink = nullptr; //media_sink_service_->GetSinkByRoute(route);
   CHECK(sink);
 
   activity->SendStopSessionMessageToReceiver(
@@ -402,8 +412,8 @@ CastActivityManager::FindActivityByChannelId(int channel_id) {
   return std::find_if(
       activities_.begin(), activities_.end(), [channel_id, this](auto& entry) {
         const MediaRoute& route = entry.second->route();
-        const MediaSinkInternal* sink =
-            media_sink_service_->GetSinkByRoute(route);
+        const MediaSinkInternal* sink = nullptr;
+//            media_sink_service_->GetSinkByRoute(route);
         return sink && sink->cast_data().cast_channel_id == channel_id;
       });
 }
@@ -555,6 +565,7 @@ cast_channel::ResultCallback CastActivityManager::MakeResultCallbackForRoute(
 void CastActivityManager::AddNonLocalActivityRecord(
     const MediaSinkInternal& sink,
     const CastSession& session) {
+#if 0
   const MediaSink::Id& sink_id = sink.sink().id();
 
   // We derive the MediaSource from a session using the app ID.
@@ -577,6 +588,7 @@ void CastActivityManager::AddNonLocalActivityRecord(
 
   auto* activity_ptr = AddCastActivityRecord(route, app_id);
   activity_ptr->SetOrUpdateSession(session, sink, hash_token_);
+#endif
 }
 
 const MediaRoute* CastActivityManager::GetRoute(
diff --git a/chrome/browser/media/router/providers/cast/cast_activity_record.cc b/chrome/browser/media/router/providers/cast/cast_activity_record.cc
index f783cc21a196..66bcf2ec28dd 100644
--- a/chrome/browser/media/router/providers/cast/cast_activity_record.cc
+++ b/chrome/browser/media/router/providers/cast/cast_activity_record.cc
@@ -131,7 +131,7 @@ void CastActivityRecord::SendStopSessionMessageToReceiver(
     const std::string& hash_token,
     mojom::MediaRouteProvider::TerminateRouteCallback callback) {
   const std::string& sink_id = route_.media_sink_id();
-  const MediaSinkInternal* sink = media_sink_service_->GetSinkById(sink_id);
+  const MediaSinkInternal* sink = nullptr; //media_sink_service_->GetSinkById(sink_id);
   DCHECK(sink);
   DCHECK(session_id_);
 
@@ -240,7 +240,7 @@ void CastActivityRecord::OnInternalMessage(
     const cast_channel::InternalMessage& message) {}
 
 int CastActivityRecord::GetCastChannelId() {
-  const MediaSinkInternal* sink = media_sink_service_->GetSinkByRoute(route_);
+  const MediaSinkInternal* sink = nullptr;//media_sink_service_->GetSinkByRoute(route_);
   if (!sink) {
     // TODO(crbug.com/905002): Add UMA metrics for this and other error
     // conditions.
diff --git a/chrome/browser/media/router/providers/cast/cast_app_availability_tracker.cc b/chrome/browser/media/router/providers/cast/cast_app_availability_tracker.cc
index 543d3ec7b762..800f8a41f9f5 100644
--- a/chrome/browser/media/router/providers/cast/cast_app_availability_tracker.cc
+++ b/chrome/browser/media/router/providers/cast/cast_app_availability_tracker.cc
@@ -67,8 +67,8 @@ std::vector<CastMediaSource> CastAppAvailabilityTracker::UpdateAppAvailability(
 
   std::vector<CastMediaSource> affected_sources;
   for (const auto& source : registered_sources_) {
-    if (source.second.ContainsApp(app_id))
-      affected_sources.push_back(source.second);
+//    if (source.second.ContainsApp(app_id))
+//      affected_sources.push_back(source.second);
   }
   return affected_sources;
 }
diff --git a/chrome/browser/media/router/providers/cast/cast_app_discovery_service.cc b/chrome/browser/media/router/providers/cast/cast_app_discovery_service.cc
index 3b06c1fbcb37..f1df66c69175 100644
--- a/chrome/browser/media/router/providers/cast/cast_app_discovery_service.cc
+++ b/chrome/browser/media/router/providers/cast/cast_app_discovery_service.cc
@@ -171,7 +171,9 @@ void CastAppDiscoveryServiceImpl::UpdateAppAvailability(
     cast_channel::GetAppAvailabilityResult availability) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   RecordAppAvailabilityResult(availability, clock_->NowTicks() - start_time);
+#if 0
   if (!media_sink_service_->GetSinkById(sink_id))
+#endif
     return;
 
   DVLOG(1) << "App " << app_id << " on sink " << sink_id << " is "
@@ -197,11 +199,13 @@ void CastAppDiscoveryServiceImpl::UpdateSinkQueries(
 std::vector<MediaSinkInternal> CastAppDiscoveryServiceImpl::GetSinksByIds(
     const base::flat_set<MediaSink::Id>& sink_ids) const {
   std::vector<MediaSinkInternal> sinks;
+#if 0
   for (const auto& sink_id : sink_ids) {
     const MediaSinkInternal* sink = media_sink_service_->GetSinkById(sink_id);
     if (sink)
       sinks.push_back(*sink);
   }
+#endif
   return sinks;
 }
 
diff --git a/chrome/browser/media/router/providers/cast/cast_media_route_provider.cc b/chrome/browser/media/router/providers/cast/cast_media_route_provider.cc
index 2488bb17b926..8c8bda589e7f 100644
--- a/chrome/browser/media/router/providers/cast/cast_media_route_provider.cc
+++ b/chrome/browser/media/router/providers/cast/cast_media_route_provider.cc
@@ -100,14 +100,18 @@ void CastMediaRouteProvider::CreateRoute(const std::string& source_id,
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   // TODO(https://crbug.com/809249): Handle mirroring routes, including
   // mirror-to-Cast transitions.
+#if 0
   const MediaSinkInternal* sink = media_sink_service_->GetSinkById(sink_id);
   if (!sink) {
+#else
+  {
+#endif
     std::move(callback).Run(base::nullopt, nullptr,
                             std::string("Sink not found"),
                             RouteRequestResult::ResultCode::SINK_NOT_FOUND);
     return;
   }
-
+#if 0
   std::unique_ptr<CastMediaSource> cast_source =
       CastMediaSource::FromMediaSourceId(source_id);
   if (!cast_source) {
@@ -119,6 +123,7 @@ void CastMediaRouteProvider::CreateRoute(const std::string& source_id,
 
   activity_manager_->LaunchSession(*cast_source, *sink, presentation_id, origin,
                                    tab_id, incognito, std::move(callback));
+#endif
 }
 
 void CastMediaRouteProvider::JoinRoute(const std::string& media_source,
@@ -191,8 +196,8 @@ void CastMediaRouteProvider::StartObservingMediaSinks(
   // app precache message to receivers.
   if (cast_source->broadcast_request()) {
     // TODO(imcheng): Add metric to record broadcast usage.
-    BroadcastMessageToSinks(cast_source->GetAppIds(),
-                            *cast_source->broadcast_request());
+//    BroadcastMessageToSinks(cast_source->GetAppIds(),
+//                            *cast_source->broadcast_request());
     return;
   }
 
diff --git a/chrome/browser/media/router/providers/cast/mirroring_activity_record.cc b/chrome/browser/media/router/providers/cast/mirroring_activity_record.cc
index 18d315905e42..7ff3cafa3802 100644
--- a/chrome/browser/media/router/providers/cast/mirroring_activity_record.cc
+++ b/chrome/browser/media/router/providers/cast/mirroring_activity_record.cc
@@ -197,7 +197,7 @@ void MirroringActivityRecord::SendStopSessionMessageToReceiver(
     const std::string& hash_token,
     MediaRouteProvider::TerminateRouteCallback callback) {
   const std::string& sink_id = route_.media_sink_id();
-  const MediaSinkInternal* sink = media_sink_service_->GetSinkById(sink_id);
+  const MediaSinkInternal* sink = nullptr; //media_sink_service_->GetSinkById(sink_id);
   DCHECK(sink);
   DCHECK(session_id_);
   message_handler_->StopSession(
diff --git a/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc b/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
index 954ce6977683..1543cc5af246 100644
--- a/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
+++ b/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
@@ -114,13 +114,6 @@ MediaCaptureDevicesDispatcher::MediaCaptureDevicesDispatcher()
 #endif
   media_access_handlers_.push_back(
       std::make_unique<DesktopCaptureAccessHandler>());
-#if defined(OS_CHROMEOS)
-  // Wrapper around TabCaptureAccessHandler used in Public Sessions.
-  media_access_handlers_.push_back(
-      std::make_unique<PublicSessionTabCaptureAccessHandler>());
-#else
-  media_access_handlers_.push_back(std::make_unique<TabCaptureAccessHandler>());
-#endif
 #endif
   media_access_handlers_.push_back(
       std::make_unique<PermissionBubbleMediaAccessHandler>());
diff --git a/chrome/browser/metrics/chrome_feature_list_creator.cc b/chrome/browser/metrics/chrome_feature_list_creator.cc
index b14b36d349ec..59e086f593e1 100644
--- a/chrome/browser/metrics/chrome_feature_list_creator.cc
+++ b/chrome/browser/metrics/chrome_feature_list_creator.cc
@@ -55,11 +55,17 @@ ChromeFeatureListCreator::ChromeFeatureListCreator() = default;
 ChromeFeatureListCreator::~ChromeFeatureListCreator() = default;
 
 void ChromeFeatureListCreator::CreateFeatureList() {
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 1";
   CreatePrefService();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 2";
   ConvertFlagsToSwitches();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 3";
   CreateMetricsServices();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 4";
   SetupMasterPrefs();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 5";
   SetupFieldTrials();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 6";
 }
 
 void ChromeFeatureListCreator::SetApplicationLocale(const std::string& locale) {
diff --git a/chrome/browser/notifications/fullscreen_notification_blocker.cc b/chrome/browser/notifications/fullscreen_notification_blocker.cc
index 5429c12e2b8c..5abad73a1faa 100644
--- a/chrome/browser/notifications/fullscreen_notification_blocker.cc
+++ b/chrome/browser/notifications/fullscreen_notification_blocker.cc
@@ -23,7 +23,7 @@ FullscreenNotificationBlocker::~FullscreenNotificationBlocker() {
 
 void FullscreenNotificationBlocker::CheckState() {
   bool was_fullscreen_mode = is_fullscreen_mode_;
-  is_fullscreen_mode_ = IsFullScreenMode();
+  is_fullscreen_mode_ = false;//IsFullScreenMode();
   if (is_fullscreen_mode_ != was_fullscreen_mode)
     NotifyBlockingStateChanged();
 
diff --git a/chrome/browser/notifications/notification_display_service_impl.cc b/chrome/browser/notifications/notification_display_service_impl.cc
index 46f516b5f2d3..c01c2778d775 100644
--- a/chrome/browser/notifications/notification_display_service_impl.cc
+++ b/chrome/browser/notifications/notification_display_service_impl.cc
@@ -261,24 +261,6 @@ void NotificationDisplayServiceImpl::Display(
 void NotificationDisplayServiceImpl::Close(
     NotificationHandler::Type notification_type,
     const std::string& notification_id) {
-  CHECK(profile_ || notification_type == NotificationHandler::Type::TRANSIENT);
-
-  if (!bridge_initialized_) {
-    actions_.push(base::BindOnce(&NotificationDisplayServiceImpl::Close,
-                                 weak_factory_.GetWeakPtr(), notification_type,
-                                 notification_id));
-    return;
-  }
-
-#if BUILDFLAG(ENABLE_NATIVE_NOTIFICATIONS)
-  NotificationPlatformBridge* bridge =
-      NotificationPlatformBridge::CanHandleType(notification_type)
-          ? bridge_
-          : message_center_bridge_.get();
-  DCHECK(bridge);
-
-  bridge->Close(profile_, notification_id);
-#endif
 }
 
 void NotificationDisplayServiceImpl::GetDisplayed(
diff --git a/chrome/browser/obsolete_system/obsolete_system_android.cc b/chrome/browser/obsolete_system/obsolete_system_android.cc
new file mode 100644
index 000000000000..10d94a577595
--- /dev/null
+++ b/chrome/browser/obsolete_system/obsolete_system_android.cc
@@ -0,0 +1,25 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/obsolete_system/obsolete_system.h"
+
+// static
+bool ObsoleteSystem::IsObsoleteNowOrSoon() {
+  return false;
+}
+
+// static
+base::string16 ObsoleteSystem::LocalizedObsoleteString() {
+  return base::string16();
+}
+
+// static
+bool ObsoleteSystem::IsEndOfTheLine() {
+  return false;
+}
+
+// static
+const char* ObsoleteSystem::GetLinkURL() {
+  return "";
+}
diff --git a/chrome/browser/permissions/attestation_permission_request.cc b/chrome/browser/permissions/attestation_permission_request.cc
index 672203370d4d..af9a7f53d997 100644
--- a/chrome/browser/permissions/attestation_permission_request.cc
+++ b/chrome/browser/permissions/attestation_permission_request.cc
@@ -26,7 +26,17 @@ class AttestationPermissionRequest : public PermissionRequest {
       : origin_(origin), callback_(std::move(callback)) {}
 
   PermissionRequest::IconId GetIconId() const override {
-    return kUsbSecurityKeyIcon;
+    return 0;
+  }
+
+  base::string16 GetTitleText() const override {
+    return l10n_util::GetStringUTF16(
+        IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
+  }
+
+  base::string16 GetMessageText() const override {
+    return l10n_util::GetStringUTF16(
+        IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
   }
 
   base::string16 GetMessageTextFragment() const override {
diff --git a/chrome/browser/platform_util.cc b/chrome/browser/platform_util.cc
index 0a12f09c6f73..3b0cc83e53a6 100644
--- a/chrome/browser/platform_util.cc
+++ b/chrome/browser/platform_util.cc
@@ -21,30 +21,6 @@ namespace {
 
 bool shell_operations_allowed = true;
 
-void VerifyAndOpenItemOnBlockingThread(const base::FilePath& path,
-                                       OpenItemType type,
-                                       const OpenOperationCallback& callback) {
-  base::File target_item(path, base::File::FLAG_OPEN | base::File::FLAG_READ);
-  if (!base::PathExists(path)) {
-    if (!callback.is_null())
-      base::PostTask(FROM_HERE, {BrowserThread::UI},
-                     base::BindOnce(callback, OPEN_FAILED_PATH_NOT_FOUND));
-    return;
-  }
-  if (base::DirectoryExists(path) != (type == OPEN_FOLDER)) {
-    if (!callback.is_null())
-      base::PostTask(FROM_HERE, {BrowserThread::UI},
-                     base::BindOnce(callback, OPEN_FAILED_INVALID_TYPE));
-    return;
-  }
-
-  if (shell_operations_allowed)
-    internal::PlatformOpenVerifiedItem(path, type);
-  if (!callback.is_null())
-    base::PostTask(FROM_HERE, {BrowserThread::UI},
-                   base::BindOnce(callback, OPEN_SUCCEEDED));
-}
-
 }  // namespace
 
 namespace internal {
@@ -55,24 +31,6 @@ void DisableShellOperationsForTesting() {
 
 }  // namespace internal
 
-void OpenItem(Profile* profile,
-              const base::FilePath& full_path,
-              OpenItemType item_type,
-              const OpenOperationCallback& callback) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  // TaskPriority::USER_BLOCKING because this is usually opened as a result of a
-  // user action (e.g. open-downloaded-file or show-item-in-folder).
-  // TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN because this doesn't need global
-  // state and can hang shutdown without this trait as it may result in an
-  // interactive dialog.
-  base::PostTask(
-      FROM_HERE,
-      {base::ThreadPool(), base::MayBlock(), base::TaskPriority::USER_BLOCKING,
-       base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
-      base::BindOnce(&VerifyAndOpenItemOnBlockingThread, full_path, item_type,
-                     callback));
-}
-
 bool IsBrowserLockedFullscreen(const Browser* browser) {
   return false;
 }
diff --git a/chrome/browser/platform_util_android.cc b/chrome/browser/platform_util_android.cc
index aae50e7dca78..b825cc8d1baf 100644
--- a/chrome/browser/platform_util_android.cc
+++ b/chrome/browser/platform_util_android.cc
@@ -55,6 +55,10 @@ void ActivateWindow(gfx::NativeWindow window) {
   NOTIMPLEMENTED();
 }
 
+gfx::NativeView GetViewForWindow(gfx::NativeWindow window) {
+  return nullptr;
+}
+
 bool IsVisible(gfx::NativeView view) {
   NOTIMPLEMENTED();
   return true;
diff --git a/chrome/browser/plugins/plugins_resource_service.cc b/chrome/browser/plugins/plugins_resource_service.cc
index 1e063a0c1aab..57723a447cb3 100644
--- a/chrome/browser/plugins/plugins_resource_service.cc
+++ b/chrome/browser/plugins/plugins_resource_service.cc
@@ -67,7 +67,7 @@ GURL GetPluginsServerURL() {
 #elif defined(OS_MACOSX)
   filename = "plugins_mac.json";
 #else
-#error Unknown platform
+  filename = "plugins_linux.json";
 #endif
 
   return GURL(kPluginsServerUrl + filename);
diff --git a/chrome/browser/policy/BUILD.gn b/chrome/browser/policy/BUILD.gn
index 87450f3ec300..35d45c3d030d 100644
--- a/chrome/browser/policy/BUILD.gn
+++ b/chrome/browser/policy/BUILD.gn
@@ -8,6 +8,7 @@ source_set("path_parser") {
   sources = [
     "policy_path_parser.h",
     "policy_path_parser_linux.cc",
+    "policy_path_parser_android.cc",
     "policy_path_parser_mac.mm",
     "policy_path_parser_win.cc",
   ]
diff --git a/chrome/browser/policy/browser_dm_token_storage_android.cc b/chrome/browser/policy/browser_dm_token_storage_android.cc
new file mode 100644
index 000000000000..b89463561bea
--- /dev/null
+++ b/chrome/browser/policy/browser_dm_token_storage_android.cc
@@ -0,0 +1,191 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/policy/browser_dm_token_storage_android.h"
+
+#include <string>
+
+#include "base/base64url.h"
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/callback.h"
+#include "base/files/file_util.h"
+#include "base/files/important_file_writer.h"
+#include "base/hash/sha1.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/syslog_logging.h"
+#include "base/task/post_task.h"
+#include "base/task/task_traits.h"
+#include "base/task_runner_util.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/sequenced_task_runner_handle.h"
+#include "chrome/common/chrome_paths.h"
+
+namespace policy {
+
+namespace {
+
+const char kDmTokenBaseDir[] = FILE_PATH_LITERAL("Policy/Enrollment/");
+const char kEnrollmentTokenFilename[] =
+    FILE_PATH_LITERAL("enrollment/CloudManagementEnrollmentToken");
+// TODO(crbug.com/907589) : Remove once no longer in use.
+const char kEnrollmentTokenOldFilename[] =
+    FILE_PATH_LITERAL("enrollment/enrollment_token");
+const char kMachineIdFilename[] = FILE_PATH_LITERAL("/etc/machine-id");
+
+// Enrollment Mandatory Option.
+const char kEnrollmentOptionsFilePath[] =
+    FILE_PATH_LITERAL("enrollment/CloudManagementEnrollmentOptions");
+const char kEnrollmentMandatoryOption[] = "Mandatory";
+
+bool GetDmTokenFilePath(base::FilePath* token_file_path,
+                        const std::string& client_id,
+                        bool create_dir) {
+  if (!base::PathService::Get(chrome::DIR_USER_DATA, token_file_path))
+    return false;
+
+  *token_file_path = token_file_path->Append(kDmTokenBaseDir);
+
+  if (create_dir && !base::CreateDirectory(*token_file_path))
+    return false;
+
+  *token_file_path = token_file_path->Append(client_id);
+
+  return true;
+}
+
+bool StoreDMTokenInUserDataDir(const std::string& token,
+                               const std::string& client_id) {
+  base::FilePath token_file_path;
+  if (!GetDmTokenFilePath(&token_file_path, client_id, true)) {
+    NOTREACHED();
+    return false;
+  }
+
+  return base::ImportantFileWriter::WriteFileAtomically(token_file_path, token);
+}
+
+}  // namespace
+
+// static
+BrowserDMTokenStorage* BrowserDMTokenStorage::Get() {
+  if (storage_for_testing_)
+    return storage_for_testing_;
+
+  static base::NoDestructor<BrowserDMTokenStorageAndroid> storage;
+  return storage.get();
+}
+
+BrowserDMTokenStorageAndroid::BrowserDMTokenStorageAndroid()
+    : task_runner_(
+          base::CreateTaskRunner({base::ThreadPool(), base::MayBlock()})) {}
+
+BrowserDMTokenStorageAndroid::~BrowserDMTokenStorageAndroid() {}
+
+std::string BrowserDMTokenStorageAndroid::InitClientId() {
+  // The client ID is derived from /etc/machine-id
+  // (https://www.freedesktop.org/software/systemd/man/machine-id.html). As per
+  // guidelines, this ID must not be transmitted outside of the machine, which
+  // is why we hash it first and then encode it in base64 before transmitting
+  // it.
+  const int machine_id_size = 32;
+  std::string machine_id;
+  machine_id = ReadMachineIdFile();
+  base::StringPiece machine_id_trimmed =
+      base::TrimWhitespaceASCII(machine_id, base::TRIM_TRAILING);
+  if (machine_id_trimmed.size() != machine_id_size) {
+    SYSLOG(ERROR) << "Error: /etc/machine-id contains "
+                  << machine_id_trimmed.size() << " characters ("
+                  << machine_id_size << " were expected).";
+    return std::string();
+  }
+
+  std::string machine_id_base64;
+  base::Base64UrlEncode(base::SHA1HashString(std::string(machine_id_trimmed)),
+                        base::Base64UrlEncodePolicy::OMIT_PADDING,
+                        &machine_id_base64);
+  return machine_id_base64;
+}
+
+std::string BrowserDMTokenStorageAndroid::InitEnrollmentToken() {
+  std::string enrollment_token;
+  base::FilePath dir_policy_files_path;
+
+  if (!base::PathService::Get(chrome::DIR_POLICY_FILES,
+                              &dir_policy_files_path)) {
+    return std::string();
+  }
+
+  base::FilePath token_file_path =
+      dir_policy_files_path.Append(kEnrollmentTokenFilename);
+
+  // Read the enrollment token from the new location. If that fails, try the old
+  // location (which will be deprecated soon). If that also fails, bail as there
+  // is no token set.
+  if (!base::ReadFileToString(token_file_path, &enrollment_token)) {
+    // TODO(crbug.com/907589) : Remove once no longer in use.
+    token_file_path = dir_policy_files_path.Append(kEnrollmentTokenOldFilename);
+    if (!base::ReadFileToString(token_file_path, &enrollment_token))
+      return std::string();
+  }
+
+  return base::TrimWhitespaceASCII(enrollment_token, base::TRIM_ALL)
+      .as_string();
+}
+
+std::string BrowserDMTokenStorageAndroid::InitDMToken() {
+  base::FilePath token_file_path;
+  if (!GetDmTokenFilePath(&token_file_path, RetrieveClientId(), false))
+    return std::string();
+
+  std::string token;
+  if (!base::ReadFileToString(token_file_path, &token))
+    return std::string();
+
+  return base::TrimWhitespaceASCII(token, base::TRIM_ALL).as_string();
+}
+
+bool BrowserDMTokenStorageAndroid::InitEnrollmentErrorOption() {
+  std::string options;
+  base::FilePath dir_policy_files_path;
+
+  if (!base::PathService::Get(chrome::DIR_POLICY_FILES,
+                              &dir_policy_files_path)) {
+    return false;
+  }
+
+  base::FilePath options_file_path =
+      dir_policy_files_path.Append(kEnrollmentOptionsFilePath);
+
+  if (!base::ReadFileToString(options_file_path, &options))
+    return false;
+
+  return base::TrimWhitespaceASCII(options, base::TRIM_ALL).as_string() ==
+         kEnrollmentMandatoryOption;
+}
+
+BrowserDMTokenStorage::StoreTask BrowserDMTokenStorageAndroid::SaveDMTokenTask(
+    const std::string& token,
+    const std::string& client_id) {
+  return base::BindOnce(&StoreDMTokenInUserDataDir, token, client_id);
+}
+
+scoped_refptr<base::TaskRunner>
+BrowserDMTokenStorageAndroid::SaveDMTokenTaskRunner() {
+  return task_runner_;
+}
+
+std::string BrowserDMTokenStorageAndroid::ReadMachineIdFile() {
+  std::string machine_id;
+  if (!base::ReadFileToString(base::FilePath(kMachineIdFilename), &machine_id))
+    return std::string();
+  return machine_id;
+}
+
+}  // namespace policy
diff --git a/chrome/browser/policy/browser_dm_token_storage_android.h b/chrome/browser/policy/browser_dm_token_storage_android.h
new file mode 100644
index 000000000000..2a16d354d4bb
--- /dev/null
+++ b/chrome/browser/policy/browser_dm_token_storage_android.h
@@ -0,0 +1,58 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+#define CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+
+#include "chrome/browser/policy/browser_dm_token_storage.h"
+
+#include <string>
+
+#include "base/gtest_prod_util.h"
+#include "base/macros.h"
+#include "base/memory/scoped_refptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/sequence_checker.h"
+#include "base/single_thread_task_runner.h"
+
+namespace policy {
+
+// Implementation of BrowserDMTokenStorage for Android. The global singleton
+// instance can be retrieved by calling BrowserDMTokenStorage::Get().
+class BrowserDMTokenStorageAndroid : public BrowserDMTokenStorage {
+ public:
+  // Get the global singleton instance by calling BrowserDMTokenStorage::Get().
+  BrowserDMTokenStorageAndroid();
+  ~BrowserDMTokenStorageAndroid() override;
+
+ private:
+  // override BrowserDMTokenStorage
+  std::string InitClientId() override;
+  std::string InitEnrollmentToken() override;
+  std::string InitDMToken() override;
+  bool InitEnrollmentErrorOption() override;
+  StoreTask SaveDMTokenTask(const std::string& token,
+                            const std::string& client_id) override;
+  scoped_refptr<base::TaskRunner> SaveDMTokenTaskRunner() override;
+
+  // Returns the content of "/etc/machine-id". Virtual for tests.
+  virtual std::string ReadMachineIdFile();
+
+  scoped_refptr<base::TaskRunner> task_runner_;
+
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitClientId);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitEnrollmentToken);
+  // TODO(crbug.com/907589): Remove once no longer in use.
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest,
+                           InitOldEnrollmentToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitDMToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest,
+                           InitDMTokenWithoutDirectory);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, SaveDMToken);
+
+  DISALLOW_COPY_AND_ASSIGN(BrowserDMTokenStorageAndroid);
+};
+
+}  // namespace policy
+#endif  // CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
diff --git a/chrome/browser/policy/chrome_browser_policy_connector.cc b/chrome/browser/policy/chrome_browser_policy_connector.cc
index 637c861be75d..77d896d864dd 100644
--- a/chrome/browser/policy/chrome_browser_policy_connector.cc
+++ b/chrome/browser/policy/chrome_browser_policy_connector.cc
@@ -47,7 +47,7 @@
 #include "components/policy/core/browser/android/android_combined_policy_provider.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 #include "chrome/browser/policy/chrome_browser_cloud_management_controller.h"
 #include "components/policy/core/common/cloud/machine_level_user_cloud_policy_manager.h"
 #endif
diff --git a/chrome/browser/policy/configuration_policy_handler_list_factory.cc b/chrome/browser/policy/configuration_policy_handler_list_factory.cc
index 9c2fdea178f5..05b15eab5c8d 100644
--- a/chrome/browser/policy/configuration_policy_handler_list_factory.cc
+++ b/chrome/browser/policy/configuration_policy_handler_list_factory.cc
@@ -1072,7 +1072,7 @@ const PolicyToPreferenceMapEntry kSimplePolicyMap[] = {
     base::Value::Type::BOOLEAN },
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   { key::kRelaunchNotification,
     prefs::kRelaunchNotification,
     base::Value::Type::INTEGER },
diff --git a/chrome/browser/policy/policy_path_parser_android.cc b/chrome/browser/policy/policy_path_parser_android.cc
new file mode 100644
index 000000000000..669a85bc765d
--- /dev/null
+++ b/chrome/browser/policy/policy_path_parser_android.cc
@@ -0,0 +1,71 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <pwd.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "chrome/browser/policy/policy_path_parser.h"
+
+#include "base/logging.h"
+
+namespace policy {
+
+namespace path_parser {
+
+const char kMachineNamePolicyVarName[] = "${machine_name}";
+const char kUserNamePolicyVarName[] = "${user_name}";
+
+// Replaces all variable occurrences in the policy string with the respective
+// system settings values.
+base::FilePath::StringType ExpandPathVariables(
+    const base::FilePath::StringType& untranslated_string) {
+  base::FilePath::StringType result(untranslated_string);
+  if (result.length() == 0)
+    return result;
+  // Sanitize quotes in case of any around the whole string.
+  if (result.length() > 1 &&
+      ((result.front() == '"' && result.back() == '"') ||
+       (result.front() == '\'' && result.back() == '\''))) {
+    // Strip first and last char which should be matching quotes now.
+    result = result.substr(1, result.length() - 2);
+  }
+  // Translate two special variables ${user_name} and ${machine_name}
+  size_t position = result.find(kUserNamePolicyVarName);
+  if (position != std::string::npos) {
+    struct passwd* user = getpwuid(geteuid());
+    if (user) {
+      result.replace(position, strlen(kUserNamePolicyVarName), user->pw_name);
+    } else {
+      LOG(ERROR) << "Username variable can not be resolved. ";
+    }
+  }
+  position = result.find(kMachineNamePolicyVarName);
+  if (position != std::string::npos) {
+    char machinename[255];
+    if (gethostname(machinename, 255) == 0) {
+      result.replace(position, strlen(kMachineNamePolicyVarName), machinename);
+    } else {
+      LOG(ERROR) << "Machine name variable can not be resolved.";
+    }
+  }
+  return result;
+}
+
+void CheckUserDataDirPolicy(base::FilePath* user_data_dir) {
+  // This function is not implemented in Linux because we don't support the
+  // policy on this platform.
+  NOTREACHED();
+}
+
+void CheckDiskCacheDirPolicy(base::FilePath* user_data_dir) {
+  // This function is not implemented in Linux because we don't support the
+  // policy on this platform.
+  NOTREACHED();
+}
+
+}  // namespace path_parser
+
+}  // namespace policy
diff --git a/chrome/browser/prefs/browser_prefs.cc b/chrome/browser/prefs/browser_prefs.cc
index 236422f50eba..407f094cd57f 100644
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -217,7 +217,6 @@
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
 #include "components/feed/core/pref_names.h"
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else   // defined(OS_ANDROID)
 #include "chrome/browser/apps/app_service/app_service_proxy.h"
 #include "chrome/browser/enterprise_reporting/prefs.h"
 #include "chrome/browser/gcm/gcm_product_util.h"
@@ -350,12 +349,12 @@
 #include "components/os_crypt/os_crypt.h"
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || \
+#if true || defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 #include "chrome/browser/browser_switcher/browser_switcher_prefs.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/ui/startup/default_browser_prompt.h"
 #endif
 
@@ -363,7 +362,7 @@
 #include "chrome/browser/ui/browser_view_prefs.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/media/unified_autoplay_config.h"
 #include "components/ntp_tiles/custom_links_manager_impl.h"
 #endif
@@ -448,7 +447,7 @@ const char kContentSuggestionsNotificationsEnabled[] =
 
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Deprecated 5/2019
 const char kSignInPromoShowOnFirstRunAllowed[] =
     "sync_promo.show_on_first_run_allowed";
@@ -470,7 +469,7 @@ const char kHasSeenWin10PromoPage[] = "browser.has_seen_win10_promo_page";
 // Deprecated 7/2019
 const char kSignedInTime[] = "signin.signedin_time";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Deprecated 7/2019
 const char kNtpActivateHideShortcutsFieldTrial[] =
     "ntp.activate_hide_shortcuts_field_trial";
@@ -571,7 +570,7 @@ void RegisterProfilePrefsForMigration(
   registry->RegisterBooleanPref(kContentSuggestionsNotificationsEnabled, true);
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(kSignInPromoShowOnFirstRunAllowed, true);
   registry->RegisterBooleanPref(kSignInPromoShowNTPBubble, false);
 #endif  // !defined(OS_ANDROID)
@@ -665,11 +664,11 @@ void RegisterLocalState(PrefRegistrySimple* registry) {
 
 #if defined(OS_ANDROID)
   ::android::RegisterPrefs(registry);
-#else
+
   media_router::RegisterLocalStatePrefs(registry);
   // The native GCM is used on Android instead.
-  gcm::GCMChannelStatusSyncer::RegisterPrefs(registry);
-  gcm::RegisterPrefs(registry);
+//  gcm::GCMChannelStatusSyncer::RegisterPrefs(registry);
+//  gcm::RegisterPrefs(registry);
   metrics::TabStatsTracker::RegisterPrefs(registry);
   RegisterBrowserPrefs(registry);
   StartupBrowserCreator::RegisterLocalStatePrefs(registry);
@@ -770,7 +769,7 @@ void RegisterLocalState(PrefRegistrySimple* registry) {
 
   // Obsolete. See MigrateObsoleteBrowserPrefs().
   registry->RegisterIntegerPref(metrics::prefs::kStabilityExecutionPhase, 0);
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(kNtpActivateHideShortcutsFieldTrial, false);
 #endif  // !defined(OS_ANDROID)
   registry->RegisterInt64Pref(kLastStartupTimestamp, 0);
@@ -785,6 +784,7 @@ void RegisterLocalState(PrefRegistrySimple* registry) {
 // Register prefs applicable to all profiles.
 void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
                           const std::string& locale) {
+  LOG(ERROR) << "[Kiwi] prefs/browser_prefs.cc::RegisterProfilePrefs - Step 1";
   TRACE_EVENT0("browser", "chrome::RegisterProfilePrefs");
   // User prefs. Please keep this list alphabetized.
   AccessibilityLabelsService::RegisterProfilePrefs(registry);
@@ -902,15 +902,18 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
   feed::RegisterProfilePrefs(registry);
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else
   apps::AppServiceProxy::RegisterProfilePrefs(registry);
   AppShortcutManager::RegisterProfilePrefs(registry);
+#if 0
   DeviceIDFetcher::RegisterProfilePrefs(registry);
+#endif
   DevToolsWindow::RegisterProfilePrefs(registry);
   extensions::CommandService::RegisterProfilePrefs(registry);
   extensions::TabsCaptureVisibleTabFunction::RegisterProfilePrefs(registry);
   NewTabUI::RegisterProfilePrefs(registry);
+#if 0
   PepperFlashSettingsManager::RegisterProfilePrefs(registry);
+#endif
   PinnedTabCodec::RegisterProfilePrefs(registry);
   signin::RegisterProfilePrefs(registry);
 #endif
@@ -927,22 +930,22 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
-  browser_sync::ForeignSessionHandler::RegisterProfilePrefs(registry);
-  ChromeAuthenticatorRequestDelegate::RegisterProfilePrefs(registry);
+#if true || !defined(OS_ANDROID)
+//  browser_sync::ForeignSessionHandler::RegisterProfilePrefs(registry);
+//  ChromeAuthenticatorRequestDelegate::RegisterProfilePrefs(registry);
   first_run::RegisterProfilePrefs(registry);
   HatsService::RegisterProfilePrefs(registry);
   InstantService::RegisterProfilePrefs(registry);
   PromoService::RegisterProfilePrefs(registry);
   SearchSuggestService::RegisterProfilePrefs(registry);
-  gcm::GCMChannelStatusSyncer::RegisterProfilePrefs(registry);
-  gcm::RegisterProfilePrefs(registry);
+//  gcm::GCMChannelStatusSyncer::RegisterProfilePrefs(registry);
+//  gcm::RegisterProfilePrefs(registry);
   media_router::RegisterProfilePrefs(registry);
   ntp_tiles::CustomLinksManagerImpl::RegisterProfilePrefs(registry);
   StartupBrowserCreator::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   default_apps::RegisterProfilePrefs(registry);
 #endif
 
@@ -1016,7 +1019,7 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
   RegisterChromeLauncherUserPrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   HistoryUI::RegisterProfilePrefs(registry);
   settings::SettingsUI::RegisterProfilePrefs(registry);
 #endif
@@ -1030,11 +1033,11 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
   NotificationChannelsProviderAndroid::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   UnifiedAutoplayConfig::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_CHROMEOS) && BUILDFLAG(ENABLE_EXTENSIONS)
+#if true || !defined(OS_CHROMEOS) && BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::enterprise_reporting::RegisterProfilePrefs(registry);
 #endif
 
@@ -1043,6 +1046,7 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
 #endif
 
   RegisterProfilePrefsForMigration(registry);
+  LOG(ERROR) << "[Kiwi] prefs/browser_prefs.cc::RegisterProfilePrefs - Step 2";
 }
 
 void RegisterUserProfilePrefs(user_prefs::PrefRegistrySyncable* registry) {
@@ -1098,7 +1102,7 @@ void MigrateObsoleteBrowserPrefs(Profile* profile, PrefService* local_state) {
   local_state->ClearPref(kHasSeenWin10PromoPage);
 #endif  // defined(OS_WIN)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Added 7/2019.
   local_state->ClearPref(kNtpActivateHideShortcutsFieldTrial);
 #endif  // !defined(OS_ANDROID)
@@ -1196,7 +1200,7 @@ void MigrateObsoleteProfilePrefs(Profile* profile) {
   profile_prefs->ClearPref(kContentSuggestionsNotificationsEnabled);
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Deprecated 5/2019
   profile_prefs->ClearPref(kSignInPromoShowOnFirstRunAllowed);
   profile_prefs->ClearPref(kSignInPromoShowNTPBubble);
diff --git a/chrome/browser/prefs/chrome_pref_service_factory.cc b/chrome/browser/prefs/chrome_pref_service_factory.cc
index ce49583f5c3e..f7db89898433 100644
--- a/chrome/browser/prefs/chrome_pref_service_factory.cc
+++ b/chrome/browser/prefs/chrome_pref_service_factory.cc
@@ -124,7 +124,7 @@ const prefs::TrackedPreferenceMetadata kTrackedPrefs[] = {
      PrefTrackingStrategy::ATOMIC, ValueType::PERSONAL},
     {7, prefs::kSearchProviderOverrides, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     {11, prefs::kPinnedTabs, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
 #endif
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
index c136190f2bb9..8f9189c0c962 100644
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -98,7 +98,7 @@
 #include "chrome/browser/android/explore_sites/explore_sites_service_factory.h"
 #include "chrome/browser/android/search_permissions/search_permissions_service.h"
 #include "chrome/browser/media/android/cdm/media_drm_origin_id_manager_factory.h"
-#else
+
 #include "chrome/browser/apps/app_service/app_service_proxy_factory.h"
 #include "chrome/browser/feedback/feedback_uploader_factory_chrome.h"
 #include "chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.h"
@@ -188,109 +188,174 @@ ChromeBrowserMainExtraPartsProfiles::~ChromeBrowserMainExtraPartsProfiles() {}
 // FooServiceFactory here will scale or is desirable long term.
 //
 // static
+
+// Special Android
+// When we are on Android, we need to initialize the first pass only the minimum to be able to init the profile the first time
 void ChromeBrowserMainExtraPartsProfiles::
-    EnsureBrowserContextKeyedServiceFactoriesBuilt() {
+    EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init) {
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 1";
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 2";
   apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 3";
   extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 4";
   extensions::ExtensionManagementFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 5";
   chrome_extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 6";
   chrome_apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 7";
   chrome_apps::api::EnsureAPIBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 8";
+  }
 #endif
 
 #if defined(OS_CHROMEOS)
   chromeos::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 9";
   app_list::AppListSyncableServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 10";
 
 #if !defined(OS_ANDROID)
   apps::AppServiceProxyFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 11";
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 12";
   AboutSigninInternalsFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 13";
   AccountConsistencyModeManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 14";
   AccountInvestigatorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 15";
   AccountReconcilorFactory::GetInstance();
   AdaptiveQuietNotificationPermissionUiEnabler::Factory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 16";
+  if (full_init)
   AutocompleteClassifierFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 17";
   autofill::PersonalDataManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 18";
 #if BUILDFLAG(ENABLE_BACKGROUND_CONTENTS)
   BackgroundContentsServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 19";
   BookmarkModelFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 20";
   BookmarkUndoServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 21";
   BrowsingDataHistoryObserverService::Factory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 22";
   browser_sync::UserEventServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 23";
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   CaptivePortalServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 24";
   CertificateReportingServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 25";
+  if (full_init)
   ChromeBrowsingDataRemoverDelegateFactory::GetInstance();
   ChromeSigninClientFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 28";
   ClientHintsFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 29";
 #if BUILDFLAG(ENABLE_PRINT_PREVIEW) && !defined(OS_CHROMEOS)
   CloudPrintProxyServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 30";
   ConsentAuditorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 31";
   ContentSuggestionsServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 32";
   CookieSettingsFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 33";
   NotifierStateTrackerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 34";
   dom_distiller::DomDistillerServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 35";
   DownloadCoreServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 36";
   DownloadServiceFactory::GetInstance();
 #if defined(OS_ANDROID)
   explore_sites::ExploreSitesServiceFactory::GetInstance();
 #endif
   FaviconServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 41";
+  if (full_init)
   HistoryUiFaviconRequestHandlerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 42";
 #if BUILDFLAG(ENABLE_LEGACY_DESKTOP_IN_PRODUCT_HELP)
   feature_engagement::BookmarkTrackerFactory::GetInstance();
   feature_engagement::IncognitoWindowTrackerFactory::GetInstance();
   feature_engagement::NewTabTrackerFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 43";
   feature_engagement::TrackerFactory::GetInstance();
 #if !defined(OS_ANDROID)
   feedback::FeedbackUploaderFactoryChrome::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 44";
   FindBarStateFactory::GetInstance();
   GAIAInfoUpdateServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 45";
 #if !defined(OS_ANDROID)
   GlobalErrorServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 46";
   GoogleSearchDomainMixingMetricsEmitterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47";
   HistoryServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-1";
   HostContentSettingsMapFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-2";
   IdentityManagerFactory::EnsureFactoryAndDependeeFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-3";
   InMemoryURLIndexFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-4";
   invalidation::DeprecatedProfileInvalidationProviderFactory::GetInstance();
-#if !defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-5";
+#if true || !defined(OS_ANDROID)
   InstantServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-6";
 #if BUILDFLAG(ENABLE_SERVICE_DISCOVERY)
   cloud_print::PrivetNotificationServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-7";
   RendererUpdaterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 48";
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
+  if (full_init)
   SupervisedUserServiceFactory::GetInstance();
 #endif
   LanguageModelManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 48-4";
 #if !defined(OS_ANDROID)
   LoginUIServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 49";
   if (MediaEngagementService::IsEnabled())
     MediaEngagementServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 50";
   media_router::MediaRouterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 51";
 #if !defined(OS_ANDROID)
   media_router::MediaRouterUIServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 52";
 #if defined(OS_ANDROID)
   MediaDrmOriginIdManagerFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 53";
 #if !defined(OS_ANDROID)
   MediaGalleriesPreferencesFactory::GetInstance();
 #endif
   if (base::FeatureList::IsEnabled(media::kUseMediaHistoryStore))
     media_history::MediaHistoryKeyedServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 54";
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
   metrics::DesktopProfileSessionDurationsServiceFactory::GetInstance();
@@ -300,10 +365,11 @@ void ChromeBrowserMainExtraPartsProfiles::
   NTPResourceCacheFactory::GetInstance();
 #endif
   PasswordStoreFactory::GetInstance();
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   PinnedTabServiceFactory::GetInstance();
   ThemeServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 55";
 #if BUILDFLAG(ENABLE_PLUGINS)
   PluginPrefsFactory::GetInstance();
 #endif
@@ -311,34 +377,59 @@ void ChromeBrowserMainExtraPartsProfiles::
 #if !defined(OS_CHROMEOS)
   policy::UserPolicySigninServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58";
   policy::UserCloudPolicyInvalidatorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-1";
+  if (full_init)
   predictors::AutocompleteActionPredictorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-2";
+  if (full_init)
   predictors::PredictorDatabaseFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-3";
+  if (full_init)
   predictors::LoadingPredictorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-4";
+  if (full_init)
   prerender::PrerenderLinkManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-5";
+  if (full_init)
   prerender::PrerenderManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-6";
+  if (full_init)
   prerender::PrerenderMessageFilter::EnsureShutdownNotifierFactoryBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-7";
   ProfileSyncServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-8";
   ProtocolHandlerRegistryFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 59";
 #if !defined(OS_ANDROID)
   resource_coordinator::LocalSiteCharacteristicsDataStoreFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 59-1";
 #if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::AdvancedProtectionStatusManagerFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 60";
 #if defined(OS_ANDROID)
   SearchPermissionsService::Factory::GetInstance();
 #endif
   send_tab_to_self::SendTabToSelfClientServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 61";
 #if BUILDFLAG(ENABLE_SESSION_SERVICE)
   SessionServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62";
+  if (full_init)
   SharingServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-1";
   ShortcutsBackendFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-2";
   SigninProfileAttributesUpdaterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-3";
 
   if (SiteEngagementService::IsEnabled())
     SiteEngagementServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-4";
 
 #if BUILDFLAG(ENABLE_SPELLCHECK)
   SpellcheckServiceFactory::GetInstance();
@@ -347,25 +438,40 @@ void ChromeBrowserMainExtraPartsProfiles::
   StorageNotificationServiceFactory::GetInstance();
 #endif
   suggestions::SuggestionsServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 63";
   TabRestoreServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-1";
   TemplateURLFetcherFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-2";
   TemplateURLServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-3";
   TopSitesFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-4";
   translate::TranslateRankerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65";
 #if defined(OS_WIN)
   TriggeredProfileResetterFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65-1";
   UnifiedConsentServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65-2";
   UrlLanguageHistogramFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 66";
 #if !defined(OS_ANDROID)
   UsbChooserContextFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 67";
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
   web_app::WebAppProviderFactory::GetInstance();
   web_app::WebAppMetricsFactory::GetInstance();
+  }
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 68";
   WebDataServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 69";
   webrtc_event_logging::WebRtcEventLogManagerKeyedServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 70";
 }
 
 void ChromeBrowserMainExtraPartsProfiles::PreProfileInit() {
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
index 8b366bcf4331..584ac76e307e 100644
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
@@ -23,7 +23,7 @@ class ChromeBrowserMainExtraPartsProfiles : public ChromeBrowserMainExtraParts {
   // Instantiates all chrome KeyedService factories, which is
   // especially important for services that should be created at profile
   // creation time as compared to lazily on first access.
-  static void EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  static void EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init = true);
 
   // Overridden from ChromeBrowserMainExtraParts:
   void PreProfileInit() override;
diff --git a/chrome/browser/profiles/off_the_record_profile_impl.cc b/chrome/browser/profiles/off_the_record_profile_impl.cc
index 9d71bfd22580..284868293675 100644
--- a/chrome/browser/profiles/off_the_record_profile_impl.cc
+++ b/chrome/browser/profiles/off_the_record_profile_impl.cc
@@ -76,7 +76,6 @@
 
 #if defined(OS_ANDROID)
 #include "components/prefs/scoped_user_pref_update.h"
-#else  // !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_otr_delegate.h"
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/browser/host_zoom_map.h"
@@ -110,7 +109,7 @@
 
 using content::BrowserThread;
 using content::DownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 using content::HostZoomMap;
 #endif
 
@@ -162,7 +161,7 @@ void OffTheRecordProfileImpl::Init() {
         IncognitoModePrefs::GetAvailability(profile_->GetPrefs()) !=
             IncognitoModePrefs::DISABLED);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   TrackZoomLevelsFromParent();
 #endif
 
@@ -236,7 +235,7 @@ void OffTheRecordProfileImpl::InitIoData() {
   io_data_.reset(new OffTheRecordProfileIOData::Handle(this));
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OffTheRecordProfileImpl::TrackZoomLevelsFromParent() {
   DCHECK(!profile_->IsIncognitoProfile());
 
@@ -290,7 +289,7 @@ base::Time OffTheRecordProfileImpl::GetCreationTime() const {
   return start_time_;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 OffTheRecordProfileImpl::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
@@ -635,7 +634,7 @@ Profile* Profile::CreateOffTheRecordProfile() {
   return profile;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OffTheRecordProfileImpl::OnParentZoomLevelChanged(
     const HostZoomMap::ZoomLevelChange& change) {
   HostZoomMap* host_zoom_map = HostZoomMap::GetDefaultForBrowserContext(this);
diff --git a/chrome/browser/profiles/off_the_record_profile_impl.h b/chrome/browser/profiles/off_the_record_profile_impl.h
index f805b608cac2..c4ebe3a2753e 100644
--- a/chrome/browser/profiles/off_the_record_profile_impl.h
+++ b/chrome/browser/profiles/off_the_record_profile_impl.h
@@ -17,7 +17,7 @@
 #include "components/domain_reliability/clear_mode.h"
 #include "content/public/browser/content_browser_client.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -93,7 +93,7 @@ class OffTheRecordProfileImpl : public Profile {
   base::FilePath GetPath() override;
   base::FilePath GetPath() const override;
   base::Time GetCreationTime() const override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
@@ -129,12 +129,12 @@ class OffTheRecordProfileImpl : public Profile {
  private:
   void InitIoData();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Allows a profile to track changes in zoom levels in its parent profile.
   void TrackZoomLevelsFromParent();
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Callback function for tracking parent's zoom level changes.
   void OnParentZoomLevelChanged(
       const content::HostZoomMap::ZoomLevelChange& change);
@@ -146,7 +146,7 @@ class OffTheRecordProfileImpl : public Profile {
 
   std::unique_ptr<sync_preferences::PrefServiceSyncable> prefs_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::HostZoomMap::Subscription> track_zoom_subscription_;
   std::unique_ptr<ChromeZoomLevelPrefs::DefaultZoomLevelSubscription>
       parent_default_zoom_level_subscription_;
diff --git a/chrome/browser/profiles/profile.cc b/chrome/browser/profiles/profile.cc
index 2b1140fdd27e..4a5625924812 100644
--- a/chrome/browser/profiles/profile.cc
+++ b/chrome/browser/profiles/profile.cc
@@ -39,7 +39,7 @@
 #include "chromeos/constants/chromeos_switches.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/first_run/first_run.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -129,7 +129,7 @@ TestingProfile* Profile::AsTestingProfile() {
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ChromeZoomLevelPrefs* Profile::GetZoomLevelPrefs() {
   return nullptr;
 }
diff --git a/chrome/browser/profiles/profile.h b/chrome/browser/profiles/profile.h
index 458c4acb0851..0d59f20ff6ae 100644
--- a/chrome/browser/profiles/profile.h
+++ b/chrome/browser/profiles/profile.h
@@ -21,7 +21,7 @@
 #include "services/network/public/mojom/network_context.mojom-forward.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class ChromeZoomLevelPrefs;
 #endif
 
@@ -218,7 +218,7 @@ class Profile : public content::BrowserContext {
   virtual PrefService* GetPrefs() = 0;
   virtual const PrefService* GetPrefs() const = 0;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Retrieves a pointer to the PrefService that manages the default zoom
   // level and the per-host zoom levels for this user profile.
   // TODO(wjmaclean): Remove this when HostZoomMap migrates to StoragePartition.
@@ -425,7 +425,7 @@ class Profile : public content::BrowserContext {
   // correctly assigned to its owner.
   Profile* CreateOffTheRecordProfile();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Convenience method to retrieve the default zoom level for the default
   // storage partition.
   double GetDefaultZoomLevelForProfile();
diff --git a/chrome/browser/profiles/profile_impl.cc b/chrome/browser/profiles/profile_impl.cc
index fc6e53edf708..3023d9885d20 100644
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -186,7 +186,6 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/profile_key_startup_accessor.h"
-#else
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/common/page_zoom.h"
 #endif
@@ -366,12 +365,14 @@ const char ProfileImpl::kPrefExitTypeNormal[] = "Normal";
 // static
 void ProfileImpl::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 1";
   registry->RegisterBooleanPref(prefs::kSavingBrowserHistoryDisabled, false);
   registry->RegisterBooleanPref(prefs::kAllowDeletingBrowserHistory, true);
   registry->RegisterBooleanPref(prefs::kForceGoogleSafeSearch, false);
   registry->RegisterIntegerPref(prefs::kForceYouTubeRestrict,
                                 safe_search_util::YOUTUBE_RESTRICT_OFF);
   registry->RegisterStringPref(prefs::kAllowedDomainsForApps, std::string());
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 2";
 
   registry->RegisterIntegerPref(prefs::kProfileAvatarIndex, -1);
   // Whether a profile is using an avatar without having explicitely chosen it
@@ -392,6 +393,7 @@ void ProfileImpl::RegisterProfilePrefs(
                                home_page_flags);
   registry->RegisterStringPref(prefs::kNewTabPageLocationOverride,
                                std::string());
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 3";
 
 #if BUILDFLAG(ENABLE_PRINTING)
   registry->RegisterBooleanPref(prefs::kPrintingEnabled, true);
@@ -406,9 +408,10 @@ void ProfileImpl::RegisterProfilePrefs(
       prefs::kOobeMarketingOptInScreenFinished, false,
       user_prefs::PrefRegistrySyncable::SYNCABLE_OS_PREF);
 #endif  // defined(OS_CHROMEOS)
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(prefs::kShowCastIconInToolbar, false);
 #endif  // !defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 4";
 }
 
 ProfileImpl::ProfileImpl(
@@ -807,7 +810,7 @@ Profile::ProfileType ProfileImpl::GetProfileType() const {
   return REGULAR_PROFILE;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 ProfileImpl::CreateZoomLevelDelegate(const base::FilePath& partition_path) {
   return std::make_unique<ChromeZoomLevelPrefs>(
@@ -1062,7 +1065,7 @@ const PrefService* ProfileImpl::GetPrefs() const {
   return prefs_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ChromeZoomLevelPrefs* ProfileImpl::GetZoomLevelPrefs() {
   return static_cast<ChromeZoomLevelPrefs*>(
       GetDefaultStoragePartition(this)->GetZoomLevelDelegate());
diff --git a/chrome/browser/profiles/profile_impl.h b/chrome/browser/profiles/profile_impl.h
index 7c835593998b..051b36eed26b 100644
--- a/chrome/browser/profiles/profile_impl.h
+++ b/chrome/browser/profiles/profile_impl.h
@@ -27,7 +27,7 @@
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/identity/public/mojom/identity_service.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -76,7 +76,7 @@ class ProfileImpl : public Profile {
   static void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry);
 
   // content::BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif
@@ -133,7 +133,7 @@ class ProfileImpl : public Profile {
   ExtensionSpecialStoragePolicy* GetExtensionSpecialStoragePolicy() override;
   PrefService* GetPrefs() override;
   const PrefService* GetPrefs() const override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   ChromeZoomLevelPrefs* GetZoomLevelPrefs() override;
 #endif
   PrefService* GetOffTheRecordPrefs() override;
diff --git a/chrome/browser/profiles/profile_manager.cc b/chrome/browser/profiles/profile_manager.cc
index c5ab679fb529..6ba38f9efec6 100644
--- a/chrome/browser/profiles/profile_manager.cc
+++ b/chrome/browser/profiles/profile_manager.cc
@@ -123,7 +123,7 @@
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/metrics/android_profile_session_durations_service_factory.h"
 #include "chrome/browser/ntp_snippets/content_suggestions_service_factory.h"
-#else
+
 #include "chrome/browser/first_run/first_run.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -235,7 +235,7 @@ void ProfileSizeTask(const base::FilePath& path, int enabled_app_count) {
     UMA_HISTOGRAM_COUNTS_10000("Profile.AppCount", enabled_app_count);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Schedule a profile for deletion if it isn't already scheduled.
 // Returns whether the profile has been newly scheduled.
 bool ScheduleProfileDirectoryForDeletion(const base::FilePath& path) {
@@ -803,7 +803,7 @@ ProfileShortcutManager* ProfileManager::profile_shortcut_manager() {
   return profile_shortcut_manager_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileManager::MaybeScheduleProfileForDeletion(
     const base::FilePath& profile_dir,
     ProfileLoadedCallback callback,
@@ -1408,7 +1408,7 @@ Profile* ProfileManager::CreateAndInitializeProfile(
   return profile_ptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileManager::EnsureActiveProfileExistsBeforeDeletion(
     ProfileLoadedCallback callback,
     const base::FilePath& profile_dir) {
@@ -1724,7 +1724,7 @@ void ProfileManager::SaveActiveProfiles() {
   }
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileManager::OnBrowserOpened(Browser* browser) {
   DCHECK(browser);
   Profile* profile = browser->profile();
@@ -1856,7 +1856,7 @@ void ProfileManager::OnNewActiveProfileLoaded(
 void ProfileManager::ScheduleForcedEphemeralProfileForDeletion(
     const base::FilePath& profile_dir) {
   DCHECK_EQ(0u, chrome::GetBrowserCount(GetProfileByPath(profile_dir)));
-  DCHECK(IsProfileEphemeral(&GetProfileAttributesStorage(), profile_dir));
+//  DCHECK(IsProfileEphemeral(&GetProfileAttributesStorage(), profile_dir));
 
   // Search for latest active profile, already loaded preferably.
   bool found_entry_loaded = false;
diff --git a/chrome/browser/profiles/profile_manager.h b/chrome/browser/profiles/profile_manager.h
index 7d02af7f8f60..87c16b05395a 100644
--- a/chrome/browser/profiles/profile_manager.h
+++ b/chrome/browser/profiles/profile_manager.h
@@ -199,7 +199,7 @@ class ProfileManager : public content::NotificationObserver,
   // profile specfic desktop shortcuts.
   ProfileShortcutManager* profile_shortcut_manager();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Less strict version of ScheduleProfileForDeletion(), silently exits if
   // profile is either scheduling or marked for deletion.
   void MaybeScheduleProfileForDeletion(
@@ -315,7 +315,7 @@ class ProfileManager : public content::NotificationObserver,
   // null if creation fails.
   Profile* CreateAndInitializeProfile(const base::FilePath& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Continues the scheduled profile deletion after closing all the profile's
   // browsers tabs. Creates a new profile if the profile to be deleted is the
   // last non-supervised profile. In the Mac, loads the next non-supervised
@@ -367,7 +367,7 @@ class ProfileManager : public content::NotificationObserver,
 
   void SaveActiveProfiles();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   void OnBrowserOpened(Browser* browser);
   void OnBrowserClosed(Browser* browser);
 
diff --git a/chrome/browser/profiles/profile_metrics.cc b/chrome/browser/profiles/profile_metrics.cc
index 353f18928bc9..a77117a0e0dd 100644
--- a/chrome/browser/profiles/profile_metrics.cc
+++ b/chrome/browser/profiles/profile_metrics.cc
@@ -25,7 +25,7 @@
 #include "components/signin/core/browser/signin_header_helper.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #endif
 
@@ -33,7 +33,7 @@ namespace {
 
 const int kMaximumDaysOfDisuse = 4 * 7;  // Should be integral number of weeks.
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 size_t number_of_profile_switches_ = 0;
 #endif
 
@@ -47,7 +47,7 @@ enum ProfileOpenState {
   PROFILE_UNOPENED
 };
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ProfileOpenState GetProfileOpenState(
     ProfileManager* manager,
     const base::FilePath& path) {
@@ -463,7 +463,7 @@ void ProfileMetrics::LogProfileOpenMethod(ProfileOpen metric) {
                             NUM_PROFILE_OPEN_METRICS);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileMetrics::LogProfileSwitch(
     ProfileOpen metric,
     ProfileManager* manager,
diff --git a/chrome/browser/profiles/profile_metrics.h b/chrome/browser/profiles/profile_metrics.h
index fed2dca9615e..a47547328988 100644
--- a/chrome/browser/profiles/profile_metrics.h
+++ b/chrome/browser/profiles/profile_metrics.h
@@ -190,7 +190,7 @@ class ProfileMetrics {
   static void LogProfileAvatarSelection(size_t icon_index);
   static void LogProfileDeleteUser(ProfileDelete metric);
   static void LogProfileOpenMethod(ProfileOpen metric);
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   static void LogProfileSwitch(ProfileOpen metric,
                                ProfileManager* manager,
                                const base::FilePath& profile_path);
diff --git a/chrome/browser/profiles/profile_window.cc b/chrome/browser/profiles/profile_window.cc
index 4f453ac671bd..651d4d8fe8ec 100644
--- a/chrome/browser/profiles/profile_window.cc
+++ b/chrome/browser/profiles/profile_window.cc
@@ -54,7 +54,7 @@
 #include "extensions/browser/extension_system.h"
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_list_observer.h"
@@ -253,7 +253,7 @@ void OpenBrowserWindowForProfile(ProfileManager::CreateCallback callback,
                                             is_first_run, true);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 void LoadProfileAsync(const base::FilePath& path,
                       ProfileManager::CreateCallback callback) {
diff --git a/chrome/browser/profiles/profile_window.h b/chrome/browser/profiles/profile_window.h
index 00014301cdb5..e98d510b4c73 100644
--- a/chrome/browser/profiles/profile_window.h
+++ b/chrome/browser/profiles/profile_window.h
@@ -15,10 +15,6 @@
 #include "chrome/browser/ui/profile_chooser_constants.h"
 #include "chrome/browser/ui/startup/startup_types.h"
 
-#if defined(OS_ANDROID)
-#error "Not used on Android"
-#endif
-
 class Profile;
 
 namespace base { class FilePath; }
diff --git a/chrome/browser/profiles/profiles_state.cc b/chrome/browser/profiles/profiles_state.cc
index 2e6a1b274dde..c480c93a5691 100644
--- a/chrome/browser/profiles/profiles_state.cc
+++ b/chrome/browser/profiles/profiles_state.cc
@@ -27,7 +27,7 @@
 #include "content/public/browser/browsing_data_remover.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -82,7 +82,7 @@ void SetLastUsedProfile(const std::string& profile_dir) {
   local_state->SetString(prefs::kProfileLastUsed, profile_dir);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 base::string16 GetAvatarNameForProfile(const base::FilePath& profile_path) {
   if (profile_path == ProfileManager::GetGuestProfilePath()) {
     return l10n_util::GetStringUTF16(IDS_GUEST_PROFILE_NAME);
diff --git a/chrome/browser/profiles/profiles_state.h b/chrome/browser/profiles/profiles_state.h
index 6d3e919daea1..90e33a7cf123 100644
--- a/chrome/browser/profiles/profiles_state.h
+++ b/chrome/browser/profiles/profiles_state.h
@@ -43,7 +43,7 @@ void RegisterPrefs(PrefRegistrySimple* registry);
 // System Profile directory, which is an invalid last used profile.
 void SetLastUsedProfile(const std::string& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Returns the display name of the specified on-the-record profile (or guest),
 // specified by |profile_path|, used in the avatar button or user manager. If
 // |profile_path| is the guest path, it will return IDS_GUEST_PROFILE_NAME. If
diff --git a/chrome/browser/renderer_context_menu/render_view_context_menu.cc b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
index 491e36bcdfba..2a3df2d0119d 100644
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.cc
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
@@ -157,7 +157,7 @@
 #include "ui/gfx/text_elider.h"
 #include "ui/strings/grit/ui_strings.h"
 
-#if BUILDFLAG(USE_RENDERER_SPELLCHECKER)
+#if true || BUILDFLAG(USE_RENDERER_SPELLCHECKER)
 #include "chrome/browser/renderer_context_menu/spelling_options_submenu_observer.h"
 #endif
 
@@ -1746,16 +1746,6 @@ void RenderViewContextMenu::AppendLanguageSettings() {
 #if defined(OS_MACOSX)
   menu_model_.AddItemWithStringId(IDC_CONTENT_CONTEXT_LANGUAGE_SETTINGS,
                                   IDS_CONTENT_CONTEXT_LANGUAGE_SETTINGS);
-#else
-  if (!spelling_options_submenu_observer_) {
-    const int kLanguageRadioGroup = 1;
-    spelling_options_submenu_observer_ =
-        std::make_unique<SpellingOptionsSubMenuObserver>(this, this,
-                                                         kLanguageRadioGroup);
-  }
-
-  spelling_options_submenu_observer_->InitMenu(params_);
-  observers_.AddObserver(spelling_options_submenu_observer_.get());
 #endif
 }
 
diff --git a/chrome/browser/renderer_context_menu/render_view_context_menu.h b/chrome/browser/renderer_context_menu/render_view_context_menu.h
index d5195d4b0f6c..2044bfc6f2ec 100644
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.h
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.h
@@ -33,6 +33,8 @@
 #include "chrome/browser/extensions/menu_manager.h"
 #endif
 
+#include "chrome/browser/renderer_context_menu/spelling_options_submenu_observer.h"
+
 class AccessibilityLabelsMenuObserver;
 class ClickToCallContextMenuObserver;
 class PrintPreviewContextMenuObserver;
diff --git a/chrome/browser/resource_coordinator/resource_coordinator_parts.cc b/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
index 577b26d47bfa..a4cd9e009950 100644
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
@@ -9,12 +9,12 @@
 namespace resource_coordinator {
 
 ResourceCoordinatorParts::ResourceCoordinatorParts()
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     : tab_manager_(&tab_load_tracker_),
       tab_lifecycle_unit_source_(tab_manager_.usage_clock())
 #endif
 {
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   tab_lifecycle_unit_source_.AddObserver(&tab_manager_);
 #endif
 }
diff --git a/chrome/browser/resource_coordinator/resource_coordinator_parts.h b/chrome/browser/resource_coordinator/resource_coordinator_parts.h
index 788e4bd6f9a2..5229f60a7f63 100644
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.h
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.h
@@ -10,7 +10,7 @@
 #include "chrome/browser/resource_coordinator/tab_load_tracker.h"
 #include "chrome/browser/resource_coordinator/tab_memory_metrics_reporter.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/resource_coordinator/tab_lifecycle_unit_source.h"
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
@@ -39,19 +39,11 @@ class ResourceCoordinatorParts {
   TabLoadTracker* tab_load_tracker() { return &tab_load_tracker_; }
 
   TabManager* tab_manager() {
-#if defined(OS_ANDROID)
-    return nullptr;
-#else
     return &tab_manager_;
-#endif  // defined(OS_ANDROID)
   }
 
   TabLifecycleUnitSource* tab_lifecycle_unit_source() {
-#if defined(OS_ANDROID)
-    return nullptr;
-#else
     return &tab_lifecycle_unit_source_;
-#endif  // defined(OS_ANDROID)
   }
 
  private:
@@ -62,7 +54,7 @@ class ResourceCoordinatorParts {
   // Created on demand the first time it's being accessed.
   std::unique_ptr<TabMemoryMetricsReporter> tab_memory_metrics_reporter_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Any change to this #ifdef must be reflected as well in
   // chrome/browser/resource_coordinator/tab_manager_browsertest.cc
   //
diff --git a/chrome/browser/resource_coordinator/tab_helper.cc b/chrome/browser/resource_coordinator/tab_helper.cc
index e3e1822e974e..58ce5d97699b 100644
--- a/chrome/browser/resource_coordinator/tab_helper.cc
+++ b/chrome/browser/resource_coordinator/tab_helper.cc
@@ -25,7 +25,7 @@
 #include "content/public/browser/render_process_host.h"
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/resource_coordinator/local_site_characteristics_webcontents_observer.h"
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
@@ -43,7 +43,7 @@ ResourceCoordinatorTabHelper::ResourceCoordinatorTabHelper(
         TabLoadTracker::Get());
   }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   local_site_characteristics_wc_observer_ =
       std::make_unique<LocalSiteCharacteristicsWebContentsObserver>(
           web_contents);
diff --git a/chrome/browser/resource_coordinator/tab_helper.h b/chrome/browser/resource_coordinator/tab_helper.h
index ada74f4c0539..21af0b72fa74 100644
--- a/chrome/browser/resource_coordinator/tab_helper.h
+++ b/chrome/browser/resource_coordinator/tab_helper.h
@@ -53,7 +53,7 @@ class ResourceCoordinatorTabHelper
   ukm::SourceId ukm_source_id() const { return ukm_source_id_; }
   void SetUkmSourceIdForTest(ukm::SourceId id) { ukm_source_id_ = id; }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   LocalSiteCharacteristicsWebContentsObserver*
   local_site_characteristics_wc_observer() {
     return local_site_characteristics_wc_observer_.get();
@@ -68,7 +68,7 @@ class ResourceCoordinatorTabHelper
 
   friend class content::WebContentsUserData<ResourceCoordinatorTabHelper>;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<LocalSiteCharacteristicsWebContentsObserver>
       local_site_characteristics_wc_observer_;
 #endif
diff --git a/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc b/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc
index b0788d433142..5e4a9e980b67 100644
--- a/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc
+++ b/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc
@@ -41,6 +41,9 @@ void TabManager::WebContentsData::DidStartNavigation(
 void TabManager::WebContentsData::DidFinishNavigation(
     content::NavigationHandle* navigation_handle) {
   SetIsInSessionRestore(false);
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation A: " << g_browser_process;
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation B: " << g_browser_process->GetTabManager();
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation C: " << navigation_handle;
   g_browser_process->GetTabManager()->OnDidFinishNavigation(navigation_handle);
 }
 
diff --git a/chrome/browser/resources/BUILD.gn b/chrome/browser/resources/BUILD.gn
index dee22c328366..765056543fd9 100644
--- a/chrome/browser/resources/BUILD.gn
+++ b/chrome/browser/resources/BUILD.gn
@@ -17,7 +17,7 @@ if (closure_compile) {
       "interventions_internals:closure_compile",
       "reset_password:closure_compile",
     ]
-    if (is_linux || is_win || is_mac) {
+    if (true || is_linux || is_win || is_mac) {
       deps += [
         "bluetooth_internals:closure_compile",
         "bookmarks:closure_compile",
@@ -69,7 +69,7 @@ if (closure_compile) {
   }
 }
 
-if (!is_android) {
+if (true || !is_android) {
   grit("bookmarks_resources") {
     # The .grd contains references to generated files.
     source_is_generated = true
@@ -288,7 +288,7 @@ if (is_chromeos) {
   }
 }
 
-if (!is_android && !is_chromeos) {
+if (true || (!is_android && !is_chromeos)) {
   grit("welcome_resources") {
     source = "welcome/welcome_resources.grd"
 
diff --git a/chrome/browser/resources/md_extensions/extensions.html b/chrome/browser/resources/md_extensions/extensions.html
new file mode 100644
index 000000000000..94f99121fcb7
--- /dev/null
+++ b/chrome/browser/resources/md_extensions/extensions.html
@@ -0,0 +1,47 @@
+<!doctype html>
+<html dir="$i18n{textdirection}" lang="$i18n{language}"
+    class="loading $i18n{loadTimeClasses}">
+<head>
+  <meta charset="utf8">
+  <title>$i18n{title}</title>
+  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
+<if expr="not optimize_webui">
+  <base href="chrome://extensions">
+</if>
+  <style>
+    html {
+      /* --md-background-color in disguise. Not using the var for increased
+       * performance. */
+      background-color: rgb(248, 249, 250);
+
+      /* Remove 300ms delay for 'click' event, when using touch interface. */
+      touch-action: manipulation;
+    }
+
+    .loading {
+      /* --google-blue-700 in disguise. Replaced when manager.html loads. */
+      border-top: 56px solid rgb(51, 103, 214);
+    }
+
+    /* Note: .in-dev-mode is applied by i18n{loadTimeClasses}. */
+    .loading.in-dev-mode {
+      border-top-width: 96px;
+    }
+
+    html,
+    body {
+      height: 100%;
+      line-height: 154%;
+      margin: 0;
+      overflow: hidden;
+      width: 100%;
+    }
+  </style>
+</head>
+<body>
+  <extensions-manager></extensions-manager>
+  <link rel="stylesheet" href="chrome://resources/css/md_colors.css">
+  <link rel="stylesheet" href="chrome://resources/css/text_defaults_md.css">
+  <link rel="import" href="chrome://extensions/manager.html">
+</body>
+</html>
diff --git a/chrome/browser/resources/unpack_pak.py b/chrome/browser/resources/unpack_pak.py
index d0c6ef693325..3689508027c0 100755
--- a/chrome/browser/resources/unpack_pak.py
+++ b/chrome/browser/resources/unpack_pak.py
@@ -50,6 +50,10 @@ def Unpack(pak_path, out_path):
       res = re.match('^#define (\S*).* (\d+)\)?$', line)
       if res:
         resource_ids[int(res.group(2))] = res.group(1)
+      else:
+        res = re.match('#define ([^ ]+) ([^ ]+) (\d+)', line)
+        if res:
+          resource_ids[int(res.group(3))] = res.group(1)
   assert resource_ids
 
   # Associate numerical string IDs to files.
diff --git a/chrome/browser/search/instant_service.h b/chrome/browser/search/instant_service.h
index 4a4ba44043ad..cace1b724b4b 100644
--- a/chrome/browser/search/instant_service.h
+++ b/chrome/browser/search/instant_service.h
@@ -33,10 +33,6 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class InstantIOContext;
 class InstantServiceObserver;
 class Profile;
diff --git a/chrome/browser/search/instant_service_factory.h b/chrome/browser/search/instant_service_factory.h
index 2db314b90617..4d3e053d532f 100644
--- a/chrome/browser/search/instant_service_factory.h
+++ b/chrome/browser/search/instant_service_factory.h
@@ -10,10 +10,6 @@
 #include "build/build_config.h"
 #include "components/keyed_service/content/browser_context_keyed_service_factory.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class InstantService;
 class Profile;
 
diff --git a/chrome/browser/search/instant_service_observer.h b/chrome/browser/search/instant_service_observer.h
index 29b80c5cc853..0575e64c191e 100644
--- a/chrome/browser/search/instant_service_observer.h
+++ b/chrome/browser/search/instant_service_observer.h
@@ -9,10 +9,6 @@
 
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 struct InstantMostVisitedInfo;
 struct NtpTheme;
 
diff --git a/chrome/browser/search/local_ntp_source.h b/chrome/browser/search/local_ntp_source.h
index 0d299a5f2600..7644cfddac4a 100644
--- a/chrome/browser/search/local_ntp_source.h
+++ b/chrome/browser/search/local_ntp_source.h
@@ -26,10 +26,6 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 struct OneGoogleBarData;
 struct PromoData;
 class Profile;
diff --git a/chrome/browser/search/most_visited_iframe_source.h b/chrome/browser/search/most_visited_iframe_source.h
index c0ecdacffab8..8c88fab79fc2 100644
--- a/chrome/browser/search/most_visited_iframe_source.h
+++ b/chrome/browser/search/most_visited_iframe_source.h
@@ -9,10 +9,6 @@
 #include "build/build_config.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 // Serves HTML for displaying suggestions using iframes, e.g.
 // chrome-search://most-visited/single.html
 class MostVisitedIframeSource : public content::URLDataSource {
diff --git a/chrome/browser/sharing/click_to_call/feature.cc b/chrome/browser/sharing/click_to_call/feature.cc
index 9921fd492667..06e572476c1f 100644
--- a/chrome/browser/sharing/click_to_call/feature.cc
+++ b/chrome/browser/sharing/click_to_call/feature.cc
@@ -9,7 +9,7 @@ const base::Feature kClickToCallReceiver{"ClickToCallReceiver",
                                          base::FEATURE_ENABLED_BY_DEFAULT};
 #endif  // defined(OS_ANDROID)
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 const base::Feature kClickToCallUI{"ClickToCallUI",
                                    base::FEATURE_ENABLED_BY_DEFAULT};
 
diff --git a/chrome/browser/sharing/click_to_call/feature.h b/chrome/browser/sharing/click_to_call/feature.h
index ca367376f6ac..a5c1ad98a16a 100644
--- a/chrome/browser/sharing/click_to_call/feature.h
+++ b/chrome/browser/sharing/click_to_call/feature.h
@@ -14,7 +14,7 @@
 extern const base::Feature kClickToCallReceiver;
 #endif  // defined(OS_ANDROID)
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 // Feature to allow click to call gets processed on desktop.
 extern const base::Feature kClickToCallUI;
 
diff --git a/chrome/browser/sharing/shared_clipboard/feature_flags.cc b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
index 2fdf694812a7..4f278c961ca8 100644
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.cc
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
@@ -11,7 +11,7 @@ const base::Feature kSharedClipboardUI{"SharedClipboardUI",
                                        base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const base::Feature kRemoteCopyReceiver{"RemoteCopyReceiver",
                                         base::FEATURE_DISABLED_BY_DEFAULT};
 
diff --git a/chrome/browser/sharing/shared_clipboard/feature_flags.h b/chrome/browser/sharing/shared_clipboard/feature_flags.h
index d26791db7a26..d9dffda9c33a 100644
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.h
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.h
@@ -18,7 +18,7 @@ extern const base::Feature kSharedClipboardReceiver;
 extern const base::Feature kSharedClipboardUI;
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 // Feature to enable handling remote copy messages.
 extern const base::Feature kRemoteCopyReceiver;
 
diff --git a/chrome/browser/signin/account_consistency_mode_manager.cc b/chrome/browser/signin/account_consistency_mode_manager.cc
index 75bd8332ec58..430a1cca5093 100644
--- a/chrome/browser/signin/account_consistency_mode_manager.cc
+++ b/chrome/browser/signin/account_consistency_mode_manager.cc
@@ -33,7 +33,9 @@ namespace {
 // Preference indicating that the Dice migraton has happened.
 const char kDiceMigrationCompletePref[] = "signin.DiceMigrationComplete";
 
+#if 0
 const char kDiceMigrationStatusHistogram[] = "Signin.DiceMigrationStatus";
+#endif
 
 // Used for UMA histogram kDiceMigrationStatusHistogram.
 // Do not remove or re-order values.
@@ -47,6 +49,7 @@ enum class DiceMigrationStatus {
   kDiceMigrationStatusCount
 };
 
+#if 0
 DiceMigrationStatus GetDiceMigrationStatus(
     AccountConsistencyMethod account_consistency) {
   switch (account_consistency) {
@@ -60,6 +63,7 @@ DiceMigrationStatus GetDiceMigrationStatus(
   }
 }
 #endif
+#endif
 
 }  // namespace
 
@@ -93,7 +97,7 @@ AccountConsistencyModeManager::AccountConsistencyModeManager(Profile* profile)
 
   account_consistency_ = ComputeAccountConsistencyMethod(profile_);
 
-#if BUILDFLAG(ENABLE_DICE_SUPPORT)
+#if false && BUILDFLAG(ENABLE_DICE_SUPPORT)
   // New profiles don't need Dice migration. Old profiles may need it if they
   // were created before Dice.
   if (profile_->IsNewProfile())
diff --git a/chrome/browser/signin/chrome_signin_helper.cc b/chrome/browser/signin/chrome_signin_helper.cc
index f73fca57478f..73917f70e8d7 100644
--- a/chrome/browser/signin/chrome_signin_helper.cc
+++ b/chrome/browser/signin/chrome_signin_helper.cc
@@ -48,7 +48,7 @@
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/signin/signin_utils.h"
 #include "ui/android/view_android.h"
-#else
+
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_window.h"
diff --git a/chrome/browser/spellchecker/spelling_service_client.cc b/chrome/browser/spellchecker/spelling_service_client.cc
new file mode 100644
index 000000000000..7b888886b357
--- /dev/null
+++ b/chrome/browser/spellchecker/spelling_service_client.cc
@@ -0,0 +1,343 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/spellcheck/browser/spelling_service_client.h"
+
+#include <stddef.h>
+
+#include <algorithm>
+#include <memory>
+
+#include "base/bind.h"
+#include "base/json/json_reader.h"
+#include "base/json/string_escape.h"
+#include "base/memory/ptr_util.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/values.h"
+#include "components/prefs/pref_service.h"
+#include "components/spellcheck/browser/pref_names.h"
+#include "components/spellcheck/common/spellcheck_common.h"
+#include "components/spellcheck/common/spellcheck_result.h"
+#include "components/user_prefs/user_prefs.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/storage_partition.h"
+#include "google_apis/google_api_keys.h"
+#include "net/base/load_flags.h"
+#include "services/network/public/cpp/resource_request.h"
+#include "services/network/public/cpp/shared_url_loader_factory.h"
+#include "services/network/public/cpp/simple_url_loader.h"
+#include "url/gurl.h"
+
+namespace {
+
+// The REST endpoint for requesting spell checking and sending user feedback.
+const char kSpellingServiceRestURL[] =
+    "https://www.googleapis.com/spelling/v%d/spelling/check?key=%s";
+
+// The spellcheck suggestions object key in the JSON response from the spelling
+// service.
+const char kMisspellingsRestPath[] = "spellingCheckResponse.misspellings";
+
+// The location of error messages in JSON response from spelling service.
+const char kErrorPath[] = "error";
+
+// Languages currently supported by SPELLCHECK.
+const char* const kValidLanguages[] = {"en", "es", "fi", "da"};
+
+}  // namespace
+
+SpellingServiceClient::SpellingServiceClient() = default;
+
+SpellingServiceClient::~SpellingServiceClient() = default;
+
+bool SpellingServiceClient::RequestTextCheck(
+    content::BrowserContext* context,
+    ServiceType type,
+    const base::string16& text,
+    TextCheckCompleteCallback callback) {
+  DCHECK(type == SUGGEST || type == SPELLCHECK);
+  if (!context || !IsAvailable(context, type)) {
+    std::move(callback).Run(false, text, std::vector<SpellCheckResult>());
+    return false;
+  }
+  const PrefService* pref = user_prefs::UserPrefs::Get(context);
+  DCHECK(pref);
+
+  std::string dictionary;
+  pref->GetList(spellcheck::prefs::kSpellCheckDictionaries)
+      ->GetString(0, &dictionary);
+
+  std::string language_code;
+  std::string country_code;
+  spellcheck::GetISOLanguageCountryCodeFromLocale(dictionary, &language_code,
+                                                  &country_code);
+
+  // Replace typographical apostrophes with typewriter apostrophes, so that
+  // server word breaker behaves correctly.
+  const base::char16 kApostrophe = 0x27;
+  const base::char16 kRightSingleQuotationMark = 0x2019;
+  base::string16 text_copy = text;
+  std::replace(text_copy.begin(), text_copy.end(), kRightSingleQuotationMark,
+               kApostrophe);
+
+  std::string api_key = google_apis::GetAPIKey();
+  std::string encoded_text = base::GetQuotedJSONString(text_copy);
+
+  static const char kSpellingRequestRestBodyTemplate[] =
+      "{"
+      "\"text\":%s,"
+      "\"language\":\"%s\","
+      "\"originCountry\":\"%s\""
+      "}";
+
+  std::string request_body =
+      base::StringPrintf(kSpellingRequestRestBodyTemplate, encoded_text.c_str(),
+                         language_code.c_str(), country_code.c_str());
+
+  // Create traffic annotation tag.
+  net::NetworkTrafficAnnotationTag traffic_annotation =
+      net::DefineNetworkTrafficAnnotation("spellcheck_lookup", R"(
+        semantics {
+          sender: "Online Spellcheck"
+          description:
+            "Chromium can provide smarter spell-checking, by sending the text "
+            "that the users type into the browser, to Google's servers. This"
+            "allows users to use the same spell-checking technology used by "
+            "Google products, such as Docs. If the feature is enabled, "
+            "Chromium will send the entire contents of text fields as user "
+            "types them to Google, along with the browser’s default language. "
+            "Google returns a list of suggested spellings, which will be "
+            "displayed in the context menu."
+          trigger: "User types text into a text field or asks to correct a "
+                   "misspelled word."
+          data: "Text a user has typed into a text field. No user identifier "
+                "is sent along with the text."
+          destination: GOOGLE_OWNED_SERVICE
+        }
+        policy {
+          cookies_allowed: NO
+          setting:
+            "Users can enable or disable this feature via 'Enhanced spell "
+            "check' in Chromium's settings under 'Sync and Google services'. "
+            "The feature is disabled by default."
+          chrome_policy {
+            SpellCheckServiceEnabled {
+                policy_options {mode: MANDATORY}
+                SpellCheckServiceEnabled: false
+            }
+          }
+        })");
+
+  auto resource_request = std::make_unique<network::ResourceRequest>();
+  resource_request->url = BuildEndpointUrl(type);
+  resource_request->credentials_mode = network::mojom::CredentialsMode::kOmit;
+  resource_request->method = "POST";
+
+  std::unique_ptr<network::SimpleURLLoader> simple_url_loader =
+      network::SimpleURLLoader::Create(std::move(resource_request),
+                                       traffic_annotation);
+  simple_url_loader->AttachStringForUpload(request_body, "application/json");
+
+  auto it = spellcheck_loaders_.insert(
+      spellcheck_loaders_.begin(),
+      std::make_unique<TextCheckCallbackData>(std::move(simple_url_loader),
+                                              std::move(callback), text));
+  network::SimpleURLLoader* loader = it->get()->simple_url_loader.get();
+  auto url_loader_factory =
+      url_loader_factory_for_testing_
+          ? url_loader_factory_for_testing_
+          : content::BrowserContext::GetDefaultStoragePartition(context)
+                ->GetURLLoaderFactoryForBrowserProcess();
+  loader->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
+      url_loader_factory.get(),
+      base::BindOnce(&SpellingServiceClient::OnSimpleLoaderComplete,
+                     base::Unretained(this), std::move(it),
+                     base::TimeTicks::Now()));
+  return true;
+}
+
+bool SpellingServiceClient::IsAvailable(content::BrowserContext* context,
+                                        ServiceType type) {
+  const PrefService* pref = user_prefs::UserPrefs::Get(context);
+  DCHECK(pref);
+  // If prefs don't allow spell checking, if enhanced spell check is disabled,
+  // or if the context is off the record, the spelling service should be
+  // unavailable.
+  if (!pref->GetBoolean(spellcheck::prefs::kSpellCheckEnable) ||
+      !pref->GetBoolean(spellcheck::prefs::kSpellCheckUseSpellingService) ||
+      context->IsOffTheRecord())
+    return false;
+
+  // If the locale for spelling has not been set, the user has not decided to
+  // use spellcheck so we don't do anything remote (suggest or spelling).
+  std::string locale;
+  pref->GetList(spellcheck::prefs::kSpellCheckDictionaries)
+      ->GetString(0, &locale);
+  if (locale.empty())
+    return false;
+
+  // Finally, if all options are available, we only enable only SUGGEST
+  // if SPELLCHECK is not available for our language because SPELLCHECK results
+  // are a superset of SUGGEST results.
+  for (const char* language : kValidLanguages) {
+    if (!locale.compare(0, 2, language))
+      return type == SPELLCHECK;
+  }
+
+  // Only SUGGEST is allowed.
+  return type == SUGGEST;
+}
+
+void SpellingServiceClient::SetURLLoaderFactoryForTesting(
+    scoped_refptr<network::SharedURLLoaderFactory>
+        url_loader_factory_for_testing) {
+  url_loader_factory_for_testing_ = std::move(url_loader_factory_for_testing);
+}
+
+GURL SpellingServiceClient::BuildEndpointUrl(int type) {
+    return GURL(base::StringPrintf(kSpellingServiceRestURL, type,
+                                   google_apis::GetAPIKey().c_str()));
+}
+
+bool SpellingServiceClient::ParseResponse(
+    const std::string& data,
+    std::vector<SpellCheckResult>* results) {
+  // Data is in the following format:
+  //  * spellingCheckResponse: A wrapper object containing the response
+  //    * mispellings: (optional Array<object>) A list of mistakes for the
+  //      requested text, with the following format:
+  //      * charStart: (number) The zero-based start of the misspelled region
+  //      * charLength: (number) The length of the misspelled region
+  //      * suggestions: (Array<object>) The suggestions for the misspelled
+  //        text, with the following format:
+  //        * suggestion: (string) the suggestion for the correct text
+  //      * canAutoCorrect (optional boolean) Whether we can use the first
+  //        suggestion for auto-correction
+  //
+  // Example response for "duck goes quisk":
+  //  {
+  //    "spellingCheckResponse": {
+  //      "misspellings": [{
+  //        "charStart": 10,
+  //        "charLength": 5,
+  //        "suggestions": [{
+  //          "suggestion": "quack"
+  //        }],
+  //        "canAutoCorrect": false
+  //      }]
+  //    }
+  //  }
+  //
+  // If the service is not available, the Spelling service returns JSON with an
+  // error:
+  //  {
+  //    "error": {
+  //      "code": 400,
+  //      "message": "Bad Request",
+  //      "data": [...]
+  //    }
+  //  }
+
+  std::unique_ptr<base::DictionaryValue> value(
+      static_cast<base::DictionaryValue*>(
+          base::JSONReader::ReadDeprecated(data,
+                                           base::JSON_ALLOW_TRAILING_COMMAS)
+              .release()));
+  if (!value || !value->is_dict())
+    return false;
+
+  // Check for errors from spelling service.
+  base::DictionaryValue* error = nullptr;
+  if (value->GetDictionary(kErrorPath, &error))
+    return false;
+
+  // Retrieve the array of Misspelling objects. When the input text does not
+  // have misspelled words, it returns an empty JSON. (In this case, its HTTP
+  // status is 200.) We just return true for this case.
+  base::ListValue* misspellings = nullptr;
+
+  if (!value->GetList(kMisspellingsRestPath, &misspellings))
+    return true;
+
+  for (size_t i = 0; i < misspellings->GetSize(); ++i) {
+    // Retrieve the i-th misspelling region and put it to the given vector. When
+    // the Spelling service sends two or more suggestions, we read only the
+    // first one because SpellCheckResult can store only one suggestion.
+    base::DictionaryValue* misspelling = nullptr;
+    if (!misspellings->GetDictionary(i, &misspelling))
+      return false;
+
+    int start = 0;
+    int length = 0;
+    base::ListValue* suggestions = nullptr;
+    if (!misspelling->GetInteger("charStart", &start) ||
+        !misspelling->GetInteger("charLength", &length) ||
+        !misspelling->GetList("suggestions", &suggestions)) {
+      return false;
+    }
+
+    base::DictionaryValue* suggestion = nullptr;
+    base::string16 replacement;
+    if (!suggestions->GetDictionary(0, &suggestion) ||
+        !suggestion->GetString("suggestion", &replacement)) {
+      return false;
+    }
+    SpellCheckResult result(SpellCheckResult::SPELLING, start, length,
+                            replacement);
+    results->push_back(result);
+  }
+  return true;
+}
+
+SpellingServiceClient::TextCheckCallbackData::TextCheckCallbackData(
+    std::unique_ptr<network::SimpleURLLoader> simple_url_loader,
+    TextCheckCompleteCallback callback,
+    base::string16 text)
+    : simple_url_loader(std::move(simple_url_loader)),
+      callback(std::move(callback)),
+      text(text) {}
+
+SpellingServiceClient::TextCheckCallbackData::~TextCheckCallbackData() {}
+
+void SpellingServiceClient::OnSimpleLoaderComplete(
+    SpellCheckLoaderList::iterator it,
+    base::TimeTicks request_start,
+    std::unique_ptr<std::string> response_body) {
+  UMA_HISTOGRAM_TIMES("SpellCheck.SpellingService.RequestDuration",
+                      base::TimeTicks::Now() - request_start);
+
+  TextCheckCompleteCallback callback = std::move(it->get()->callback);
+  base::string16 text = it->get()->text;
+  bool success = false;
+  std::vector<SpellCheckResult> results;
+  if (response_body)
+    success = ParseResponse(*response_body, &results);
+
+  int response_code = net::ERR_FAILED;
+  auto* resp_info = it->get()->simple_url_loader->ResponseInfo();
+  if (resp_info && resp_info->headers) {
+    response_code = resp_info->headers->response_code();
+  }
+
+  ServiceRequestResultType result_type =
+      ServiceRequestResultType::kRequestFailure;
+  if (success) {
+    result_type = results.empty()
+                      ? ServiceRequestResultType::kSuccessEmpty
+                      : ServiceRequestResultType::kSuccessWithSuggestions;
+  }
+
+  base::UmaHistogramSparse("SpellCheck.SpellingService.RequestHttpResponseCode",
+                           response_code);
+  UMA_HISTOGRAM_ENUMERATION("SpellCheck.SpellingService.RequestResultType",
+                            result_type);
+
+  spellcheck_loaders_.erase(it);
+  std::move(callback).Run(success, text, results);
+}
diff --git a/chrome/browser/startup_data.cc b/chrome/browser/startup_data.cc
index ba8b5a110c2b..6217f5c91593 100644
--- a/chrome/browser/startup_data.cc
+++ b/chrome/browser/startup_data.cc
@@ -87,12 +87,18 @@ void StartupData::RecordCoreSystemProfile() {
 
 #if defined(OS_ANDROID)
 void StartupData::CreateProfilePrefService() {
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 1";
   key_ = std::make_unique<ProfileKey>(GetProfilePath());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 2";
   PreProfilePrefServiceInit();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 3";
   CreateServicesInternal();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 4";
   key_->SetPrefs(prefs_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 5";
 
   ProfileKeyStartupAccessor::GetInstance()->SetProfileKey(key_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 6";
 }
 
 bool StartupData::HasBuiltProfilePrefService() {
@@ -138,12 +144,16 @@ StartupData::TakeProtoDatabaseProvider() {
 }
 
 void StartupData::PreProfilePrefServiceInit() {
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 1";
   pref_registry_ = base::MakeRefCounted<user_prefs::PrefRegistrySyncable>();
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 2";
   ChromeBrowserMainExtraPartsProfiles::
-      EnsureBrowserContextKeyedServiceFactoriesBuilt();
+      EnsureBrowserContextKeyedServiceFactoriesBuilt(false);
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 3";
 }
 
 void StartupData::CreateServicesInternal() {
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 1";
   const base::FilePath& path = key_->GetPath();
   if (!base::PathExists(path)) {
     // TODO(rogerta): http://crbug/160553 - Bad things happen if we can't
@@ -153,25 +163,32 @@ void StartupData::CreateServicesInternal() {
       return;
 
     CreateProfileReadme(path);
+    LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 2";
   }
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 3";
   scoped_refptr<base::SequencedTaskRunner> io_task_runner =
       base::CreateSequencedTaskRunner(
           {base::ThreadPool(), base::TaskShutdownBehavior::BLOCK_SHUTDOWN,
            base::MayBlock()});
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 4";
   policy::ChromeBrowserPolicyConnector* browser_policy_connector =
       chrome_feature_list_creator_->browser_policy_connector();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 5";
   std::unique_ptr<policy::SchemaRegistry> schema_registry =
       std::make_unique<policy::SchemaRegistry>();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 6";
   schema_registry_service_ = BuildSchemaRegistryService(
       std::move(schema_registry), browser_policy_connector->GetChromeSchema(),
       browser_policy_connector->GetSchemaRegistry());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 7";
 
   user_cloud_policy_manager_ = CreateUserCloudPolicyManager(
       path, schema_registry_service_->registry(),
       true /* force_immediate_policy_load */, io_task_runner);
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 8";
   profile_policy_connector_ = policy::CreateAndInitProfilePolicyConnector(
       schema_registry_service_->registry(),
       static_cast<policy::ChromeBrowserPolicyConnector*>(
@@ -179,26 +196,32 @@ void StartupData::CreateServicesInternal() {
       user_cloud_policy_manager_.get(),
       user_cloud_policy_manager_->core()->store(),
       true /* force_immediate_policy_load*/, nullptr /* user */);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 9";
 
   // StoragePartitionImplMap uses profile directory as default storage
   // partition, see StoragePartitionImplMap::GetStoragePartitionPath().
   proto_db_provider_ =
       std::make_unique<leveldb_proto::ProtoDatabaseProvider>(path);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 10";
   key_->SetProtoDatabaseProvider(proto_db_provider_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 11";
 
   RegisterProfilePrefs(false /* is_signin_profile */,
                        chrome_feature_list_creator_->actual_locale(),
                        pref_registry_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 12";
 
   mojo::PendingRemote<prefs::mojom::TrackedPreferenceValidationDelegate>
       pref_validation_delegate;
   // The preference tracking and protection is not required on Android.
   DCHECK(!ProfilePrefStoreManager::kPlatformSupportsPreferenceTracking);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 14";
 
   prefs_ = CreatePrefService(
       pref_registry_, nullptr /* extension_pref_store */,
       profile_policy_connector_->policy_service(), browser_policy_connector,
       std::move(pref_validation_delegate), io_task_runner, key_.get(), path,
       false /* async_prefs*/);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 15";
 }
 #endif
diff --git a/chrome/browser/supervised_user/supervised_user_service.cc b/chrome/browser/supervised_user/supervised_user_service.cc
index e778b7059361..a057785007bc 100644
--- a/chrome/browser/supervised_user/supervised_user_service.cc
+++ b/chrome/browser/supervised_user/supervised_user_service.cc
@@ -660,6 +660,8 @@ void SupervisedUserService::OnBlacklistLoaded() {
 }
 
 void SupervisedUserService::UpdateBlacklist() {
+  if (true)
+    return;
   bool use_blacklist = supervised_users::IsSafeSitesBlacklistEnabled(profile_);
   url_filter_.SetBlacklist(use_blacklist ? &blacklist_ : nullptr);
   for (SupervisedUserServiceObserver& observer : observer_list_)
diff --git a/chrome/browser/sync/profile_sync_service_factory.cc b/chrome/browser/sync/profile_sync_service_factory.cc
index bed5a18c962d..22dab3738847 100644
--- a/chrome/browser/sync/profile_sync_service_factory.cc
+++ b/chrome/browser/sync/profile_sync_service_factory.cc
@@ -136,47 +136,76 @@ ProfileSyncServiceFactory::ProfileSyncServiceFactory()
   // when it is shut down.  Specify those dependencies here to build the proper
   // destruction order. Note that some of the dependencies are listed here but
   // actually plumbed in ChromeSyncClient, which this factory constructs.
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 1";
   DependsOn(AboutSigninInternalsFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 2";
   DependsOn(AccountPasswordStoreFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 3";
   DependsOn(autofill::PersonalDataManagerFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 4";
   DependsOn(BookmarkModelFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 5";
   DependsOn(BookmarkSyncServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 6";
   DependsOn(BookmarkUndoServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 7";
   DependsOn(browser_sync::UserEventServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 8";
   DependsOn(ConsentAuditorFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 9";
   DependsOn(DeviceInfoSyncServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 10";
   DependsOn(FaviconServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 11";
   DependsOn(gcm::GCMProfileServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 12";
   DependsOn(HistoryServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 13";
   DependsOn(IdentityManagerFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 14";
   DependsOn(invalidation::DeprecatedProfileInvalidationProviderFactory::
                 GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 15";
   DependsOn(invalidation::ProfileInvalidationProviderFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 16";
   DependsOn(ModelTypeStoreServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 17";
   DependsOn(PasswordStoreFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 18";
   DependsOn(SecurityEventRecorderFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 19";
   DependsOn(SendTabToSelfSyncServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 20";
   DependsOn(SpellcheckServiceFactory::GetInstance());
-#if BUILDFLAG(ENABLE_SUPERVISED_USERS)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 21";
+#if false && BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SupervisedUserServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 22";
   DependsOn(SupervisedUserSettingsServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 23";
 #endif  // BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SessionSyncServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 24";
   DependsOn(TemplateURLServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 25";
 #if !defined(OS_ANDROID)
   DependsOn(ThemeServiceFactory::GetInstance());
 #endif  // !defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 26";
   DependsOn(WebDataServiceFactory::GetInstance());
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 27";
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
   DependsOn(extensions::StorageFrontend::GetFactoryInstance());
   DependsOn(web_app::WebAppProviderFactory::GetInstance());
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 28";
 #if defined(OS_CHROMEOS)
   DependsOn(chromeos::SyncedPrintersManagerFactory::GetInstance());
   DependsOn(WifiConfigurationSyncServiceFactory::GetInstance());
 #endif  // defined(OS_CHROMEOS)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 29";
 }
 
 ProfileSyncServiceFactory::~ProfileSyncServiceFactory() = default;
diff --git a/chrome/browser/touch_to_fill/android/BUILD.gn b/chrome/browser/touch_to_fill/android/BUILD.gn
index 2667e4002ac1..77ec077e2f16 100644
--- a/chrome/browser/touch_to_fill/android/BUILD.gn
+++ b/chrome/browser/touch_to_fill/android/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("//build/config/android/rules.gni")
 import("//chrome/android/features/android_library_factory_tmpl.gni")
+import("//third_party/protobuf/proto_library.gni")
 
 source_set("android") {
   visibility = [ "//chrome/browser/touch_to_fill:factory" ]
diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index 7932e2421de6..6b096a497bae 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -587,7 +587,7 @@ jumbo_static_library("ui") {
   allow_circular_includes_from +=
       [ "//chrome/browser/ui/webui/bluetooth_internals" ]
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
     deps += [ "//chrome/browser/ui/webui/discards:mojo_bindings" ]
   }
 
@@ -804,7 +804,9 @@ jumbo_static_library("ui") {
       "//services/device/public/mojom:usb",
       "//ui/android",
     ]
-  } else {
+  }
+  if (true)
+  {
     # !is_android
     sources += [
       "apps/app_info_dialog.h",
@@ -1016,6 +1018,8 @@ jumbo_static_library("ui") {
       "media_router/ui_media_sink.cc",
       "media_router/ui_media_sink.h",
       "native_window_tracker.h",
+      "native_window_tracker_android.cc",
+      "native_window_tracker_android.h",
       "omnibox/alternate_nav_infobar_delegate.cc",
       "omnibox/alternate_nav_infobar_delegate.h",
       "omnibox/chrome_omnibox_client.cc",
@@ -2049,7 +2053,7 @@ jumbo_static_library("ui") {
     }
   }
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (is_win || is_mac || is_desktop_linux || is_chromeos || true) {
     sources += [
       "autofill/payments/webauthn_dialog_controller.h",
       "autofill/payments/webauthn_dialog_controller_impl.cc",
@@ -2098,13 +2102,17 @@ jumbo_static_library("ui") {
     deps += [ "//ui/webui" ]
   }
 
-  if (is_win || is_mac || is_desktop_linux) {
+  if (is_win || is_mac || is_desktop_linux || is_android) {
     sources += [
       "avatar_button_error_controller.cc",
       "avatar_button_error_controller.h",
       "avatar_button_error_controller_delegate.h",
       "bookmarks/bookmark_bubble_sign_in_delegate.cc",
       "bookmarks/bookmark_bubble_sign_in_delegate.h",
+#      "signin_view_controller.cc",
+#      "signin_view_controller.h",
+#      "signin_view_controller_delegate.cc",
+#      "signin_view_controller_delegate.h",
       "startup/default_browser_infobar_delegate.cc",
       "startup/default_browser_infobar_delegate.h",
       "startup/default_browser_prompt.cc",
@@ -2114,8 +2122,6 @@ jumbo_static_library("ui") {
       "sync/one_click_signin_links_delegate_impl.h",
       "user_manager.cc",
       "user_manager.h",
-      "views/external_protocol_dialog.cc",
-      "views/external_protocol_dialog.h",
       "views/profiles/badged_profile_photo.cc",
       "views/profiles/badged_profile_photo.h",
       "views/profiles/profile_menu_view.cc",
@@ -2500,6 +2506,11 @@ jumbo_static_library("ui") {
     }
   }
 
+  sources += [
+    "views/chrome_views_delegate_android.cc",
+    "views/frame/native_browser_frame_factory_android.cc",
+  ]
+
   if (is_desktop_linux) {
     sources += [
       "views/apps/chrome_app_window_client_views_linux.cc",
@@ -2602,8 +2613,9 @@ jumbo_static_library("ui") {
       sources += [ "views/tabs/window_finder_ozone.cc" ]
     }
   }
+  sources += [ "views/tabs/window_finder_android.cc" ]
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     sources += [
       "autofill/payments/local_card_migration_bubble.h",
       "autofill/payments/local_card_migration_bubble_controller_impl.cc",
@@ -2667,10 +2679,6 @@ jumbo_static_library("ui") {
       "views/autofill/autofill_bubble_handler_impl.h",
       "views/autofill/autofill_popup_base_view.cc",
       "views/autofill/autofill_popup_base_view.h",
-      "views/autofill/autofill_popup_view_native_views.cc",
-      "views/autofill/autofill_popup_view_native_views.h",
-      "views/autofill/payments/card_unmask_prompt_views.cc",
-      "views/autofill/payments/card_unmask_prompt_views.h",
       "views/autofill/payments/dialog_view_ids.h",
       "views/autofill/payments/local_card_migration_bubble_views.cc",
       "views/autofill/payments/local_card_migration_bubble_views.h",
@@ -2776,6 +2784,7 @@ jumbo_static_library("ui") {
       "views/download/download_started_animation_views.cc",
       "views/dropdown_bar_host.cc",
       "views/dropdown_bar_host.h",
+      "views/dropdown_bar_host_android.cc",
       "views/dropdown_bar_host_delegate.h",
       "views/elevation_icon_setter.cc",
       "views/elevation_icon_setter.h",
@@ -2906,8 +2915,6 @@ jumbo_static_library("ui") {
       "views/importer/import_lock_dialog_view.h",
       "views/infobars/alternate_nav_infobar_view.cc",
       "views/infobars/alternate_nav_infobar_view.h",
-      "views/infobars/confirm_infobar.cc",
-      "views/infobars/confirm_infobar.h",
       "views/infobars/infobar_container_view.cc",
       "views/infobars/infobar_container_view.h",
       "views/infobars/infobar_view.cc",
@@ -2963,12 +2970,8 @@ jumbo_static_library("ui") {
       "views/media_router/cast_dialog_view.h",
       "views/media_router/cast_toolbar_button.cc",
       "views/media_router/cast_toolbar_button.h",
-      "views/media_router/cloud_services_dialog_view.cc",
-      "views/media_router/cloud_services_dialog_view.h",
       "views/media_router/media_remoting_dialog_view.cc",
       "views/media_router/media_remoting_dialog_view.h",
-      "views/media_router/media_router_dialog_controller_views.cc",
-      "views/media_router/media_router_dialog_controller_views.h",
       "views/media_router/media_router_views_ui.cc",
       "views/media_router/media_router_views_ui.h",
       "views/media_router/presentation_receiver_window_factory.cc",
@@ -3010,8 +3013,6 @@ jumbo_static_library("ui") {
       "views/overlay/back_to_tab_image_button.h",
       "views/overlay/close_image_button.cc",
       "views/overlay/close_image_button.h",
-      "views/overlay/overlay_window_views.cc",
-      "views/overlay/overlay_window_views.h",
       "views/overlay/playback_image_button.cc",
       "views/overlay/playback_image_button.h",
       "views/overlay/resize_handle_button.cc",
@@ -3042,8 +3043,6 @@ jumbo_static_library("ui") {
       "views/page_info/permission_selector_row.cc",
       "views/page_info/permission_selector_row.h",
       "views/page_info/permission_selector_row_observer.h",
-      "views/page_info/safety_tip_page_info_bubble_view.cc",
-      "views/page_info/safety_tip_page_info_bubble_view.h",
       "views/passwords/account_chooser_dialog_view.cc",
       "views/passwords/account_chooser_dialog_view.h",
       "views/passwords/auto_signin_first_run_dialog_view.cc",
@@ -3058,59 +3057,12 @@ jumbo_static_library("ui") {
       "views/passwords/password_auto_sign_in_view.h",
       "views/passwords/password_bubble_view_base.cc",
       "views/passwords/password_bubble_view_base.h",
-      "views/passwords/password_generation_popup_view_views.cc",
-      "views/passwords/password_generation_popup_view_views.h",
       "views/passwords/password_items_view.cc",
       "views/passwords/password_items_view.h",
       "views/passwords/password_pending_view.cc",
       "views/passwords/password_pending_view.h",
       "views/passwords/password_save_confirmation_view.cc",
       "views/passwords/password_save_confirmation_view.h",
-      "views/payments/contact_info_editor_view_controller.cc",
-      "views/payments/contact_info_editor_view_controller.h",
-      "views/payments/credit_card_editor_view_controller.cc",
-      "views/payments/credit_card_editor_view_controller.h",
-      "views/payments/cvc_unmask_view_controller.cc",
-      "views/payments/cvc_unmask_view_controller.h",
-      "views/payments/editor_view_controller.cc",
-      "views/payments/editor_view_controller.h",
-      "views/payments/error_message_view_controller.cc",
-      "views/payments/error_message_view_controller.h",
-      "views/payments/order_summary_view_controller.cc",
-      "views/payments/order_summary_view_controller.h",
-      "views/payments/payment_handler_modal_dialog_manager_delegate.cc",
-      "views/payments/payment_handler_modal_dialog_manager_delegate.h",
-      "views/payments/payment_handler_web_flow_view_controller.cc",
-      "views/payments/payment_handler_web_flow_view_controller.h",
-      "views/payments/payment_method_view_controller.cc",
-      "views/payments/payment_method_view_controller.h",
-      "views/payments/payment_request_dialog_view.cc",
-      "views/payments/payment_request_dialog_view.h",
-      "views/payments/payment_request_dialog_view_ids.h",
-      "views/payments/payment_request_item_list.cc",
-      "views/payments/payment_request_item_list.h",
-      "views/payments/payment_request_row_view.cc",
-      "views/payments/payment_request_row_view.h",
-      "views/payments/payment_request_sheet_controller.cc",
-      "views/payments/payment_request_sheet_controller.h",
-      "views/payments/payment_request_views_util.cc",
-      "views/payments/payment_request_views_util.h",
-      "views/payments/payment_sheet_view_controller.cc",
-      "views/payments/payment_sheet_view_controller.h",
-      "views/payments/profile_list_view_controller.cc",
-      "views/payments/profile_list_view_controller.h",
-      "views/payments/shipping_address_editor_view_controller.cc",
-      "views/payments/shipping_address_editor_view_controller.h",
-      "views/payments/shipping_option_view_controller.cc",
-      "views/payments/shipping_option_view_controller.h",
-      "views/payments/validating_combobox.cc",
-      "views/payments/validating_combobox.h",
-      "views/payments/validating_textfield.cc",
-      "views/payments/validating_textfield.h",
-      "views/payments/validation_delegate.cc",
-      "views/payments/validation_delegate.h",
-      "views/payments/view_stack.cc",
-      "views/payments/view_stack.h",
       "views/permission_bubble/chooser_bubble_ui.cc",
       "views/permission_bubble/chooser_bubble_ui.h",
       "views/permission_bubble/chooser_bubble_ui_views.cc",
@@ -3154,8 +3106,6 @@ jumbo_static_library("ui") {
       "views/sharing/sharing_dialog_view.h",
       "views/sharing/sharing_icon_view.cc",
       "views/sharing/sharing_icon_view.h",
-      "views/simple_message_box_views.cc",
-      "views/simple_message_box_views.h",
       "views/status_bubble_views.cc",
       "views/status_bubble_views.h",
       "views/subtle_notification_view.cc",
@@ -3369,8 +3319,6 @@ jumbo_static_library("ui") {
       sources += [
         "views/create_application_shortcut_view.cc",
         "views/create_application_shortcut_view.h",
-        "views/ssl_client_certificate_selector.cc",
-        "views/ssl_client_certificate_selector.h",
       ]
     }
 
@@ -3458,6 +3406,14 @@ jumbo_static_library("ui") {
     }
   }
 
+  sources += [
+      "views/accelerator_utils_android.cc",
+      "window_sizer/window_sizer_android.cc",
+      "views/frame/browser_non_client_frame_view_factory_views.cc",
+      "views/frame/desktop_browser_frame_android.cc",
+      "views/frame/desktop_browser_frame_android.h",
+  ]
+
   if (use_aura) {
     sources += [
       "aura/accessibility/automation_manager_aura.cc",
@@ -3957,7 +3913,7 @@ jumbo_static_library("ui") {
       "//components/printing/browser",
       "//printing",
     ]
-    if (!is_chromeos && !is_android) {
+    if (true || !is_chromeos && !is_android) {
       sources += [
         "webui/settings/printing_handler.cc",
         "webui/settings/printing_handler.h",
diff --git a/chrome/browser/ui/android/appmenu/internal/BUILD.gn b/chrome/browser/ui/android/appmenu/internal/BUILD.gn
index 04b1999e6526..cf6808edb0d8 100644
--- a/chrome/browser/ui/android/appmenu/internal/BUILD.gn
+++ b/chrome/browser/ui/android/appmenu/internal/BUILD.gn
@@ -19,6 +19,20 @@ android_library("java") {
   deps = [
     ":java_resources",
     "//base:base_java",
+    "//base:jni_java",
+    ":jni_headers",
+    "//chrome/browser/ui/android/appmenu:java_resources",
+    "//chrome/browser/ui/android/strings:ui_strings_grd",
+    "//chrome/browser/ui/android/styles:java_resources",
+    "//chrome/browser/ui/android/widget:ui_widget_java_resources",
+    "//chrome/android:chrome_java",
+    "//content/public/android:content_java",
+    "//chrome/android:ui_locale_string_resources",
+    "//chrome/android/features/start_surface/internal:java",
+    "//chrome/android/public/profiles:java",
+    "//chrome/browser/ui/android/strings:ui_strings_grd",
+    "//chrome/browser/ui/android/styles:java",
+    "//chrome/browser/ui/android/widget:java",
     "//chrome/browser/ui/android/appmenu:java",
     "//chrome/browser/ui/android/appmenu:java_resources",
     "//chrome/browser/ui/android/widget:java",
@@ -27,6 +41,15 @@ android_library("java") {
     "//third_party/android_deps:androidx_annotation_annotation_java",
     "//ui/android:ui_java",
   ]
+
+}
+
+generate_jni("jni_headers") {
+  sources = [
+    "java/src/org/chromium/chrome/browser/ui/appmenu/AppMenu.java",
+#    "java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuDragHelper.java"
+  ]
+
 }
 
 android_resources("java_resources") {
diff --git a/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenu.java b/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenu.java
index 9cd2173848f3..8fd0b65f3366 100644
--- a/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenu.java
+++ b/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenu.java
@@ -7,10 +7,17 @@ package org.chromium.chrome.browser.ui.appmenu;
 import android.animation.Animator;
 import android.animation.Animator.AnimatorListener;
 import android.animation.AnimatorSet;
+import android.app.Activity;
 import android.content.Context;
 import android.content.res.Resources;
+import android.util.Log;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.BitmapFactory;
+import android.graphics.Color;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+import android.graphics.ColorMatrixColorFilter;
 import android.os.Build;
 import android.text.TextUtils;
 import android.view.Gravity;
@@ -18,6 +25,7 @@ import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.Menu;
 import android.view.MenuItem;
+import android.view.MenuItem.OnMenuItemClickListener;
 import android.view.Surface;
 import android.view.View;
 import android.view.View.MeasureSpec;
@@ -26,24 +34,47 @@ import android.view.ViewGroup;
 import android.view.ViewStub;
 import android.view.WindowManager;
 import android.widget.AdapterView;
+import android.widget.AdapterView.AdapterContextMenuInfo;
 import android.widget.AdapterView.OnItemClickListener;
 import android.widget.ImageButton;
 import android.widget.ListView;
 import android.widget.PopupWindow;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View.OnTouchListener;
+import android.util.Base64;
+import android.util.Base64InputStream;
+import android.support.v7.view.menu.MenuBuilder;
+import android.widget.AdapterView;
 
+import org.chromium.content_public.browser.LoadUrlParams;
+import org.chromium.ui.base.PageTransition;
+import org.chromium.chrome.browser.tabmodel.TabLaunchType;
+import org.chromium.chrome.browser.ChromeActivity;
+import org.chromium.ui.mojom.WindowOpenDisposition;
+import org.chromium.base.ContextUtils;
 import androidx.annotation.IdRes;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
+import org.chromium.chrome.browser.tabmodel.TabModelSelector;
 
 import org.chromium.base.AnimationFrameTimeHistogram;
 import org.chromium.base.ApiCompatibilityUtils;
 import org.chromium.base.ContextUtils;
 import org.chromium.base.SysUtils;
+import org.chromium.chrome.browser.tab.Tab;
 import org.chromium.chrome.browser.ui.appmenu.internal.R;
 import org.chromium.chrome.browser.ui.widget.highlight.ViewHighlighter;
 import org.chromium.ui.widget.Toast;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.content_public.browser.WebContents;
+
+import org.chromium.base.ThreadUtils;
+import org.chromium.base.annotations.CalledByNative;
 
 import java.util.ArrayList;
+import java.util.Hashtable;
 import java.util.List;
 
 /**
@@ -63,6 +94,9 @@ class AppMenu implements OnItemClickListener, OnKeyListener, AppMenuAdapter.OnCl
     private final int mNegativeVerticalOffsetNotTopAnchored;
     private final int[] mTempLocation;
 
+    private Hashtable<Integer, String> extensionsIds;
+    private Hashtable<Integer, String> extensionsPopups;
+    private Activity mActivity;
     private PopupWindow mPopup;
     private ListView mListView;
     private AppMenuAdapter mAdapter;
@@ -168,7 +202,7 @@ class AppMenu implements OnItemClickListener, OnKeyListener, AppMenuAdapter.OnCl
      * @param showFromBottom        Whether the appearance animation should run from the bottom up.
      * @param customViewBinders     See {@link AppMenuPropertiesDelegate#getCustomViewBinders()}.
      */
-    void show(Context context, final View anchorView, boolean isByPermanentButton,
+    void show(Activity activity, Context context, final View anchorView, boolean isByPermanentButton,
             int screenRotation, Rect visibleDisplayFrame, int screenHeight,
             @IdRes int footerResourceId, @IdRes int headerResourceId, Integer highlightedItemId,
             boolean circleHighlightItem, boolean showFromBottom,
@@ -229,12 +263,71 @@ class AppMenu implements OnItemClickListener, OnKeyListener, AppMenuAdapter.OnCl
 
         // Extract visible items from the Menu.
         int numItems = mMenu.size();
+        int numItemsBase = mMenu.size();
         List<MenuItem> menuItems = new ArrayList<MenuItem>();
-        for (int i = 0; i < numItems; ++i) {
-            MenuItem item = mMenu.getItem(i);
-            if (item.isVisible()) {
+        // Show all menuitems first, then extensions
+        if (!ContextUtils.getAppSharedPreferences().getBoolean("show_extensions_first", false)) {
+          for (int i = 0; i < numItems; ++i) {
+              MenuItem item = mMenu.getItem(i);
+              if (item.isVisible()) {
+                  menuItems.add(item);
+              }
+          }
+        } else { // Show one menuitem, then extensions, then all other menuitems
+          for (int i = 0; i < numItems && i < 1; ++i) {
+              MenuItem item = mMenu.getItem(i);
+              if (item.isVisible()) {
+                  menuItems.add(item);
+              }
+          }
+        }
+        WebContents webContents = null;
+        mActivity = activity;
+        boolean canShowExtensions = false;
+        if (activity instanceof ChromeActivity) {
+          Tab currentTab = ((ChromeActivity)activity).getActivityTab();
+          if (currentTab != null)
+            canShowExtensions = true;
+          webContents = currentTab != null ? currentTab.getWebContents() : null;
+        }
+
+        extensionsIds = new Hashtable<Integer, String>();
+        extensionsPopups = new Hashtable<Integer, String>();
+
+        if (canShowExtensions) {
+          int itemIndex = numItems++;
+          String extensions = nativeGetRunningExtensions(getProfile(), webContents);
+          if (!extensions.isEmpty()) {
+            String[] extensionsArray = extensions.split("\u001f");
+            for (String extension: extensionsArray) {
+                String[] extensionsInfo = extension.split("\u001e");
+                Menu fakeMenu = new MenuBuilder(activity);
+                MenuItem item = fakeMenu.add(999999, itemIndex, 0, extensionsInfo[0]);
+                if (extensionsInfo.length > 1) {
+                  extensionsIds.put(itemIndex, extensionsInfo[1]);
+                }
+                if (extensionsInfo.length > 2 && !extensionsInfo[2].equals("")) {
+                  extensionsPopups.put(itemIndex, extensionsInfo[2]);
+                }
+                if (extensionsInfo.length > 3) {
+                  String cleanImage = extensionsInfo[3].replace("data:image/png;base64,", "").replace("data:image/jpeg;base64,","").replace("data:image/gif;base64,", "");
+                  byte[] decodedString = Base64.decode(cleanImage, Base64.DEFAULT);
+                  Bitmap decodedByte = BitmapFactory.decodeByteArray(decodedString, 0, decodedString.length);
+                  item.setIcon(new BitmapDrawable(context.getResources(), decodedByte));
+                }
                 menuItems.add(item);
+                itemIndex++;
             }
+          }
+        }
+
+        if (ContextUtils.getAppSharedPreferences().getBoolean("show_extensions_first", false)) {
+          for (int i = 1; i < numItemsBase; ++i) {
+              MenuItem item = mMenu.getItem(i);
+              if (item.isVisible()) {
+                  menuItems.add(item);
+              }
+          }
         }
 
         Rect sizingPadding = new Rect(bgPadding);
@@ -355,12 +448,47 @@ class AppMenu implements OnItemClickListener, OnKeyListener, AppMenuAdapter.OnCl
 
         int xPos = anchorViewX + offsets[0];
         int yPos = anchorViewY + offsets[1];
+        if (ContextUtils.getAppSharedPreferences().getBoolean("enable_bottom_toolbar", false)) {
+           yPos = appRect.height() - popupHeight;
+           if (yPos <= 0)
+               yPos = 0;
+        }
         int[] position = {xPos, yPos};
         return position;
     }
 
     @Override
     public void onItemClick(MenuItem menuItem) {
+        Log.i("Kiwi", "[EXTENSIONS] Item was clicked in the main menu: " + menuItem.getGroupId());
+        if (menuItem.getGroupId() == 999999 && extensionsPopups.containsKey(menuItem.getItemId())) {
+          Log.e("EXTENSIONS", "[EXTENSIONS] MenuItem clicked (popup)");
+          if (mActivity != null && mActivity instanceof ChromeActivity) {
+            Log.e("EXTENSIONS", "[EXTENSIONS] MenuItem clicked - Activity is not empty, opening tab - Step 1: " + extensionsPopups.get(menuItem.getItemId()));
+            WebContents webContents = null;
+            Tab currentTab = ((ChromeActivity)mActivity).getActivityTab();
+            if (currentTab != null) {
+              webContents = currentTab != null ? currentTab.getWebContents() : null;
+              nativeGrantExtensionActiveTab(getProfile(), webContents, extensionsIds.get(menuItem.getItemId()));
+              TabModelSelector.from(currentTab).openNewTab(new LoadUrlParams(extensionsPopups.get(menuItem.getItemId()), PageTransition.LINK), TabLaunchType.FROM_CHROME_UI, currentTab, currentTab.isIncognito());
+            }
+            Log.e("EXTENSIONS", "[EXTENSIONS] MenuItem clicked - Activity is not empty, opening tab - Step 2: " + extensionsPopups.get(menuItem.getItemId()));
+          } else {
+            Log.e("EXTENSIONS", "[EXTENSIONS] MenuItem clicked but no activity");
+          }
+        }
+        else if (menuItem.getGroupId() == 999999 && extensionsIds.containsKey(menuItem.getItemId())) {
+          Log.e("EXTENSIONS", "[EXTENSIONS] MenuItem clicked");
+          if (mActivity != null && mActivity instanceof ChromeActivity) {
+            Log.e("EXTENSIONS", "[EXTENSIONS] MenuItem clicked - Activity is not empty, opening tab - Step 1: " + extensionsIds.get(menuItem.getItemId()));
+            WebContents webContents = null;
+            Tab currentTab = ((ChromeActivity)mActivity).getActivityTab();
+            webContents = currentTab != null ? currentTab.getWebContents() : null;
+            nativeCallExtension(getProfile(), webContents, extensionsIds.get(menuItem.getItemId()));
+            Log.e("EXTENSIONS", "[EXTENSIONS] MenuItem clicked - Activity is not empty, opening tab - Step 2: " + extensionsIds.get(menuItem.getItemId()));
+          } else {
+            Log.e("EXTENSIONS", "[EXTENSIONS] MenuItem clicked but no activity");
+          }
+        }
         if (menuItem.isEnabled()) {
             dismiss();
             mHandler.onOptionsItemSelected(menuItem);
@@ -503,6 +631,10 @@ class AppMenu implements OnItemClickListener, OnKeyListener, AppMenuAdapter.OnCl
         ViewGroup list = mListView;
         for (int i = 0; i < list.getChildCount(); i++) {
             View view = list.getChildAt(i);
+            MenuItem item = mAdapter.getItem(i);
+            int viewCount = item.hasSubMenu() ? item.getSubMenu().size() : 1;
+            if (viewCount != 5)
+              continue;
             Object animatorObject = view.getTag(R.id.menu_item_enter_anim_id);
             if (animatorObject != null) {
                 if (builder == null) {
@@ -533,6 +665,8 @@ class AppMenu implements OnItemClickListener, OnKeyListener, AppMenuAdapter.OnCl
 
         if (mHandler != null) mHandler.onFooterViewInflated(mFooterView);
 
+        if (mHandler != null) mHandler.onFooterInflated(mFooterView);
+
         return mFooterView.getMeasuredHeight();
     }
 
@@ -556,4 +690,16 @@ class AppMenu implements OnItemClickListener, OnKeyListener, AppMenuAdapter.OnCl
     void finishAnimationsForTests() {
         if (mMenuItemEnterAnimator != null) mMenuItemEnterAnimator.end();
     }
+
+    /**
+     * @returns The profile on which all UI-based browsing data operations should be performed,
+     *         which is the currently active regular profile.
+     */
+    private static Profile getProfile() {
+        return Profile.getLastUsedProfile().getOriginalProfile();
+    }
+
+    public static native String nativeGetRunningExtensions(Profile profile, WebContents webContents);
+    private static native void nativeCallExtension(Profile profile, WebContents webContents, String extensionId);
+    private static native void nativeGrantExtensionActiveTab(Profile profile, WebContents webContents, String extensionId);
 }
diff --git a/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuCoordinatorImpl.java b/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuCoordinatorImpl.java
index 50d32ed993f4..bfb4f9b1b6a3 100644
--- a/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuCoordinatorImpl.java
+++ b/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuCoordinatorImpl.java
@@ -4,6 +4,7 @@
 
 package org.chromium.chrome.browser.ui.appmenu;
 
+import android.app.Activity;
 import android.content.Context;
 import android.view.View;
 import android.view.ViewConfiguration;
@@ -65,7 +66,11 @@ class AppMenuCoordinatorImpl implements AppMenuCoordinator {
         mAppMenuDelegate = appMenuDelegate;
         mAppMenuPropertiesDelegate = mAppMenuDelegate.createAppMenuPropertiesDelegate();
 
-        mAppMenuHandler = new AppMenuHandlerImpl(mAppMenuPropertiesDelegate, mAppMenuDelegate,
+        Activity activity = null;
+        if (mContext instanceof Activity) {
+            activity = (Activity) mContext;
+        }
+        mAppMenuHandler = new AppMenuHandlerImpl(activity, mAppMenuPropertiesDelegate, mAppMenuDelegate,
                 mAppMenuPropertiesDelegate.getAppMenuLayoutId(), decorView,
                 activityLifecycleDispatcher, hardwareButtonAnchorView);
     }
diff --git a/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuHandlerImpl.java b/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuHandlerImpl.java
index 9bd681ed7084..dda1e1b9e62f 100644
--- a/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuHandlerImpl.java
+++ b/chrome/browser/ui/android/appmenu/internal/java/src/org/chromium/chrome/browser/ui/appmenu/AppMenuHandlerImpl.java
@@ -5,6 +5,7 @@
 package org.chromium.chrome.browser.ui.appmenu;
 
 import android.annotation.SuppressLint;
+import android.app.Activity;
 import android.content.Context;
 import android.content.res.Configuration;
 import android.content.res.TypedArray;
@@ -49,6 +50,7 @@ class AppMenuHandlerImpl
     private final AppMenuDelegate mAppMenuDelegate;
     private final View mDecorView;
     private final ActivityLifecycleDispatcher mActivityLifecycleDispatcher;
+    private final Activity mActivity;
 
     private Callback<MenuItem> mTestOptionsItemSelectedListener;
 
@@ -77,10 +79,11 @@ class AppMenuHandlerImpl
      * @param hardwareButtonAnchorView The {@link View} used as an anchor for the menu when it is
      *            displayed using a hardware button.
      */
-    public AppMenuHandlerImpl(AppMenuPropertiesDelegate delegate, AppMenuDelegate appMenuDelegate,
+    public AppMenuHandlerImpl(Activity activity, AppMenuPropertiesDelegate delegate, AppMenuDelegate appMenuDelegate,
             int menuResourceId, View decorView,
             ActivityLifecycleDispatcher activityLifecycleDispatcher,
             View hardwareButtonAnchorView) {
+        mActivity = activity;
         mAppMenuDelegate = appMenuDelegate;
         mDelegate = delegate;
         mDecorView = decorView;
@@ -212,7 +215,7 @@ class AppMenuHandlerImpl
         if (mDelegate.shouldShowHeader(appRect.height())) {
             headerResourceId = mDelegate.getHeaderResourceId();
         }
-        mAppMenu.show(wrapper, anchorView, isByPermanentButton, rotation, appRect, pt.y,
+        mAppMenu.show(mActivity, wrapper, anchorView, isByPermanentButton, rotation, appRect, pt.y,
                 footerResourceId, headerResourceId, mHighlightMenuId, mCircleHighlight,
                 showFromBottom, mDelegate.getCustomViewBinders());
         mAppMenuDragHelper.onShow(startDragging);
@@ -302,6 +305,14 @@ class AppMenuHandlerImpl
         }
     }
 
+    /**
+     * A notification that the footer view has been inflated.
+     * @param view The inflated view.
+     */
+    void onFooterInflated(View view) {
+        if (mDelegate != null) mDelegate.onFooterViewInflated(this, view);
+    }
+
     /**
      * A notification that the header view has been inflated.
      * @param view The inflated view.
diff --git a/chrome/browser/ui/android/tab_model/tab_model.h b/chrome/browser/ui/android/tab_model/tab_model.h
index 3b1db32af03a..a3b57d235410 100644
--- a/chrome/browser/ui/android/tab_model/tab_model.h
+++ b/chrome/browser/ui/android/tab_model/tab_model.h
@@ -113,6 +113,7 @@ class TabModel {
 
   virtual int GetTabCount() const = 0;
   virtual int GetActiveIndex() const = 0;
+  virtual int GetLastNonExtensionActiveIndex() const = 0;
   virtual content::WebContents* GetActiveWebContents() const;
   virtual content::WebContents* GetWebContentsAt(int index) const = 0;
   // This will return NULL if the tab has not yet been initialized.
diff --git a/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.cc b/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.cc
index 7c8d15e4cf81..2ca3b529b595 100644
--- a/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.cc
+++ b/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.cc
@@ -87,6 +87,11 @@ int TabModelJniBridge::GetActiveIndex() const {
   return Java_TabModelJniBridge_index(env, java_object_.get(env));
 }
 
+int TabModelJniBridge::GetLastNonExtensionActiveIndex() const {
+  JNIEnv* env = AttachCurrentThread();
+  return Java_TabModelJniBridge_getLastNonExtensionActiveIndex(env, java_object_.get(env));
+}
+
 void TabModelJniBridge::CreateTab(TabAndroid* parent,
                                   WebContents* web_contents) {
   JNIEnv* env = AttachCurrentThread();
diff --git a/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.h b/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.h
index d8b0980da0a1..01547d77c730 100644
--- a/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.h
+++ b/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.h
@@ -45,6 +45,7 @@ class TabModelJniBridge : public TabModel {
   // TabModel::
   int GetTabCount() const override;
   int GetActiveIndex() const override;
+  int GetLastNonExtensionActiveIndex() const override;
   content::WebContents* GetWebContentsAt(int index) const override;
   TabAndroid* GetTabAt(int index) const override;
 
diff --git a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
index ed43c8eff770..48c291866e75 100644
--- a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
@@ -63,7 +63,7 @@ std::vector<GURL> GetURLsToOpen(
   return urls;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool ShouldOpenAll(gfx::NativeWindow parent,
                    const std::vector<const BookmarkNode*>& nodes) {
   size_t child_count = GetURLsToOpen(nodes).size();
@@ -89,7 +89,7 @@ int ChildURLCountTotal(const BookmarkNode* node) {
                          count_children);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Returns in |urls|, the url and title pairs for each open tab in browser.
 void GetURLsForOpenTabs(Browser* browser,
                         std::vector<std::pair<GURL, base::string16>>* urls) {
@@ -104,7 +104,7 @@ void GetURLsForOpenTabs(Browser* browser,
 
 }  // namespace
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OpenAll(gfx::NativeWindow parent,
              content::PageNavigator* navigator,
              const std::vector<const BookmarkNode*>& nodes,
@@ -188,9 +188,6 @@ void ShowBookmarkAllTabsDialog(Browser* browser) {
       BookmarkEditor::EditDetails::AddFolder(parent, parent->children().size());
   GetURLsForOpenTabs(browser, &(details.urls));
   DCHECK(!details.urls.empty());
-
-  BookmarkEditor::Show(browser->window()->GetNativeWindow(), profile, details,
-                       BookmarkEditor::SHOW_TREE);
 }
 
 bool HasBookmarkURLs(const std::vector<const BookmarkNode*>& selection) {
diff --git a/chrome/browser/ui/browser.cc b/chrome/browser/ui/browser.cc
index d262a424f49b..c28d26c1d338 100644
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -280,6 +280,7 @@ const int kUIUpdateCoalescingTimeMS = 200;
 
 BrowserWindow* CreateBrowserWindow(std::unique_ptr<Browser> browser,
                                    bool user_gesture) {
+  LOG(ERROR) << "[Kiwi] BrowserWindow* CreateBrowserWindow";
   return BrowserWindow::CreateBrowserWindow(std::move(browser), user_gesture);
 }
 
@@ -1314,7 +1315,8 @@ bool Browser::ShouldAllowRunningInsecureContent(
   if (allowed_per_prefs)
     return true;
 
-  if (base::FeatureList::IsEnabled(features::kMixedContentSiteSetting)) {
+//  if (base::FeatureList::IsEnabled(features::kMixedContentSiteSetting)) {
+  if (0) {
     Profile* profile =
         Profile::FromBrowserContext(web_contents->GetBrowserContext());
     HostContentSettingsMap* content_settings =
@@ -1946,6 +1948,7 @@ void Browser::RequestPpapiBrokerPermission(
     return;
   }
 
+#if 0
   TabSpecificContentSettings* tab_content_settings =
       TabSpecificContentSettings::FromWebContents(web_contents);
 
@@ -1977,7 +1980,8 @@ void Browser::RequestPpapiBrokerPermission(
                          ? base::UserMetricsAction("PPAPI.BrokerSettingAllow")
                          : base::UserMetricsAction("PPAPI.BrokerSettingDeny"));
   tab_content_settings->SetPepperBrokerAllowed(allowed);
-  std::move(callback).Run(allowed);
+#endif
+  std::move(callback).Run(false);
   return;
 }
 
@@ -2587,6 +2591,7 @@ void Browser::SetAsDelegate(WebContents* web_contents, bool set_delegate) {
   web_contents->SetDelegate(delegate);
 
   // ...and all the helpers.
+#if 0
   WebContentsModalDialogManager::FromWebContents(web_contents)
       ->SetDelegate(delegate);
   translate::ContentTranslateDriver* content_translate_driver =
@@ -2600,6 +2605,7 @@ void Browser::SetAsDelegate(WebContents* web_contents, bool set_delegate) {
     content_translate_driver->RemoveObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->RemoveObserver(this);
   }
+#endif
 }
 
 void Browser::CloseFrame() {
diff --git a/chrome/browser/ui/browser.h b/chrome/browser/ui/browser.h
index 73a31f7274ac..4b4eb4199fa8 100644
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -55,9 +55,11 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
+#if 0
 #if defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
+#endif
 
 class BackgroundContents;
 class BrowserContentSettingBubbleModelDelegate;
diff --git a/chrome/browser/ui/browser_command_controller.cc b/chrome/browser/ui/browser_command_controller.cc
index 8991faab0782..6fb6726aa91a 100644
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -645,19 +645,15 @@ bool BrowserCommandController::ExecuteCommandWithDisposition(
                                               false /* force_shortcut_app */);
       break;
     case IDC_DEV_TOOLS:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Show());
       break;
     case IDC_DEV_TOOLS_CONSOLE:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::ShowConsolePanel());
       break;
     case IDC_DEV_TOOLS_DEVICES:
       InspectUI::InspectDevices(browser_);
       break;
     case IDC_DEV_TOOLS_INSPECT:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Inspect());
       break;
     case IDC_DEV_TOOLS_TOGGLE:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Toggle());
       break;
     case IDC_TASK_MANAGER:
       OpenTaskManager(browser_);
diff --git a/chrome/browser/ui/browser_commands.cc b/chrome/browser/ui/browser_commands.cc
index c4cc789e6a83..298295e21ede 100644
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -1235,7 +1235,6 @@ void ToggleDevToolsWindow(Browser* browser, DevToolsToggleAction action) {
     base::RecordAction(UserMetricsAction("DevTools_ToggleConsole"));
   else
     base::RecordAction(UserMetricsAction("DevTools_ToggleWindow"));
-  DevToolsWindow::ToggleDevToolsWindow(browser, action);
 }
 
 bool CanOpenTaskManager() {
diff --git a/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc b/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
index 9643d436d7d8..a84c1fab5bf7 100644
--- a/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
+++ b/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
@@ -49,7 +49,7 @@ void BrowserContentSettingBubbleModelDelegate::ShowLearnMorePage(
   GURL learn_more_url;
   switch (type) {
     case ContentSettingsType::PLUGINS:
-      learn_more_url = GURL(chrome::kBlockedPluginLearnMoreURL);
+      learn_more_url = GURL("https://www.kiwibrowser.com/");
       break;
     case ContentSettingsType::ADS:
       learn_more_url = GURL(subresource_filter::kLearnMoreLink);
diff --git a/chrome/browser/ui/browser_instant_controller.h b/chrome/browser/ui/browser_instant_controller.h
index 4d105455ff24..e97cb9d82162 100644
--- a/chrome/browser/ui/browser_instant_controller.h
+++ b/chrome/browser/ui/browser_instant_controller.h
@@ -13,10 +13,6 @@
 #include "chrome/browser/search/search_engine_base_url_tracker.h"
 #include "chrome/browser/ui/search/instant_controller.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class Browser;
 class Profile;
 
diff --git a/chrome/browser/ui/browser_list.cc b/chrome/browser/ui/browser_list.cc
index 781607118c13..6a9ca0f060e6 100644
--- a/chrome/browser/ui/browser_list.cc
+++ b/chrome/browser/ui/browser_list.cc
@@ -129,13 +129,14 @@ void BrowserList::RemoveBrowser(Browser* browser) {
     // shutdown, because Browser::WindowClosing() already makes sure that the
     // SessionService is created and notified.
     browser_shutdown::NotifyAppTerminating();
-    chrome::OnAppExiting();
   }
 }
 
 // static
 void BrowserList::AddObserver(BrowserListObserver* observer) {
+  LOG(ERROR) << "[Kiwi] BrowserList::AddObserver - Step 1";
   observers_.Get().AddObserver(observer);
+  LOG(ERROR) << "[Kiwi] BrowserList::AddObserver - Step 2";
 }
 
 // static
diff --git a/chrome/browser/ui/browser_navigator_params.cc b/chrome/browser/ui/browser_navigator_params.cc
index 2b5a3bf75d22..be0ef232eb1a 100644
--- a/chrome/browser/ui/browser_navigator_params.cc
+++ b/chrome/browser/ui/browser_navigator_params.cc
@@ -13,7 +13,7 @@
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/web_contents.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -24,7 +24,7 @@ using content::WebContents;
 #if defined(OS_ANDROID)
 NavigateParams::NavigateParams(std::unique_ptr<WebContents> contents_to_insert)
     : contents_to_insert(std::move(contents_to_insert)) {}
-#else
+
 NavigateParams::NavigateParams(Browser* a_browser,
                                const GURL& a_url,
                                ui::PageTransition a_transition)
diff --git a/chrome/browser/ui/browser_navigator_params.h b/chrome/browser/ui/browser_navigator_params.h
index d3acc5cb0aeb..1c92ffd0d083 100644
--- a/chrome/browser/ui/browser_navigator_params.h
+++ b/chrome/browser/ui/browser_navigator_params.h
@@ -25,7 +25,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/tabs/tab_group_id.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
 #endif
@@ -66,7 +66,7 @@ struct NavigateParams {
 #if defined(OS_ANDROID)
   explicit NavigateParams(
       std::unique_ptr<content::WebContents> contents_to_insert);
-#else
+
   NavigateParams(Browser* browser,
                  const GURL& a_url,
                  ui::PageTransition a_transition);
@@ -211,7 +211,7 @@ struct NavigateParams {
   };
   PathBehavior path_behavior = RESPECT;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // [in]  Specifies a Browser object where the navigation could occur or the
   //       tab could be added. Navigate() is not obliged to use this Browser if
   //       it is not compatible with the operation being performed. This can be
diff --git a/chrome/browser/ui/browser_otr_state.cc b/chrome/browser/ui/browser_otr_state.cc
index 4c79c00b25a3..233af8247614 100644
--- a/chrome/browser/ui/browser_otr_state.cc
+++ b/chrome/browser/ui/browser_otr_state.cc
@@ -8,8 +8,4 @@
 
 namespace chrome {
 
-bool IsIncognitoSessionActive() {
-  return BrowserList::IsIncognitoSessionActive();
-}
-
 }  // namespace chrome
diff --git a/chrome/browser/ui/browser_ui_prefs.cc b/chrome/browser/ui/browser_ui_prefs.cc
index fa9ec80a9755..214dba85c0e8 100644
--- a/chrome/browser/ui/browser_ui_prefs.cc
+++ b/chrome/browser/ui/browser_ui_prefs.cc
@@ -40,7 +40,7 @@ uint32_t GetHomeButtonAndHomePageIsNewTabPageFlags() {
 void RegisterBrowserPrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kAllowFileSelectionDialogs, true);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterIntegerPref(prefs::kRelaunchNotification, 0);
   registry->RegisterIntegerPref(
       prefs::kRelaunchNotificationPeriod,
diff --git a/chrome/browser/ui/browser_window.h b/chrome/browser/ui/browser_window.h
index 8b1bbcde9a7a..e527178396a3 100644
--- a/chrome/browser/ui/browser_window.h
+++ b/chrome/browser/ui/browser_window.h
@@ -31,10 +31,6 @@
 #include "ui/gfx/native_widget_types.h"
 #include "url/origin.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Browser;
 class SharingDialog;
 class DownloadShelf;
diff --git a/chrome/browser/ui/chrome_pages.cc b/chrome/browser/ui/chrome_pages.cc
index 25469b494ae5..0b0e25a37961 100644
--- a/chrome/browser/ui/chrome_pages.cc
+++ b/chrome/browser/ui/chrome_pages.cc
@@ -68,7 +68,7 @@
 #include "chrome/browser/ui/signin_view_controller.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
@@ -506,7 +506,7 @@ GURL GetOSSettingsUrl(const std::string& sub_page) {
 }
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point) {
   Profile* original_profile = browser->profile()->GetOriginalProfile();
diff --git a/chrome/browser/ui/chrome_pages.h b/chrome/browser/ui/chrome_pages.h
index 24779d2549fa..1fad252cb1f4 100644
--- a/chrome/browser/ui/chrome_pages.h
+++ b/chrome/browser/ui/chrome_pages.h
@@ -13,7 +13,7 @@
 #include "components/content_settings/core/common/content_settings_types.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/signin/signin_promo.h"
 #endif
 
@@ -135,7 +135,7 @@ void ShowEnterpriseManagementPageInTabbedBrowser(Browser* browser);
 GURL GetOSSettingsUrl(const std::string& sub_page);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 // Initiates signin in a new browser tab.
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point);
diff --git a/chrome/browser/ui/content_settings/content_setting_bubble_model.cc b/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
index 5f600f81d7bb..820f3e7b932d 100644
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
@@ -691,10 +691,13 @@ ContentSettingPluginBubbleModel::ContentSettingPluginBubbleModel(
   const GURL& url = web_contents->GetURL();
   bool managed_by_user =
       GetSettingManagedByUser(url, content_type(), GetProfile(), nullptr);
+#if 0
   HostContentSettingsMap* map =
       HostContentSettingsMapFactory::GetForProfile(GetProfile());
   ContentSetting setting = PluginUtils::GetFlashPluginContentSetting(
       map, url::Origin::Create(url), url, nullptr);
+#endif
+  ContentSetting setting = CONTENT_SETTING_BLOCK;
 
   // If the setting is not managed by the user, hide the "Manage" button.
   if (!managed_by_user)
diff --git a/chrome/browser/ui/content_settings/content_setting_bubble_model.h b/chrome/browser/ui/content_settings/content_setting_bubble_model.h
index 83f24dfcc1ea..8ab6d5fa5072 100644
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.h
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.h
@@ -505,7 +505,7 @@ class ContentSettingSingleRadioGroup : public ContentSettingSimpleBubbleModel {
   DISALLOW_COPY_AND_ASSIGN(ContentSettingSingleRadioGroup);
 };
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The model for the blocked Framebust bubble.
 class ContentSettingFramebustBlockBubbleModel
     : public ContentSettingSingleRadioGroup,
diff --git a/chrome/browser/ui/exclusive_access/fullscreen_controller.cc b/chrome/browser/ui/exclusive_access/fullscreen_controller.cc
index 88f2f3e679d3..7f9138d29a77 100644
--- a/chrome/browser/ui/exclusive_access/fullscreen_controller.cc
+++ b/chrome/browser/ui/exclusive_access/fullscreen_controller.cc
@@ -95,6 +95,7 @@ bool FullscreenController::IsTabFullscreen() const {
 
 bool FullscreenController::IsFullscreenForTabOrPending(
     const WebContents* web_contents) const {
+#if 0
   if (IsFullscreenWithinTab(web_contents))
     return true;
   if (web_contents == exclusive_access_tab()) {
@@ -109,6 +110,9 @@ bool FullscreenController::IsFullscreenForTabOrPending(
     return true;
   }
   return false;
+#else
+  return true;
+#endif
 }
 
 bool FullscreenController::IsFullscreenCausedByTab() const {
diff --git a/chrome/browser/ui/extensions/extension_install_ui_default.cc b/chrome/browser/ui/extensions/extension_install_ui_default.cc
index ba7dfe118da1..ee86339695a5 100644
--- a/chrome/browser/ui/extensions/extension_install_ui_default.cc
+++ b/chrome/browser/ui/extensions/extension_install_ui_default.cc
@@ -60,9 +60,11 @@ void ShowExtensionInstalledBubble(
     scoped_refptr<const extensions::Extension> extension,
     Profile* profile,
     const SkBitmap& icon) {
+  #if 0
   Browser* browser = FindOrCreateVisibleBrowser(profile);
   if (browser)
     ExtensionInstalledBubble::ShowBubble(extension, browser, icon);
+  #endif
 }
 
 }  // namespace
diff --git a/chrome/browser/ui/extensions/icon_with_badge_image_source.h b/chrome/browser/ui/extensions/icon_with_badge_image_source.h
index e82f79440e4b..d421c176597b 100644
--- a/chrome/browser/ui/extensions/icon_with_badge_image_source.h
+++ b/chrome/browser/ui/extensions/icon_with_badge_image_source.h
@@ -56,10 +56,15 @@ class IconWithBadgeImageSource : public gfx::CanvasImageSource {
     return paint_blocked_actions_decoration_;
   }
 
+#if 0
  private:
+#endif
   // gfx::CanvasImageSource:
   void Draw(gfx::Canvas* canvas) override;
 
+#if 1
+ private:
+#endif
   // Paints |badge_|, if any, on |canvas|.
   void PaintBadge(gfx::Canvas* canvas);
 
diff --git a/chrome/browser/ui/fast_unload_controller.cc b/chrome/browser/ui/fast_unload_controller.cc
new file mode 100644
index 000000000000..fe6f07d69351
--- /dev/null
+++ b/chrome/browser/ui/fast_unload_controller.cc
@@ -0,0 +1,487 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/fast_unload_controller.h"
+
+#include "base/location.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/single_thread_task_runner.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "chrome/browser/chrome_notification_types.h"
+#include "chrome/browser/devtools/devtools_window.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/tab_contents/core_tab_helper.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/browser/ui/tabs/tab_strip_model_delegate.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/notification_source.h"
+#include "content/public/browser/notification_types.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/buildflags/buildflags.h"
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/constants.h"
+#endif  // (ENABLE_EXTENSIONS)
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, public:
+
+FastUnloadController::FastUnloadController(Browser* browser)
+    : browser_(browser),
+      tab_needing_before_unload_ack_(NULL),
+      is_attempting_to_close_browser_(false),
+      weak_factory_(this) {
+  browser_->tab_strip_model()->AddObserver(this);
+}
+
+FastUnloadController::~FastUnloadController() {
+  browser_->tab_strip_model()->RemoveObserver(this);
+  web_contents_waiting_for_deletion_.clear();
+}
+
+bool FastUnloadController::CanCloseContents(content::WebContents* contents) {
+  // Don't try to close the tab when the whole browser is being closed, since
+  // that avoids the fast shutdown path where we just kill all the renderers.
+  return !is_attempting_to_close_browser_ ||
+      is_calling_before_unload_handlers();
+}
+
+bool FastUnloadController::ShouldRunUnloadEventsHelper(
+    content::WebContents* contents) {
+  // If |contents| is being inspected, devtools needs to intercept beforeunload
+  // events.
+  return false;
+}
+
+bool FastUnloadController::RunUnloadEventsHelper(
+    content::WebContents* contents) {
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  // Don't run for extensions that are disabled or uninstalled; the tabs will
+  // be killed if they make any network requests, and the extension shouldn't
+  // be doing any work if it's removed.
+  GURL url = contents->GetLastCommittedURL();
+  if (url.SchemeIs(extensions::kExtensionScheme) &&
+      !extensions::ExtensionRegistry::Get(browser_->profile())
+           ->enabled_extensions()
+           .GetExtensionOrAppByURL(url)) {
+    return false;
+  }
+#endif  // (ENABLE_EXTENSIONS)
+
+  // Special case for when we quit an application. The Devtools window can
+  // close if it's beforeunload event has already fired which will happen due
+  // to the interception of it's content's beforeunload.
+
+  // If there's a devtools window attached to |contents|,
+  // we would like devtools to call its own beforeunload handlers first,
+  // and then call beforeunload handlers for |contents|.
+  // See DevToolsWindow::InterceptPageBeforeUnload for details.
+  // If the WebContents is not connected yet, then there's no unload
+  // handler we can fire even if the WebContents has an unload listener.
+  // One case where we hit this is in a tab that has an infinite loop
+  // before load.
+  if (contents->NeedToFireBeforeUnload()) {
+    // If the page has unload listeners, then we tell the renderer to fire
+    // them. Once they have fired, we'll get a message back saying whether
+    // to proceed closing the page or not, which sends us back to this method
+    // with the NeedToFireBeforeUnload bit cleared.
+    contents->DispatchBeforeUnload();
+    return true;
+  }
+  return false;
+}
+
+bool FastUnloadController::BeforeUnloadFiredForContents(
+    content::WebContents* contents,
+    bool proceed) {
+
+  if (!is_attempting_to_close_browser_) {
+    if (!proceed) {
+      contents->SetClosedByUserGesture(false);
+    } else {
+      // No more dialogs are possible, so remove the tab and finish
+      // running unload listeners asynchrounously.
+      browser_->tab_strip_model()->delegate()->CreateHistoricalTab(contents);
+      DetachWebContents(contents);
+    }
+    return proceed;
+  }
+
+  if (!proceed) {
+    CancelWindowClose();
+    contents->SetClosedByUserGesture(false);
+    return false;
+  }
+
+  if (tab_needing_before_unload_ack_ == contents) {
+    // Now that beforeunload has fired, queue the tab to fire unload.
+    tab_needing_before_unload_ack_ = NULL;
+    tabs_needing_unload_.insert(contents);
+    ProcessPendingTabs(false);
+    // We want to handle firing the unload event ourselves since we want to
+    // fire all the beforeunload events before attempting to fire the unload
+    // events should the user cancel closing the browser.
+    return false;
+  }
+
+  return true;
+}
+
+bool FastUnloadController::ShouldCloseWindow() {
+  if (HasCompletedUnloadProcessing())
+    return true;
+
+  // Special case for when we quit an application. The Devtools window can
+  // close if it's beforeunload event has already fired which will happen due
+  // to the interception of it's content's beforeunload.
+
+  // The behavior followed here varies based on the current phase of the
+  // operation and whether a batched shutdown is in progress.
+  //
+  // If there are tabs with outstanding beforeunload handlers:
+  // 1. If a batched shutdown is in progress: return false.
+  //    This is to prevent interference with batched shutdown already in
+  //    progress.
+  // 2. Otherwise: start sending beforeunload events and return false.
+  //
+  // Otherwise, If there are no tabs with outstanding beforeunload handlers:
+  // 3. If a batched shutdown is in progress: start sending unload events and
+  //    return false.
+  // 4. Otherwise: return true.
+  is_attempting_to_close_browser_ = true;
+  // Cases 1 and 4.
+  bool need_beforeunload_fired = TabsNeedBeforeUnloadFired();
+  if (need_beforeunload_fired == is_calling_before_unload_handlers())
+    return !need_beforeunload_fired;
+
+  // Cases 2 and 3.
+  on_close_confirmed_.Reset();
+  ProcessPendingTabs(false);
+  return false;
+}
+
+bool FastUnloadController::TryToCloseWindow(
+    bool skip_beforeunload,
+    const base::Callback<void(bool)>& on_close_confirmed) {
+  // The devtools browser gets its beforeunload events as the results of
+  // intercepting events from the inspected tab, so don't send them here as
+  // well.
+  if (browser_->is_devtools() || !TabsNeedBeforeUnloadFired())
+    return false;
+
+  on_close_confirmed_ = on_close_confirmed;
+  is_attempting_to_close_browser_ = true;
+  ProcessPendingTabs(skip_beforeunload);
+  return !skip_beforeunload;
+}
+
+void FastUnloadController::ResetTryToCloseWindow() {
+  if (!is_calling_before_unload_handlers())
+    return;
+  CancelWindowClose();
+}
+
+bool FastUnloadController::TabsNeedBeforeUnloadFired() {
+  if (!tabs_needing_before_unload_.empty() ||
+      tab_needing_before_unload_ack_ != NULL)
+    return true;
+
+  if (!is_calling_before_unload_handlers() && !tabs_needing_unload_.empty())
+    return false;
+
+  return !tabs_needing_before_unload_.empty();
+}
+
+bool FastUnloadController::HasCompletedUnloadProcessing() const {
+  return is_attempting_to_close_browser_ &&
+      tabs_needing_before_unload_.empty() &&
+      tab_needing_before_unload_ack_ == NULL &&
+      tabs_needing_unload_.empty() &&
+      tabs_needing_unload_ack_.empty();
+}
+
+void FastUnloadController::CancelTabNeedingBeforeUnloadAck() {
+  if (tab_needing_before_unload_ack_ != NULL) {
+    CoreTabHelper* core_tab_helper =
+        CoreTabHelper::FromWebContents(tab_needing_before_unload_ack_);
+    core_tab_helper->OnCloseCanceled();
+    tab_needing_before_unload_ack_ = NULL;
+  }
+}
+
+void FastUnloadController::CancelWindowClose() {
+  // Closing of window can be canceled from a beforeunload handler.
+  DCHECK(is_attempting_to_close_browser_);
+  tabs_needing_before_unload_.clear();
+  CancelTabNeedingBeforeUnloadAck();
+  for (WebContentsSet::iterator it = tabs_needing_unload_.begin();
+       it != tabs_needing_unload_.end(); it++) {
+    content::WebContents* contents = *it;
+
+    CoreTabHelper* core_tab_helper = CoreTabHelper::FromWebContents(contents);
+    core_tab_helper->OnCloseCanceled();
+  }
+  tabs_needing_unload_.clear();
+
+  // No need to clear tabs_needing_unload_ack_. Those tabs are already detached.
+
+  if (is_calling_before_unload_handlers()) {
+    base::Callback<void(bool)> on_close_confirmed = on_close_confirmed_;
+    on_close_confirmed_.Reset();
+    on_close_confirmed.Run(false);
+  }
+
+  is_attempting_to_close_browser_ = false;
+
+  content::NotificationService::current()->Notify(
+      chrome::NOTIFICATION_BROWSER_CLOSE_CANCELLED,
+      content::Source<Browser>(browser_),
+      content::NotificationService::NoDetails());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, content::WebContentsDelegate implementation:
+
+bool FastUnloadController::ShouldSuppressDialogs(content::WebContents* source) {
+  return true;
+}
+
+void FastUnloadController::CloseContents(content::WebContents* source) {
+  auto it = web_contents_waiting_for_deletion_.find(source);
+  DCHECK(it != web_contents_waiting_for_deletion_.end());
+  web_contents_waiting_for_deletion_.erase(it);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, content::NotificationObserver implementation:
+
+void FastUnloadController::Observe(
+      int type,
+      const content::NotificationSource& source,
+      const content::NotificationDetails& details) {
+  DCHECK_EQ(content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED, type);
+
+  registrar_.Remove(this, content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                    source);
+  ClearUnloadState(content::Source<content::WebContents>(source).ptr());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, TabStripModelObserver implementation:
+
+void FastUnloadController::TabInsertedAt(TabStripModel* tab_strip_model,
+                                         content::WebContents* contents,
+                                         int index,
+                                         bool foreground) {
+  TabAttachedImpl(contents);
+}
+
+void FastUnloadController::TabDetachedAt(content::WebContents* contents,
+                                         int index,
+                                         bool was_active) {
+  TabDetachedImpl(contents);
+}
+
+void FastUnloadController::TabReplacedAt(TabStripModel* tab_strip_model,
+                                         content::WebContents* old_contents,
+                                         content::WebContents* new_contents,
+                                         int index) {
+  TabDetachedImpl(old_contents);
+  TabAttachedImpl(new_contents);
+}
+
+void FastUnloadController::TabStripEmpty() {
+  // Set is_attempting_to_close_browser_ here, so that extensions, etc, do not
+  // attempt to add tabs to the browser before it closes.
+  is_attempting_to_close_browser_ = true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, private:
+
+void FastUnloadController::TabAttachedImpl(content::WebContents* contents) {
+  // If the tab crashes in the beforeunload or unload handler, it won't be
+  // able to ack. But we know we can close it.
+  registrar_.Add(
+      this,
+      content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+      content::Source<content::WebContents>(contents));
+}
+
+void FastUnloadController::TabDetachedImpl(content::WebContents* contents) {
+  if (tabs_needing_unload_ack_.find(contents) !=
+      tabs_needing_unload_ack_.end()) {
+    // Tab needs unload to complete.
+    // It will send |NOTIFICATION_WEB_CONTENTS_DISCONNECTED| when done.
+    return;
+  }
+
+  // If WEB_CONTENTS_DISCONNECTED was received then the notification may have
+  // already been unregistered.
+  const content::NotificationSource& source =
+      content::Source<content::WebContents>(contents);
+  if (registrar_.IsRegistered(this,
+                              content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                              source)) {
+    registrar_.Remove(this,
+                      content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                      source);
+  }
+
+  if (is_attempting_to_close_browser_)
+    ClearUnloadState(contents);
+}
+
+bool FastUnloadController::DetachWebContents(content::WebContents* contents) {
+  int index = browser_->tab_strip_model()->GetIndexOfWebContents(contents);
+  if (index != TabStripModel::kNoTab &&
+      contents->NeedToFireBeforeUnload()) {
+    tabs_needing_unload_ack_.insert(contents);
+    web_contents_waiting_for_deletion_[contents] =
+        browser_->tab_strip_model()->DetachWebContentsAt(index);
+    contents->SetDelegate(this);
+    CoreTabHelper* core_tab_helper = CoreTabHelper::FromWebContents(contents);
+    core_tab_helper->OnUnloadDetachedStarted();
+    return true;
+  }
+  return false;
+}
+
+void FastUnloadController::ProcessPendingTabs(bool skip_beforeunload) {
+  if (!is_attempting_to_close_browser_) {
+    // Because we might invoke this after a delay it's possible for the value of
+    // is_attempting_to_close_browser_ to have changed since we scheduled the
+    // task.
+    return;
+  }
+
+  if (tab_needing_before_unload_ack_ != NULL) {
+    if (skip_beforeunload) {
+      // Cancel and skip the ongoing before unload event.
+      tabs_needing_before_unload_.insert(tab_needing_before_unload_ack_);
+      CancelTabNeedingBeforeUnloadAck();
+    } else {
+      // Wait for |BeforeUnloadFiredForContents| before proceeding.
+      return;
+    }
+  }
+
+  // Process a beforeunload handler.
+  if (!tabs_needing_before_unload_.empty()) {
+    if (skip_beforeunload) {
+      tabs_needing_unload_.insert(tabs_needing_before_unload_.begin(),
+                                  tabs_needing_before_unload_.end());
+      tabs_needing_before_unload_.clear();
+    } else {
+      WebContentsSet::iterator it = tabs_needing_before_unload_.begin();
+      content::WebContents* contents = *it;
+      tabs_needing_before_unload_.erase(it);
+      // Null check render_view_host here as this gets called on a PostTask and
+      // the tab's render_view_host may have been nulled out.
+      if (contents->GetRenderViewHost()) {
+        tab_needing_before_unload_ack_ = contents;
+
+        CoreTabHelper* core_tab_helper =
+            CoreTabHelper::FromWebContents(contents);
+        core_tab_helper->OnCloseStarted();
+
+        // If there's a devtools window attached to |contents|,
+        // we would like devtools to call its own beforeunload handlers first,
+        // and then call beforeunload handlers for |contents|.
+        // See DevToolsWindow::InterceptPageBeforeUnload for details.
+      } else {
+        ProcessPendingTabs(skip_beforeunload);
+      }
+      return;
+    }
+  }
+
+  if (is_calling_before_unload_handlers()) {
+    base::OnceCallback<void(bool)> on_close_confirmed = on_close_confirmed_;
+    // Reset |on_close_confirmed_| in case the callback tests
+    // |is_calling_before_unload_handlers()|, we want to return that calling
+    // is complete.
+    if (tabs_needing_unload_.empty())
+      on_close_confirmed_.Reset();
+    if (!skip_beforeunload)
+      std::move(on_close_confirmed).Run(true);
+    return;
+  }
+
+  // Process all the unload handlers. (The beforeunload handlers have finished.)
+  if (!tabs_needing_unload_.empty()) {
+    browser_->OnWindowClosing();
+
+    // Run unload handlers detached since no more interaction is possible.
+    WebContentsSet::iterator it = tabs_needing_unload_.begin();
+    while (it != tabs_needing_unload_.end()) {
+      WebContentsSet::iterator current = it++;
+      content::WebContents* contents = *current;
+      tabs_needing_unload_.erase(current);
+      // Null check render_view_host here as this gets called on a PostTask
+      // and the tab's render_view_host may have been nulled out.
+      if (contents->GetRenderViewHost()) {
+        CoreTabHelper* core_tab_helper =
+            CoreTabHelper::FromWebContents(contents);
+        core_tab_helper->OnUnloadStarted();
+        DetachWebContents(contents);
+        contents->ClosePage();
+      }
+    }
+
+    // Get the browser hidden.
+    if (browser_->tab_strip_model()->empty()) {
+      browser_->TabStripEmpty();
+    } else {
+      browser_->tab_strip_model()->CloseAllTabs();  // tabs not needing unload
+    }
+    return;
+  }
+
+  if (HasCompletedUnloadProcessing()) {
+    browser_->OnWindowClosing();
+
+    // Get the browser closed.
+    if (browser_->tab_strip_model()->empty()) {
+      browser_->TabStripEmpty();
+    } else {
+      // There may be tabs if the last tab needing beforeunload crashed.
+      browser_->tab_strip_model()->CloseAllTabs();
+    }
+    return;
+  }
+}
+
+void FastUnloadController::ClearUnloadState(content::WebContents* contents) {
+  if (tabs_needing_unload_ack_.erase(contents) > 0) {
+    if (HasCompletedUnloadProcessing())
+      PostTaskForProcessPendingTabs();
+    return;
+  }
+
+  if (!is_attempting_to_close_browser_)
+    return;
+
+  if (tab_needing_before_unload_ack_ == contents) {
+    tab_needing_before_unload_ack_ = NULL;
+    PostTaskForProcessPendingTabs();
+    return;
+  }
+
+  if (tabs_needing_before_unload_.erase(contents) > 0 ||
+      tabs_needing_unload_.erase(contents) > 0) {
+    if (tab_needing_before_unload_ack_ == NULL)
+      PostTaskForProcessPendingTabs();
+  }
+}
+
+void FastUnloadController::PostTaskForProcessPendingTabs() {
+  base::ThreadTaskRunnerHandle::Get()->PostTask(
+      FROM_HERE, base::BindOnce(&FastUnloadController::ProcessPendingTabs,
+                                weak_factory_.GetWeakPtr(), false));
+}
diff --git a/chrome/browser/ui/native_window_tracker_android.cc b/chrome/browser/ui/native_window_tracker_android.cc
new file mode 100644
index 000000000000..53bf4cc03b65
--- /dev/null
+++ b/chrome/browser/ui/native_window_tracker_android.cc
@@ -0,0 +1,26 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/native_window_tracker_android.h"
+
+#include "ui/android/window_android.h"
+
+NativeWindowTrackerAndroid::NativeWindowTrackerAndroid(
+    gfx::NativeWindow window)
+    : window_(window) {
+}
+
+NativeWindowTrackerAndroid::~NativeWindowTrackerAndroid() {
+}
+
+bool NativeWindowTrackerAndroid::WasNativeWindowClosed() const {
+  return window_ == nullptr;
+}
+
+// static
+std::unique_ptr<NativeWindowTracker> NativeWindowTracker::Create(
+    gfx::NativeWindow window) {
+  return std::unique_ptr<NativeWindowTracker>(
+      new NativeWindowTrackerAndroid(window));
+}
diff --git a/chrome/browser/ui/native_window_tracker_android.h b/chrome/browser/ui/native_window_tracker_android.h
new file mode 100644
index 000000000000..6f472b86e736
--- /dev/null
+++ b/chrome/browser/ui/native_window_tracker_android.h
@@ -0,0 +1,26 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+#define CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+
+#include "base/macros.h"
+#include "chrome/browser/ui/native_window_tracker.h"
+#include "ui/android/window_android.h"
+
+class NativeWindowTrackerAndroid : public NativeWindowTracker {
+ public:
+  explicit NativeWindowTrackerAndroid(gfx::NativeWindow window);
+  ~NativeWindowTrackerAndroid() override;
+
+  bool WasNativeWindowClosed() const override;
+
+ private:
+
+  gfx::NativeWindow window_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowTrackerAndroid);
+};
+
+#endif  // CHROME_BROWSER_UI_AURA_NATIVE_WINDOW_TRACKER_AURA_H_
diff --git a/chrome/browser/ui/page_info/page_info_ui.cc b/chrome/browser/ui/page_info/page_info_ui.cc
index 99b7d6745b86..ad8cdb233f53 100644
--- a/chrome/browser/ui/page_info/page_info_ui.cc
+++ b/chrome/browser/ui/page_info/page_info_ui.cc
@@ -31,7 +31,7 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/android_theme_resources.h"
-#else
+
 #include "chrome/app/vector_icons/vector_icons.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/pref_names.h"
@@ -50,7 +50,7 @@ namespace {
 
 const int kInvalidResourceID = -1;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The icon size is actually 16, but the vector icons being used generally all
 // have additional internal padding. Account for this difference by asking for
 // the vectors in 18x18dip sizes.
@@ -110,7 +110,7 @@ static_assert(base::size(kPermissionButtonTextIDDefaultSetting) ==
                   CONTENT_SETTING_NUM_SETTINGS,
               "kPermissionButtonTextIDDefaultSetting array size is incorrect");
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The resource IDs for the strings that are displayed on the sound permission
 // button if the sound permission setting is managed by the user.
 const int kSoundPermissionButtonTextIDUserManaged[] = {
@@ -176,7 +176,7 @@ base::span<const PermissionsUIInfo> GetContentSettingsUIInfo() {
          ? IDS_PAGE_INFO_TYPE_SENSORS
          : IDS_PAGE_INFO_TYPE_MOTION_SENSORS},
     {ContentSettingsType::USB_GUARD, IDS_PAGE_INFO_TYPE_USB},
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     {ContentSettingsType::SERIAL_GUARD, IDS_PAGE_INFO_TYPE_SERIAL},
 #endif
     {ContentSettingsType::NATIVE_FILE_SYSTEM_WRITE_GUARD,
@@ -552,7 +552,7 @@ int PageInfoUI::GetConnectionIconID(PageInfo::SiteConnectionStatus status) {
   }
   return resource_id;
 }
-#else  // !defined(OS_ANDROID)
+
 // static
 const gfx::ImageSkia PageInfoUI::GetPermissionIcon(const PermissionInfo& info,
                                                    SkColor related_text_color) {
diff --git a/chrome/browser/ui/page_info/page_info_ui.h b/chrome/browser/ui/page_info/page_info_ui.h
index 90619d7736dc..183d62110adc 100644
--- a/chrome/browser/ui/page_info/page_info_ui.h
+++ b/chrome/browser/ui/page_info/page_info_ui.h
@@ -18,7 +18,7 @@
 #include "components/safe_browsing/buildflags.h"
 #include "ui/gfx/native_widget_types.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "ui/gfx/image/image_skia.h"
 #endif
 
@@ -204,7 +204,7 @@ class PageInfoUI {
 
   // Returns the connection icon ID for the given connection |status|.
   static int GetConnectionIconID(PageInfo::SiteConnectionStatus status);
-#else  // !defined(OS_ANDROID)
+
   // Returns icons for the given PermissionInfo |info|. If |info|'s current
   // setting is CONTENT_SETTING_DEFAULT, it will return the icon for |info|'s
   // default setting.
diff --git a/chrome/browser/ui/passwords/manage_passwords_view_utils.cc b/chrome/browser/ui/passwords/manage_passwords_view_utils.cc
index 71bdf570f52e..8617869aa7e7 100644
--- a/chrome/browser/ui/passwords/manage_passwords_view_utils.cc
+++ b/chrome/browser/ui/passwords/manage_passwords_view_utils.cc
@@ -232,7 +232,7 @@ bool ShouldManagePasswordsinGooglePasswordManager(Profile* profile) {
 }
 
 // Navigation is handled differently on Android.
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void NavigateToGooglePasswordManager(Profile* profile,
                                      ManagePasswordsReferrer referrer) {
   NavigateParams params(profile, GetGooglePasswordManagerURL(referrer),
@@ -245,6 +245,7 @@ void NavigateToManagePasswordsPage(Browser* browser,
                                    ManagePasswordsReferrer referrer) {
   UMA_HISTOGRAM_ENUMERATION("PasswordManager.ManagePasswordsReferrer",
                             referrer);
+#if 0
   if (IsSignedInAndSyncingPasswordsNormally(browser->profile())) {
     UMA_HISTOGRAM_ENUMERATION(
         "PasswordManager.ManagePasswordsReferrerSignedInAndSyncing", referrer);
@@ -255,6 +256,7 @@ void NavigateToManagePasswordsPage(Browser* browser,
   }
 
   chrome::ShowPasswordManager(browser);
+ #endif
 }
 
 void NavigateToPasswordCheckupPage(Profile* profile) {
diff --git a/chrome/browser/ui/passwords/manage_passwords_view_utils.h b/chrome/browser/ui/passwords/manage_passwords_view_utils.h
index 01d5672b8401..aed14d368277 100644
--- a/chrome/browser/ui/passwords/manage_passwords_view_utils.h
+++ b/chrome/browser/ui/passwords/manage_passwords_view_utils.h
@@ -10,6 +10,7 @@
 #include "base/strings/string16.h"
 #include "components/password_manager/core/browser/manage_passwords_referrer.h"
 #include "components/password_manager/core/browser/origin_credential_store.h"
+// #include "chrome/browser/ui/browser.h"
 
 namespace autofill {
 struct PasswordForm;
diff --git a/chrome/browser/ui/passwords/settings/password_manager_presenter.cc b/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
index 3fcc92f5c0dd..265ba5bfe1b9 100644
--- a/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
+++ b/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
@@ -44,7 +44,7 @@
 #include "components/undo/undo_operation.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/extensions/api/passwords_private/passwords_private_utils.h"
 #endif
 
@@ -339,7 +339,7 @@ void PasswordManagerPresenter::UndoRemoveSavedPasswordOrException() {
   undo_manager_.Undo();
 }
 
-#if !defined(OS_ANDROID)  // This is never called on Android.
+#if true || !defined(OS_ANDROID)  // This is never called on Android.
 void PasswordManagerPresenter::RequestShowPassword(
     const std::string& sort_key,
     base::OnceCallback<void(base::Optional<base::string16>)> callback) const {
diff --git a/chrome/browser/ui/screen_capture_notification_ui_stub.cc b/chrome/browser/ui/screen_capture_notification_ui_stub.cc
index ec35cb8a5495..9496c8da1fdf 100644
--- a/chrome/browser/ui/screen_capture_notification_ui_stub.cc
+++ b/chrome/browser/ui/screen_capture_notification_ui_stub.cc
@@ -20,8 +20,10 @@ class ScreenCaptureNotificationUIStub : public ScreenCaptureNotificationUI {
 };
 
 // static
+#if 0
 std::unique_ptr<ScreenCaptureNotificationUI>
 ScreenCaptureNotificationUI::Create(const base::string16& title) {
   return std::unique_ptr<ScreenCaptureNotificationUI>(
       new ScreenCaptureNotificationUIStub());
 }
+#endif
diff --git a/chrome/browser/ui/search/instant_controller.h b/chrome/browser/ui/search/instant_controller.h
index aabfb16b471f..2ddd79ecd51e 100644
--- a/chrome/browser/ui/search/instant_controller.h
+++ b/chrome/browser/ui/search/instant_controller.h
@@ -12,10 +12,6 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/tabs/tab_strip_model_observer.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class Profile;
 class TabStripModel;
 
diff --git a/chrome/browser/ui/search/ntp_user_data_logger.h b/chrome/browser/ui/search/ntp_user_data_logger.h
index a61a8d44e33b..401c6e4eea3c 100644
--- a/chrome/browser/ui/search/ntp_user_data_logger.h
+++ b/chrome/browser/ui/search/ntp_user_data_logger.h
@@ -21,10 +21,6 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 }
diff --git a/chrome/browser/ui/search/search_ipc_router.h b/chrome/browser/ui/search/search_ipc_router.h
index 7e52d7ed777e..76931eb8d43d 100644
--- a/chrome/browser/ui/search/search_ipc_router.h
+++ b/chrome/browser/ui/search/search_ipc_router.h
@@ -21,10 +21,6 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "mojo/public/cpp/bindings/associated_receiver.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class GURL;
 
 namespace content {
diff --git a/chrome/browser/ui/search/search_ipc_router_policy_impl.h b/chrome/browser/ui/search/search_ipc_router_policy_impl.h
index 286ddedb454f..19b95b52f927 100644
--- a/chrome/browser/ui/search/search_ipc_router_policy_impl.h
+++ b/chrome/browser/ui/search/search_ipc_router_policy_impl.h
@@ -9,10 +9,6 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/search/search_ipc_router.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 }
diff --git a/chrome/browser/ui/search/search_tab_helper.h b/chrome/browser/ui/search/search_tab_helper.h
index b1c4f5242ecb..dcdf914b24d4 100644
--- a/chrome/browser/ui/search/search_tab_helper.h
+++ b/chrome/browser/ui/search/search_tab_helper.h
@@ -28,10 +28,6 @@
 #include "content/public/browser/web_contents_user_data.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 struct LoadCommittedDetails;
diff --git a/chrome/browser/ui/signin_view_controller.h b/chrome/browser/ui/signin_view_controller.h
index f0ea2007c7de..1efd17a759f1 100644
--- a/chrome/browser/ui/signin_view_controller.h
+++ b/chrome/browser/ui/signin_view_controller.h
@@ -13,9 +13,11 @@
 #include "components/signin/public/base/signin_buildflags.h"
 #include "url/gurl.h"
 
+#if 0
 #if defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
+#endif
 
 class Browser;
 class SigninViewControllerDelegate;
diff --git a/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc b/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
index 52603574ba62..f06a6b120fce 100644
--- a/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
+++ b/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
@@ -37,6 +37,7 @@ void HandleOnPerformDrop(
     content::WebContents* web_contents,
     const content::DropData& drop_data,
     content::WebContentsViewDelegate::DropCompletionCallback callback) {
+#if 0
   safe_browsing::DeepScanningDialogDelegate::Data data;
   Profile* profile =
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
@@ -68,4 +69,5 @@ void HandleOnPerformDrop(
       web_contents, std::move(data),
       base::BindOnce(&DeepScanCompletionCallback, std::move(callback)),
       safe_browsing::DeepScanAccessPoint::DRAG_AND_DROP);
+ #endif
 }
diff --git a/chrome/browser/ui/tab_helpers.cc b/chrome/browser/ui/tab_helpers.cc
index 0d9d59805199..b488b422816b 100644
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -350,8 +350,10 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::TabHelper::CreateForWebContents(web_contents);
+#if 0
   if (web_app::AreWebAppsEnabled(profile))
     web_app::WebAppTabHelper::CreateForWebContents(web_contents);
+#endif
   if (SiteEngagementService::IsEnabled())
     web_app::WebAppMetrics::Get(profile);
 #endif
diff --git a/chrome/browser/ui/tabs/tab_strip_model.cc b/chrome/browser/ui/tabs/tab_strip_model.cc
index 13143a53a18f..1ef7f709f9e5 100644
--- a/chrome/browser/ui/tabs/tab_strip_model.cc
+++ b/chrome/browser/ui/tabs/tab_strip_model.cc
@@ -972,11 +972,15 @@ void TabStripModel::CloseSelectedTabs() {
 }
 
 void TabStripModel::SelectNextTab(UserGestureDetails detail) {
+#if 0
   SelectRelativeTab(true, detail);
+#endif
 }
 
 void TabStripModel::SelectPreviousTab(UserGestureDetails detail) {
+#if 0
   SelectRelativeTab(false, detail);
+#endif
 }
 
 void TabStripModel::SelectLastTab(UserGestureDetails detail) {
@@ -1440,6 +1444,7 @@ int TabStripModel::InsertWebContentsAtImpl(
     std::unique_ptr<content::WebContents> contents,
     int add_types,
     base::Optional<TabGroupId> group) {
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step 1";
   delegate()->WillAddWebContents(contents.get());
 
   bool active = (add_types & ADD_ACTIVE) != 0;
@@ -1463,6 +1468,7 @@ int TabStripModel::InsertWebContentsAtImpl(
     data->set_opener(active_contents);
   }
 
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step A";
   // TODO(gbillock): Ask the modal dialog manager whether the WebContents should
   // be blocked, or just let the modal dialog manager make the blocking call
   // directly and not use this at all.
@@ -1485,14 +1491,23 @@ int TabStripModel::InsertWebContentsAtImpl(
                              /*triggered_by_other_operation=*/true);
   }
 
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step B1";
   TabStripModelChange::Insert insert;
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step B2";
   insert.contents.push_back({raw_contents, index});
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step B3";
   TabStripModelChange change(std::move(insert));
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step B4";
+#if 0
   for (auto& observer : observers_)
     observer.OnTabStripModelChanged(this, change, selection);
-  if (group.has_value())
+#endif
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step B5";
+  if (group.has_value()) {
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step B6";
     GroupTab(index, group.value());
-
+  }
+  LOG(ERROR) << "[Kiwi] TabStripModel::InsertWebContentsAtImpl - Step C";
   return index;
 }
 
diff --git a/chrome/browser/ui/tabs/tab_strip_model.h b/chrome/browser/ui/tabs/tab_strip_model.h
index f7282146e44d..92ba717b1f92 100644
--- a/chrome/browser/ui/tabs/tab_strip_model.h
+++ b/chrome/browser/ui/tabs/tab_strip_model.h
@@ -31,10 +31,6 @@
 #include "ui/base/models/list_selection_model.h"
 #include "ui/base/page_transition_types.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Profile;
 class TabGroupModel;
 class TabStripModelDelegate;
diff --git a/chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc b/chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc
new file mode 100644
index 000000000000..1cbc2ce23f9b
--- /dev/null
+++ b/chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc
@@ -0,0 +1,59 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/toolbar/component_toolbar_actions_factory.h"
+
+#include "base/command_line.h"
+#include "base/lazy_instance.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/media/router/media_router_feature.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/toolbar/media_router_action.h"
+#include "chrome/browser/ui/toolbar/media_router_action_controller.h"
+#include "chrome/browser/ui/toolbar/toolbar_action_view_controller.h"
+#include "chrome/browser/ui/toolbar/toolbar_actions_bar.h"
+#include "extensions/browser/extension_registry.h"
+
+// static
+const char ComponentToolbarActionsFactory::kMediaRouterActionId[] =
+    "media_router_action";
+
+ComponentToolbarActionsFactory::ComponentToolbarActionsFactory(
+    Profile* profile) {
+}
+
+ComponentToolbarActionsFactory::~ComponentToolbarActionsFactory() {}
+
+std::set<std::string> ComponentToolbarActionsFactory::GetInitialComponentIds() {
+  // TODO(takumif): Instead of keeping track of |initial_ids_|, simplify by
+  // checking here whether MediaRouterAction should be visible.
+  return initial_ids_;
+}
+
+void ComponentToolbarActionsFactory::OnAddComponentActionBeforeInit(
+    const std::string& action_id) {
+  initial_ids_.insert(action_id);
+}
+
+void ComponentToolbarActionsFactory::OnRemoveComponentActionBeforeInit(
+    const std::string& action_id) {
+  initial_ids_.erase(action_id);
+}
+
+std::unique_ptr<ToolbarActionViewController>
+ComponentToolbarActionsFactory::GetComponentToolbarActionForId(
+    const std::string& action_id,
+    Browser* browser,
+    ToolbarActionsBar* bar) {
+  // Add component toolbar actions here.
+  // This current design means that the ComponentToolbarActionsFactory is aware
+  // of all actions. Since we should *not* have an excessive amount of these
+  // (since each will have an action in the toolbar or overflow menu), this
+  // should be okay. If this changes, we should rethink this design to have,
+  // e.g., RegisterChromeAction().
+
+  NOTREACHED();
+  return std::unique_ptr<ToolbarActionViewController>();
+}
diff --git a/chrome/browser/ui/unload_controller.cc b/chrome/browser/ui/unload_controller.cc
index 0f394a918479..7f0568f3612c 100644
--- a/chrome/browser/ui/unload_controller.cc
+++ b/chrome/browser/ui/unload_controller.cc
@@ -50,7 +50,7 @@ bool UnloadController::ShouldRunUnloadEventsHelper(
     content::WebContents* contents) {
   // If |contents| is being inspected, devtools needs to intercept beforeunload
   // events.
-  return DevToolsWindow::GetInstanceForInspectedWebContents(contents) != NULL;
+  return false;
 }
 
 bool UnloadController::RunUnloadEventsHelper(content::WebContents* contents) {
@@ -67,20 +67,6 @@ bool UnloadController::RunUnloadEventsHelper(content::WebContents* contents) {
   }
 #endif  // (ENABLE_EXTENSIONS)
 
-  // Special case for when we quit an application. The devtools window can
-  // close if it's beforeunload event has already fired which will happen due
-  // to the interception of it's content's beforeunload.
-  if (browser_->is_type_devtools() &&
-      DevToolsWindow::HasFiredBeforeUnloadEventForDevToolsBrowser(browser_))
-    return false;
-
-  // If there's a devtools window attached to |contents|,
-  // we would like devtools to call its own beforeunload handlers first,
-  // and then call beforeunload handlers for |contents|.
-  // See DevToolsWindow::InterceptPageBeforeUnload for details.
-  if (DevToolsWindow::InterceptPageBeforeUnload(contents)) {
-    return true;
-  }
   // If the WebContents is not connected yet, then there's no unload
   // handler we can fire even if the WebContents has an unload listener.
   // One case where we hit this is in a tab that has an infinite loop
@@ -98,9 +84,6 @@ bool UnloadController::RunUnloadEventsHelper(content::WebContents* contents) {
 
 bool UnloadController::BeforeUnloadFired(content::WebContents* contents,
                                          bool proceed) {
-  if (!proceed)
-    DevToolsWindow::OnPageCloseCanceled(contents);
-
   if (!is_attempting_to_close_browser_) {
     if (!proceed)
       contents->SetClosedByUserGesture(false);
@@ -131,14 +114,6 @@ bool UnloadController::ShouldCloseWindow() {
   if (HasCompletedUnloadProcessing())
     return true;
 
-  // Special case for when we quit an application. The devtools window can
-  // close if it's beforeunload event has already fired which will happen due
-  // to the interception of it's content's beforeunload.
-  if (browser_->is_type_devtools() &&
-      DevToolsWindow::HasFiredBeforeUnloadEventForDevToolsBrowser(browser_)) {
-    return true;
-  }
-
   // The behavior followed here varies based on the current phase of the
   // operation and whether a batched shutdown is in progress.
   //
@@ -188,6 +163,7 @@ void UnloadController::ResetTryToCloseWindow() {
 }
 
 bool UnloadController::TabsNeedBeforeUnloadFired() {
+#if 0
   if (tabs_needing_before_unload_fired_.empty()) {
     for (int i = 0; i < browser_->tab_strip_model()->count(); ++i) {
       content::WebContents* contents =
@@ -201,6 +177,7 @@ bool UnloadController::TabsNeedBeforeUnloadFired() {
       }
     }
   }
+#endif
   return !tabs_needing_before_unload_fired_.empty();
 }
 
@@ -210,10 +187,6 @@ void UnloadController::CancelWindowClose() {
   // case some of this code might not have an effect, but it's still useful to,
   // for example, call the notification(s).
   tabs_needing_before_unload_fired_.clear();
-  for (auto it = tabs_needing_unload_fired_.begin();
-       it != tabs_needing_unload_fired_.end(); ++it) {
-    DevToolsWindow::OnPageCloseCanceled(*it);
-  }
   tabs_needing_unload_fired_.clear();
   if (is_calling_before_unload_handlers()) {
     base::Callback<void(bool)> on_close_confirmed = on_close_confirmed_;
@@ -328,8 +301,6 @@ void UnloadController::ProcessPendingTabs(bool skip_beforeunload) {
       // we would like devtools to call its own beforeunload handlers first,
       // and then call beforeunload handlers for |web_contents|.
       // See DevToolsWindow::InterceptPageBeforeUnload for details.
-      if (!DevToolsWindow::InterceptPageBeforeUnload(web_contents))
-        web_contents->DispatchBeforeUnload(false /* auto_cancel */);
     } else {
       ClearUnloadState(web_contents, true);
     }
diff --git a/chrome/browser/ui/views/BUILD.gn b/chrome/browser/ui/views/BUILD.gn
index 0241896ec54b..9005f7be2b1d 100644
--- a/chrome/browser/ui/views/BUILD.gn
+++ b/chrome/browser/ui/views/BUILD.gn
@@ -5,8 +5,6 @@
 import("//build/config/ui.gni")
 import("//ui/views/features.gni")
 
-assert(toolkit_views)
-
 component("views") {
   output_name = "browser_ui_views"
   sources = [
diff --git a/chrome/browser/ui/views/accelerator_utils_android.cc b/chrome/browser/ui/views/accelerator_utils_android.cc
new file mode 100644
index 000000000000..534e7c9dec47
--- /dev/null
+++ b/chrome/browser/ui/views/accelerator_utils_android.cc
@@ -0,0 +1,30 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/views/accelerator_table.h"
+#include "ui/base/accelerators/accelerator.h"
+
+#if defined(OS_CHROMEOS)
+#include "ash/public/cpp/accelerators.h"
+#endif
+
+namespace chrome {
+
+bool IsChromeAccelerator(const ui::Accelerator& accelerator, Profile* profile) {
+  return false;
+}
+
+ui::Accelerator GetPrimaryChromeAcceleratorForBookmarkPage() {
+  return ui::Accelerator();
+}
+
+ui::Accelerator GetPrimaryChromeAcceleratorForBookmarkTab() {
+  return ui::Accelerator();
+}
+
+}  // namespace chrome
diff --git a/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc b/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc
index 703e4565b62c..22f79d6d0a8e 100644
--- a/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc
+++ b/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc
@@ -378,7 +378,9 @@ void AutofillPopupItemView::OnMouseReleased(const ui::MouseEvent& event) {
 }
 
 void AutofillPopupItemView::CreateContent() {
+#if 0
   AutofillPopupController* controller = popup_view()->controller();
+#endif
 
   auto* layout_manager = SetLayoutManager(std::make_unique<views::BoxLayout>(
       views::BoxLayout::Orientation::kHorizontal,
@@ -387,8 +389,7 @@ void AutofillPopupItemView::CreateContent() {
   layout_manager->set_cross_axis_alignment(
       views::BoxLayout::CrossAxisAlignment::kCenter);
 
-  const gfx::ImageSkia icon =
-      controller->layout_model().GetIconImage(line_number());
+  const gfx::ImageSkia icon = gfx::ImageSkia();
 
   if (!icon.isNull()) {
     AddIcon(icon);
@@ -624,7 +625,9 @@ void AutofillPopupFooterView::CreateContent() {
       /*right=*/0,
       /*color=*/popup_view()->GetSeparatorColor()));
 
+#if 0
   AutofillPopupController* controller = popup_view()->controller();
+#endif
 
   views::BoxLayout* layout_manager =
       SetLayoutManager(std::make_unique<views::BoxLayout>(
@@ -634,8 +637,7 @@ void AutofillPopupFooterView::CreateContent() {
   layout_manager->set_cross_axis_alignment(
       views::BoxLayout::CrossAxisAlignment::kStretch);
 
-  const gfx::ImageSkia icon =
-      controller->layout_model().GetIconImage(line_number());
+  const gfx::ImageSkia icon = gfx::ImageSkia();
 
   // A FooterView shows an icon, if any, on the trailing (right in LTR) side,
   // but the Show Account Cards context is an anomaly. Its icon is on the
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_drag_drop_views.cc b/chrome/browser/ui/views/bookmarks/bookmark_drag_drop_views.cc
index 47b6e6fc2163..b21a8257bb34 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_drag_drop_views.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_drag_drop_views.cc
@@ -285,7 +285,7 @@ void DoDragImpl(std::unique_ptr<ui::OSExchangeData> drag_data,
                 int operation) {
   // Allow nested run loop so we get DnD events as we drag this around.
   base::MessageLoopCurrent::ScopedNestableTaskAllower nestable_task_allower;
-
+#if 0
   views::Widget* widget = views::Widget::GetWidgetForNativeView(native_view);
   if (widget) {
     widget->RunShellDrag(nullptr, std::move(drag_data), gfx::Point(), operation,
@@ -294,6 +294,7 @@ void DoDragImpl(std::unique_ptr<ui::OSExchangeData> drag_data,
     views::RunShellDrag(native_view, std::move(drag_data), point, operation,
                         source);
   }
+#endif
 }
 
 void DragBookmarksImpl(Profile* profile,
diff --git a/chrome/browser/ui/views/browser_dialogs_views.cc b/chrome/browser/ui/views/browser_dialogs_views.cc
index e2943e51ac96..83a90a262853 100644
--- a/chrome/browser/ui/views/browser_dialogs_views.cc
+++ b/chrome/browser/ui/views/browser_dialogs_views.cc
@@ -15,17 +15,6 @@
 #include "chrome/browser/ui/views/bookmarks/bookmark_editor_view.h"
 #include "chrome/browser/ui/views/task_manager_view.h"
 
-// This file provides definitions of desktop browser dialog-creation methods for
-// all toolkit-views platforms.
-// static
-std::unique_ptr<LoginHandler> LoginHandler::Create(
-    const net::AuthChallengeInfo& auth_info,
-    content::WebContents* web_contents,
-    LoginAuthRequiredCallback auth_required_callback) {
-  return chrome::CreateLoginHandlerViews(auth_info, web_contents,
-                                         std::move(auth_required_callback));
-}
-
 // static
 void BookmarkEditor::Show(gfx::NativeWindow parent_window,
                           Profile* profile,
diff --git a/chrome/browser/ui/views/chrome_views_delegate_android.cc b/chrome/browser/ui/views/chrome_views_delegate_android.cc
new file mode 100644
index 000000000000..1321275ee1cd
--- /dev/null
+++ b/chrome/browser/ui/views/chrome_views_delegate_android.cc
@@ -0,0 +1,15 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/chrome_views_delegate.h"
+
+#include "base/feature_list.h"
+#include "chrome/common/chrome_features.h"
+
+views::NativeWidget* ChromeViewsDelegate::CreateNativeWidget(
+    views::Widget::InitParams* params,
+    views::internal::NativeWidgetDelegate* delegate) {
+  // By returning null Widget creates the default NativeWidget implementation.
+  return nullptr;
+}
diff --git a/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc b/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
index 303a9fa508f4..5e585b890730 100644
--- a/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
+++ b/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
@@ -170,7 +170,7 @@ void DesktopMediaListView::OnSourceAdded(size_t index) {
   source_view->SetName(source.name);
   source_view->SetGroup(kDesktopMediaSourceViewGroupId);
   if (source.id.type == DesktopMediaID::TYPE_WINDOW) {
-    gfx::ImageSkia icon_image = GetWindowIcon(source.id);
+    gfx::ImageSkia icon_image = gfx::ImageSkia();
 #if defined(OS_CHROMEOS)
     // Empty icons are used to represent default icon for aura windows. By
     // detecting this, we load the default icon from resource.
diff --git a/chrome/browser/ui/views/desktop_capture/desktop_media_picker_views.cc b/chrome/browser/ui/views/desktop_capture/desktop_media_picker_views.cc
index 838ed5c0d228..bbde8d453fec 100644
--- a/chrome/browser/ui/views/desktop_capture/desktop_media_picker_views.cc
+++ b/chrome/browser/ui/views/desktop_capture/desktop_media_picker_views.cc
@@ -237,10 +237,10 @@ DesktopMediaPickerDialogView::DesktopMediaPickerDialogView(
   // If the picker is a separate native window, it should not be shown in the
   // source list, so its id is passed into NativeDesktopMediaList to be ignored.
   DesktopMediaID dialog_window_id;
+#if 0
   if (is_separate_native_window) {
     dialog_window_id = DesktopMediaID::RegisterNativeWindow(
         DesktopMediaID::TYPE_WINDOW, widget->GetNativeWindow());
-
 #if !defined(OS_CHROMEOS) && defined(USE_AURA)
     // Set native window ID if the windows is outside Ash.
     dialog_window_id.id = AcceleratedWidgetToDesktopMediaId(
@@ -253,6 +253,7 @@ DesktopMediaPickerDialogView::DesktopMediaPickerDialogView(
     dialog_window_id.id = dialog_window_id.window_id;
 #endif
   }
+#endif
 
   for (const auto& list_controller : list_controllers_)
     list_controller->StartUpdating(dialog_window_id);
diff --git a/chrome/browser/ui/views/download/download_item_view.cc b/chrome/browser/ui/views/download/download_item_view.cc
index 0d89919158aa..42c2579138b9 100644
--- a/chrome/browser/ui/views/download/download_item_view.cc
+++ b/chrome/browser/ui/views/download/download_item_view.cc
@@ -1445,7 +1445,9 @@ base::string16 DownloadItemView::ElidedFilename() {
 }
 
 void DownloadItemView::OpenDownloadDuringAsyncScanning() {
+#if 0
   model_->CompleteSafeBrowsingScan();
+#endif
   should_open_while_scanning_ = true;
 }
 
diff --git a/chrome/browser/ui/views/dropdown_bar_host_android.cc b/chrome/browser/ui/views/dropdown_bar_host_android.cc
new file mode 100644
index 000000000000..5e918e7e6dae
--- /dev/null
+++ b/chrome/browser/ui/views/dropdown_bar_host_android.cc
@@ -0,0 +1,10 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/dropdown_bar_host.h"
+
+#include "ui/views/widget/widget.h"
+
+void DropdownBarHost::SetHostViewNative(views::View* host_view) {
+}
diff --git a/chrome/browser/ui/views/find_bar_host.cc b/chrome/browser/ui/views/find_bar_host.cc
index e316230ab965..eba3fa4d0c19 100644
--- a/chrome/browser/ui/views/find_bar_host.cc
+++ b/chrome/browser/ui/views/find_bar_host.cc
@@ -67,10 +67,6 @@ bool FindBarHost::MaybeForwardKeyEventToWebpage(
   // Make sure we don't have a text field element interfering with keyboard
   // input. Otherwise Up and Down arrow key strokes get eaten. "Nom Nom Nom".
   contents->ClearFocusedElement();
-  NativeWebKeyboardEvent event(key_event);
-  contents->GetRenderViewHost()
-      ->GetWidget()
-      ->ForwardKeyboardEventWithLatencyInfo(event, *key_event.latency());
   return true;
 }
 
diff --git a/chrome/browser/ui/views/frame/browser_frame.cc b/chrome/browser/ui/views/frame/browser_frame.cc
index 0d7f5b0320d9..885fd3a0c38e 100644
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -32,6 +32,7 @@
 #include "ui/events/event_handler.h"
 #include "ui/gfx/font_list.h"
 #include "ui/native_theme/native_theme_dark_aura.h"
+#include "ui/native_theme/native_theme_android.h"
 #include "ui/views/controls/menu/menu_runner.h"
 #include "ui/views/widget/native_widget.h"
 
@@ -207,11 +208,13 @@ const ui::ThemeProvider* BrowserFrame::GetThemeProvider() const {
 }
 
 const ui::NativeTheme* BrowserFrame::GetNativeTheme() const {
+#if 0
   if (browser_view_->browser()->profile()->IsIncognitoProfile() &&
       ThemeServiceFactory::GetForProfile(browser_view_->browser()->profile())
           ->UsingDefaultTheme()) {
     return ui::NativeThemeDarkAura::instance();
   }
+#endif
   return views::Widget::GetNativeTheme();
 }
 
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc b/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
index e7812b668701..11dcb80dd51e 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
@@ -61,7 +61,6 @@ BrowserNonClientFrameView* CreateBrowserNonClientFrameView(
 #endif
   OpaqueBrowserFrameView* view =
       CreateOpaqueBrowserFrameView(frame, browser_view);
-  view->InitViews();
   return view;
 }
 
diff --git a/chrome/browser/ui/views/frame/browser_root_view.cc b/chrome/browser/ui/views/frame/browser_root_view.cc
index 000ce05d8712..831e5039f629 100644
--- a/chrome/browser/ui/views/frame/browser_root_view.cc
+++ b/chrome/browser/ui/views/frame/browser_root_view.cc
@@ -67,10 +67,14 @@ void OnFindURLMimeType(const GURL& url,
   // to do disk access.
   content::WebPluginInfo plugin;
   std::move(callback).Run(
-      url, mime_type.empty() || blink::IsSupportedMimeType(mime_type) ||
+      url, mime_type.empty() || blink::IsSupportedMimeType(mime_type)
+#if 0
+ ||
                content::PluginService::GetInstance()->GetPluginInfo(
                    process_id, routing_id, url, url::Origin(), mime_type, false,
-                   nullptr, &plugin, nullptr));
+                   nullptr, &plugin, nullptr)
+#endif
+);
 }
 
 bool GetURLForDrop(const ui::DropTargetEvent& event, GURL* url) {
diff --git a/chrome/browser/ui/views/frame/browser_view.cc b/chrome/browser/ui/views/frame/browser_view.cc
index c4b714aaf52f..e59904a292a1 100644
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -851,6 +851,7 @@ void BrowserView::OnActiveTabChanged(content::WebContents* old_contents,
                                      content::WebContents* new_contents,
                                      int index,
                                      int reason) {
+#if 0
   DCHECK(new_contents);
   TRACE_EVENT0("ui", "BrowserView::OnActiveTabChanged");
 
@@ -955,10 +956,12 @@ void BrowserView::OnActiveTabChanged(content::WebContents* old_contents,
   UpdateTitleBar();
 
   TranslateBubbleView::CloseCurrentBubble();
+#endif
 }
 
 void BrowserView::OnTabDetached(content::WebContents* contents,
                                 bool was_active) {
+#if 0
   if (was_active) {
     // We need to reset the current tab contents to null before it gets
     // freed. This is because the focus manager performs some operations
@@ -969,6 +972,7 @@ void BrowserView::OnTabDetached(content::WebContents* contents,
     app_banner_manager_observer_.RemoveAll();
     UpdateDevToolsForContents(nullptr, true);
   }
+#endif
 }
 
 void BrowserView::OnTabRestored(int command_id) {
@@ -1098,11 +1102,14 @@ void BrowserView::OnExclusiveAccessUserInput() {
 }
 
 bool BrowserView::ShouldHideUIForFullscreen() const {
+#if 0
   // Immersive mode needs UI for the slide-down top panel.
   if (immersive_mode_controller_->IsEnabled())
+#endif
     return false;
-
+#if 0
   return frame_->GetFrameView()->ShouldHideTopUIForFullscreen();
+#endif
 }
 
 bool BrowserView::IsFullscreen() const {
@@ -1178,28 +1185,36 @@ void BrowserView::SetFocusToLocationBar(bool select_all) {
 }
 
 void BrowserView::UpdateReloadStopState(bool is_loading, bool force) {
+#if 0
   if (toolbar_button_provider_->GetReloadButton()) {
     toolbar_button_provider_->GetReloadButton()->ChangeMode(
         is_loading ? ReloadButton::Mode::kStop : ReloadButton::Mode::kReload,
         force);
   }
+#endif
 }
 
 void BrowserView::UpdateToolbar(content::WebContents* contents) {
+#if 0
   // We may end up here during destruction.
   if (toolbar_)
     toolbar_->Update(contents);
+#endif
 }
 
 void BrowserView::UpdateCustomTabBarVisibility(bool visible, bool animate) {
+#if 0
   if (toolbar_)
     toolbar_->UpdateCustomTabBarVisibility(visible, animate);
+#endif
 }
 
 void BrowserView::ResetToolbarTabState(content::WebContents* contents) {
+#if 0
   // We may end up here during destruction.
   if (toolbar_)
     toolbar_->ResetTabState(contents);
+#endif
 }
 
 void BrowserView::FocusToolbar() {
@@ -1225,8 +1240,10 @@ ToolbarActionsBar* BrowserView::GetToolbarActionsBar() {
 }
 
 ExtensionsContainer* BrowserView::GetExtensionsContainer() {
+#if 0
   if (toolbar_ && toolbar_->extensions_container())
     return toolbar_->extensions_container();
+#endif
   return GetToolbarActionsBar();
 }
 
@@ -1281,6 +1298,7 @@ void BrowserView::FocusBookmarksToolbar() {
 }
 
 void BrowserView::FocusInactivePopupForAccessibility() {
+#if 0
   if (GetLocationBarView()->ActivateFirstInactiveBubbleForAccessibility())
     return;
 
@@ -1293,6 +1311,7 @@ void BrowserView::FocusInactivePopupForAccessibility() {
 
   if (!infobar_container_->children().empty())
     infobar_container_->SetPaneFocusAndFocusDefault();
+#endif
 }
 
 void BrowserView::FocusAppMenu() {
diff --git a/chrome/browser/ui/views/frame/browser_window_factory.cc b/chrome/browser/ui/views/frame/browser_window_factory.cc
index 8d53cc96cced..7cbee4f26480 100644
--- a/chrome/browser/ui/views/frame/browser_window_factory.cc
+++ b/chrome/browser/ui/views/frame/browser_window_factory.cc
@@ -20,18 +20,8 @@
 BrowserWindow* BrowserWindow::CreateBrowserWindow(
     std::unique_ptr<Browser> browser,
     bool user_gesture) {
-  // Create the view and the frame. The frame will attach itself via the view
-  // so we don't need to do anything with the pointer.
   BrowserView* view = new BrowserView(std::move(browser));
   (new BrowserFrame(view))->InitBrowserFrame();
-  view->GetWidget()->non_client_view()->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_PRODUCT_NAME));
 
-#if defined(USE_AURA)
-  // For now, all browser windows are true. This only works when USE_AURA
-  // because it requires gfx::NativeWindow to be an aura::Window*.
-  view->GetWidget()->GetNativeWindow()->SetProperty(
-      aura::client::kCreatedByUserGesture, user_gesture);
-#endif
   return view;
 }
diff --git a/chrome/browser/ui/views/frame/desktop_browser_frame_android.cc b/chrome/browser/ui/views/frame/desktop_browser_frame_android.cc
new file mode 100644
index 000000000000..6ac899f85811
--- /dev/null
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_android.cc
@@ -0,0 +1,75 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_android.h"
+
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/ui/views/frame/browser_desktop_window_tree_host.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "ui/base/hit_test.h"
+#include "ui/base/models/simple_menu_model.h"
+#include "ui/gfx/font.h"
+#include "ui/views/view.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/visibility_controller.h"
+
+using aura::Window;
+
+///////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAura, public:
+
+DesktopBrowserFrameAndroid::DesktopBrowserFrameAndroid(
+    BrowserFrame* browser_frame,
+    BrowserView* browser_view)
+    : browser_view_(browser_view),
+      browser_frame_(browser_frame) {
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, protected:
+
+DesktopBrowserFrameAndroid::~DesktopBrowserFrameAndroid() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, NativeBrowserFrame implementation:
+
+views::Widget::InitParams DesktopBrowserFrameAndroid::GetWidgetParams() {
+  views::Widget::InitParams params;
+  return params;
+}
+
+bool DesktopBrowserFrameAndroid::UseCustomFrame() const {
+  return true;
+}
+
+bool DesktopBrowserFrameAndroid::UsesNativeSystemMenu() const {
+  return true;
+}
+
+int DesktopBrowserFrameAndroid::GetMinimizeButtonOffset() const {
+  return 0;
+}
+
+bool DesktopBrowserFrameAndroid::ShouldSaveWindowPlacement() const {
+  // The placement can always be stored.
+  return true;
+}
+
+void DesktopBrowserFrameAndroid::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+  *show_state = ui::SHOW_STATE_NORMAL;
+}
+
+content::KeyboardEventProcessingResult
+DesktopBrowserFrameAndroid::PreHandleKeyboardEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  return content::KeyboardEventProcessingResult::NOT_HANDLED;
+}
+
+bool DesktopBrowserFrameAndroid::HandleKeyboardEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  return false;
+}
diff --git a/chrome/browser/ui/views/frame/desktop_browser_frame_android.h b/chrome/browser/ui/views/frame/desktop_browser_frame_android.h
new file mode 100644
index 000000000000..13391d720c91
--- /dev/null
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_android.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+#define CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "chrome/browser/ui/views/frame/native_browser_frame.h"
+#include "ui/views/context_menu_controller.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+
+class BrowserDesktopWindowTreeHost;
+class BrowserFrame;
+class BrowserView;
+
+namespace wm {
+class VisibilityController;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid
+//
+//  DesktopBrowserFrameAndroid is a DesktopNativeWidgetAndroid subclass that provides
+//  the window frame for the Chrome browser window.
+//
+class DesktopBrowserFrameAndroid : public NativeBrowserFrame {
+ public:
+  DesktopBrowserFrameAndroid(BrowserFrame* browser_frame,
+                          BrowserView* browser_view);
+
+  BrowserView* browser_view() const { return browser_view_; }
+  BrowserFrame* browser_frame() const { return browser_frame_; }
+
+ protected:
+  ~DesktopBrowserFrameAndroid() override;
+
+  // Overridden from NativeBrowserFrame:
+  views::Widget::InitParams GetWidgetParams() override;
+  bool UseCustomFrame() const override;
+  bool UsesNativeSystemMenu() const override;
+  int GetMinimizeButtonOffset() const override;
+  bool ShouldSaveWindowPlacement() const override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* show_state) const override;
+  content::KeyboardEventProcessingResult PreHandleKeyboardEvent(
+      const content::NativeWebKeyboardEvent& event) override;
+  bool HandleKeyboardEvent(
+      const content::NativeWebKeyboardEvent& event) override;
+
+ private:
+  // The BrowserView is our ClientView. This is a pointer to it.
+  BrowserView* browser_view_;
+  BrowserFrame* browser_frame_;
+
+  std::unique_ptr<wm::VisibilityController> visibility_controller_;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopBrowserFrameAndroid);
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_Android_H_
diff --git a/chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc b/chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc
new file mode 100644
index 000000000000..49b06a643ce4
--- /dev/null
+++ b/chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc
@@ -0,0 +1,13 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/native_browser_frame_factory.h"
+
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_android.h"
+
+NativeBrowserFrame* NativeBrowserFrameFactory::Create(
+    BrowserFrame* browser_frame,
+    BrowserView* browser_view) {
+  return new DesktopBrowserFrameAndroid(browser_frame, browser_view);
+}
diff --git a/chrome/browser/ui/views/javascript_dialog_views.cc b/chrome/browser/ui/views/javascript_dialog_views.cc
index 1ebb4979655b..bdb3a4ce529d 100644
--- a/chrome/browser/ui/views/javascript_dialog_views.cc
+++ b/chrome/browser/ui/views/javascript_dialog_views.cc
@@ -17,6 +17,7 @@
 JavaScriptDialogViews::~JavaScriptDialogViews() = default;
 
 // static
+#if 0
 base::WeakPtr<JavaScriptDialog> JavaScriptDialog::CreateNewDialog(
     content::WebContents* parent_web_contents,
     content::WebContents* alerting_web_contents,
@@ -32,6 +33,7 @@ base::WeakPtr<JavaScriptDialog> JavaScriptDialog::CreateNewDialog(
               std::move(dialog_force_closed_callback)))
       ->weak_factory_.GetWeakPtr();
 }
+#endif
 
 void JavaScriptDialogViews::CloseDialogWithoutCallback() {
   dialog_callback_.Reset();
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.cc b/chrome/browser/ui/views/location_bar/location_bar_view.cc
index 30a283abaa3f..6d11e88fdd06 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -362,11 +362,15 @@ void LocationBarView::SelectAll() {
 // LocationBarView, public LocationBar implementation:
 
 void LocationBarView::FocusLocation(bool is_user_initiated) {
+#if 0
   omnibox_view_->SetFocus(is_user_initiated);
+#endif
 }
 
 void LocationBarView::Revert() {
+#if 0
   omnibox_view_->RevertAll();
+#endif
 }
 
 OmniboxView* LocationBarView::GetOmniboxView() {
@@ -377,7 +381,7 @@ OmniboxView* LocationBarView::GetOmniboxView() {
 // LocationBarView, public views::View implementation:
 
 bool LocationBarView::HasFocus() const {
-  return omnibox_view_ && omnibox_view_->model()->has_focus();
+  return false;
 }
 
 void LocationBarView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
@@ -386,9 +390,12 @@ void LocationBarView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
 
 gfx::Size LocationBarView::GetMinimumSize() const {
   const int height = GetLayoutConstant(LOCATION_BAR_HEIGHT);
+#if 0
   if (!IsInitialized())
+#endif
     return gfx::Size(0, height);
 
+#if 0
   const int inset_width = GetInsets().width();
   const int padding = GetLayoutConstant(LOCATION_BAR_ELEMENT_PADDING);
   const int leading_width = GetMinimumLeadingWidth();
@@ -435,13 +442,17 @@ gfx::Size LocationBarView::CalculatePreferredSize() const {
     width += trailing_width + padding;
 
   return gfx::Size(width, height);
+#endif
 }
 
 void LocationBarView::OnKeywordFaviconFetched(const gfx::Image& icon) {
+#if 0
   selected_keyword_view_->SetImage(icon.AsImageSkia());
+#endif
 }
 
 void LocationBarView::Layout() {
+#if 0
   if (!IsInitialized())
     return;
 
@@ -609,9 +620,11 @@ void LocationBarView::Layout() {
   }
   omnibox_view_->SetBoundsRect(location_bounds);
   View::Layout();
+#endif
 }
 
 void LocationBarView::OnThemeChanged() {
+#if 0
   // ToolbarView::Init() adds |this| to the view hierarchy before initializing,
   // which will trigger an early theme change.
   if (!IsInitialized())
@@ -630,14 +643,18 @@ void LocationBarView::OnThemeChanged() {
   location_icon_view_->Update(/*suppress_animations=*/false);
   RefreshClearAllButtonIcon();
   SchedulePaint();
+#endif
 }
 
 void LocationBarView::ChildPreferredSizeChanged(views::View* child) {
+#if 0
   Layout();
   SchedulePaint();
+#endif
 }
 
 void LocationBarView::Update(const WebContents* contents) {
+#if 0
   RefreshContentSettingViews();
 
   RefreshPageActionIconViews();
@@ -655,15 +672,17 @@ void LocationBarView::Update(const WebContents* contents) {
     send_tab_to_self_icon->SetVisible(false);
 
   OnChanged();  // NOTE: Calls Layout().
+#endif
 }
 
 void LocationBarView::ResetTabState(WebContents* contents) {
+#if 0
   omnibox_view_->ResetTabState(contents);
+#endif
 }
 
 bool LocationBarView::ActivateFirstInactiveBubbleForAccessibility() {
-  return page_action_icon_container_
-      ->ActivateFirstInactiveBubbleForAccessibility();
+  return false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.h b/chrome/browser/ui/views/location_bar/location_bar_view.h
index 8bd423986232..d3157a54726b 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.h
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.h
@@ -175,7 +175,9 @@ class LocationBarView : public LocationBar,
   bool HasFocus() const override;
   void GetAccessibleNodeData(ui::AXNodeData* node_data) override;
   gfx::Size GetMinimumSize() const override;
+#if 0
   gfx::Size CalculatePreferredSize() const override;
+#endif
   void Layout() override;
   void OnThemeChanged() override;
   void ChildPreferredSizeChanged(views::View* child) override;
diff --git a/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc b/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
index 5c4e950e1fec..6db7e49b618c 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
@@ -174,7 +174,7 @@ void OmniboxPopupContentsView::OpenMatch(
 gfx::Image OmniboxPopupContentsView::GetMatchIcon(
     const AutocompleteMatch& match,
     SkColor vector_icon_color) const {
-  return model_->GetMatchIcon(match, vector_icon_color);
+  return gfx::Image();
 }
 
 void OmniboxPopupContentsView::SetSelectedLine(size_t index) {
diff --git a/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc b/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
index efb8151b6873..10a6ca709e08 100644
--- a/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
+++ b/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
@@ -70,6 +70,7 @@ void PermissionPromptBubbleView::AddPermissionRequestLine(
                          DISTANCE_SUBSECTION_HORIZONTAL_INDENT)),
       provider->GetDistanceMetric(views::DISTANCE_RELATED_LABEL_HORIZONTAL)));
 
+#if 0
   auto* icon =
       line_container->AddChildView(std::make_unique<views::ImageView>());
   const gfx::VectorIcon& vector_id = request->GetIconId();
@@ -78,6 +79,7 @@ void PermissionPromptBubbleView::AddPermissionRequestLine(
   constexpr int kPermissionIconSize = 18;
   icon->SetImage(
       gfx::CreateVectorIcon(vector_id, kPermissionIconSize, icon_color));
+#endif
 
   auto* label = line_container->AddChildView(
       std::make_unique<views::Label>(request->GetMessageTextFragment()));
diff --git a/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc b/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc
index c085aa1e4bdd..9e3fe4847ea9 100644
--- a/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc
+++ b/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc
@@ -15,6 +15,7 @@
 #include "ui/views/bubble/bubble_frame_view.h"
 
 // static
+#if 0
 std::unique_ptr<PermissionPrompt> PermissionPrompt::Create(
     content::WebContents* web_contents,
     Delegate* delegate) {
@@ -27,6 +28,7 @@ std::unique_ptr<PermissionPrompt> PermissionPrompt::Create(
   return std::make_unique<PermissionPromptImpl>(browser, web_contents,
                                                 delegate);
 }
+#endif
 
 PermissionPromptImpl::PermissionPromptImpl(Browser* browser,
                                            content::WebContents* web_contents,
diff --git a/chrome/browser/ui/views/profiles/avatar_button.cc b/chrome/browser/ui/views/profiles/avatar_button.cc
new file mode 100644
index 000000000000..dad990804bbd
--- /dev/null
+++ b/chrome/browser/ui/views/profiles/avatar_button.cc
@@ -0,0 +1,559 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/profiles/avatar_button.h"
+
+#include <memory>
+#include <utility>
+
+#include "build/build_config.h"
+#include "chrome/app/vector_icons/vector_icons.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/profiles/profiles_state.h"
+#include "chrome/browser/signin/account_consistency_mode_manager.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/browser/themes/theme_properties.h"
+#include "chrome/browser/themes/theme_service.h"
+#include "chrome/browser/themes/theme_service_factory.h"
+#include "chrome/browser/ui/views/frame/avatar_button_manager.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/browser/ui/views/profiles/profile_chooser_view.h"
+#include "chrome/grit/generated_resources.h"
+#include "chrome/grit/theme_resources.h"
+#include "components/keyed_service/content/browser_context_keyed_service_shutdown_notifier_factory.h"
+#include "components/signin/core/browser/signin_manager.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/base/theme_provider.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/color_palette.h"
+#include "ui/gfx/color_utils.h"
+#include "ui/gfx/paint_vector_icon.h"
+#include "ui/views/animation/flood_fill_ink_drop_ripple.h"
+#include "ui/views/animation/ink_drop_impl.h"
+#include "ui/views/animation/ink_drop_mask.h"
+#include "ui/views/controls/button/label_button_border.h"
+
+#if defined(OS_WIN)
+#include "base/win/windows_version.h"
+#include "chrome/browser/ui/views/frame/minimize_button_metrics_win.h"
+#endif
+
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+#include "chrome/browser/ui/views/nav_button_provider.h"
+#endif
+
+namespace {
+
+#if 0
+constexpr int kGenericAvatarIconSize = 16;
+#endif
+
+// TODO(emx): Calculate width based on caption button [http://crbug.com/716365]
+constexpr int kCondensibleButtonMinWidth = 46;
+// TODO(emx): Should this be calculated based on average character width?
+constexpr int kCondensibleButtonMaxWidth = 98;
+
+#if defined(OS_WIN)
+constexpr gfx::Insets kBorderInsets(2, 8, 4, 8);
+
+std::unique_ptr<views::Border> CreateThemedBorder(
+    const int normal_image_set[],
+    const int hot_image_set[],
+    const int pushed_image_set[]) {
+  std::unique_ptr<views::LabelButtonAssetBorder> border(
+      new views::LabelButtonAssetBorder(views::Button::STYLE_TEXTBUTTON));
+
+  border->SetPainter(false, views::Button::STATE_NORMAL,
+                     views::Painter::CreateImageGridPainter(normal_image_set));
+  border->SetPainter(false, views::Button::STATE_HOVERED,
+                     views::Painter::CreateImageGridPainter(hot_image_set));
+  border->SetPainter(false, views::Button::STATE_PRESSED,
+                     views::Painter::CreateImageGridPainter(pushed_image_set));
+
+  border->set_insets(kBorderInsets);
+
+  return std::move(border);
+}
+#endif
+
+#if defined(OS_MACOSX)
+constexpr int kMacButtonHeight = 24;
+#endif
+
+// This class draws the border (and background) of the avatar button for
+// "themed" browser windows, i.e. OpaqueBrowserFrameView. Currently it's only
+// used on Linux as the shape specifically matches the Linux caption buttons.
+// TODO(estade): make this look nice on Windows and use it there as well.
+class AvatarButtonThemedBorder : public views::Border {
+ public:
+  AvatarButtonThemedBorder() {}
+  ~AvatarButtonThemedBorder() override {}
+
+  void Paint(const views::View& view, gfx::Canvas* canvas) override {
+    // Fill the color/background image from the theme.
+    cc::PaintFlags fill_flags;
+    fill_flags.setAntiAlias(true);
+    const ui::ThemeProvider* theme = view.GetThemeProvider();
+    fill_flags.setColor(
+        theme->GetColor(ThemeProperties::COLOR_BUTTON_BACKGROUND));
+    SkPath fill_path;
+    gfx::Rect fill_bounds = view.GetLocalBounds();
+    // The fill should overlap the inner stroke but not the outer stroke. But we
+    // don't inset the top because as it stands, the asset-based window controls
+    // fill one pixel higher due to how the background masking works out. Not
+    // matching that is very noticeable. TODO(estade): when the window
+    // controls use this same code, inset all sides equally.
+    fill_bounds.Inset(gfx::Insets(0, kStrokeWidth, kStrokeWidth, kStrokeWidth));
+    fill_path.addRoundRect(gfx::RectToSkRect(fill_bounds), kCornerRadius,
+                           kCornerRadius);
+    canvas->DrawPath(fill_path, fill_flags);
+    fill_flags.setColor(SK_ColorBLACK);
+    canvas->DrawImageInPath(
+        *theme->GetImageSkiaNamed(IDR_THEME_WINDOW_CONTROL_BACKGROUND), 0, 0,
+        fill_path, fill_flags);
+
+    // Paint an outer dark stroke.
+    cc::PaintFlags stroke_flags;
+    stroke_flags.setStyle(cc::PaintFlags::kStroke_Style);
+    // The colors are chosen to match the assets we use for Linux.
+    stroke_flags.setColor(SkColorSetA(SK_ColorBLACK, 0x2B));
+    stroke_flags.setStrokeWidth(kStrokeWidth);
+    stroke_flags.setAntiAlias(true);
+    gfx::RectF stroke_bounds(view.GetLocalBounds());
+    stroke_bounds.Inset(gfx::InsetsF(0.5f));
+    canvas->DrawRoundRect(stroke_bounds, kCornerRadius, stroke_flags);
+
+    // There's a second, light stroke that matches the fill bounds.
+    stroke_bounds.Inset(gfx::InsetsF(kStrokeWidth));
+    stroke_flags.setColor(SkColorSetA(SK_ColorWHITE, 0x3F));
+    canvas->DrawRoundRect(stroke_bounds, kCornerRadius, stroke_flags);
+  }
+
+  gfx::Insets GetInsets() const override {
+    auto insets = views::LabelButtonAssetBorder::GetDefaultInsetsForStyle(
+        views::Button::STYLE_TEXTBUTTON);
+    return kBorderStrokeInsets +
+           gfx::Insets(0, insets.left(), 0, insets.right());
+  }
+
+  gfx::Size GetMinimumSize() const override {
+    return gfx::Size(GetInsets().width(), GetInsets().height());
+  }
+
+  static std::unique_ptr<views::InkDropMask> CreateInkDropMask(
+      const gfx::Size& size) {
+    return std::make_unique<views::RoundRectInkDropMask>(
+        size, kBorderStrokeInsets, kCornerRadius);
+  }
+
+ private:
+  static constexpr int kStrokeWidth = 1;
+
+  // Insets between view bounds and the interior of the strokes.
+  static constexpr gfx::Insets kBorderStrokeInsets{kStrokeWidth * 2};
+
+  // Corner radius of the roundrect.
+  static constexpr float kCornerRadius = 1;
+
+  DISALLOW_COPY_AND_ASSIGN(AvatarButtonThemedBorder);
+};
+
+constexpr int AvatarButtonThemedBorder::kStrokeWidth;
+constexpr gfx::Insets AvatarButtonThemedBorder::kBorderStrokeInsets;
+constexpr float AvatarButtonThemedBorder::kCornerRadius;
+
+class AvatarButtonShutdownNotifierFactory
+    : public BrowserContextKeyedServiceShutdownNotifierFactory {
+ public:
+  static AvatarButtonShutdownNotifierFactory* GetInstance() {
+    return base::Singleton<AvatarButtonShutdownNotifierFactory>::get();
+  }
+
+ private:
+  friend struct base::DefaultSingletonTraits<
+      AvatarButtonShutdownNotifierFactory>;
+
+  AvatarButtonShutdownNotifierFactory()
+      : BrowserContextKeyedServiceShutdownNotifierFactory(
+            "AvatarButtonShutdownNotifierFactory") {
+    DependsOn(SigninManagerFactory::GetInstance());
+  }
+  ~AvatarButtonShutdownNotifierFactory() override {}
+
+  DISALLOW_COPY_AND_ASSIGN(AvatarButtonShutdownNotifierFactory);
+};
+
+#if defined(OS_WIN) || defined(OS_MACOSX)
+SkColor BaseColorForButton(const ui::ThemeProvider* theme_provider) {
+  return color_utils::IsDark(
+             theme_provider->GetColor(ThemeProperties::COLOR_FRAME))
+             ? SK_ColorWHITE
+             : SK_ColorBLACK;
+}
+
+gfx::ImageSkia AvatarIconWithBaseColor(const SkColor base_color) {
+  const SkColor icon_color =
+      SkColorSetA(base_color, static_cast<SkAlpha>(0.54 * 0xFF));
+  return gfx::CreateVectorIcon(kAccountCircleIcon, kGenericAvatarIconSize,
+                               icon_color);
+}
+#endif
+
+}  // namespace
+
+AvatarButton::AvatarButton(views::MenuButtonListener* listener,
+                           AvatarButtonStyle button_style,
+                           Profile* profile,
+                           AvatarButtonManager* manager)
+    : MenuButton(base::string16(), listener, false),
+      error_controller_(this, profile),
+      profile_(profile),
+      profile_observer_(this),
+      button_style_(button_style),
+      widget_observer_(this) {
+  DCHECK_NE(button_style, AvatarButtonStyle::NONE);
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+  views::NavButtonProvider* nav_button_provider =
+      manager->get_nav_button_provider();
+  render_native_nav_buttons_ = nav_button_provider != nullptr;
+#endif
+  set_notify_action(Button::NOTIFY_ON_PRESS);
+  set_triggerable_event_flags(ui::EF_LEFT_MOUSE_BUTTON |
+                              ui::EF_RIGHT_MOUSE_BUTTON);
+  set_animate_on_state_change(false);
+#if !defined(OS_MACOSX)
+  SetEnabledTextColors(SK_ColorWHITE);
+  SetTextSubpixelRenderingEnabled(false);
+#endif
+  SetHorizontalAlignment(gfx::ALIGN_CENTER);
+
+  profile_observer_.Add(
+      &g_browser_process->profile_manager()->GetProfileAttributesStorage());
+
+  // The largest text height that fits in the button. If the font list height
+  // is larger than this, it will be shrunk to match it.
+  // TODO(noms): Calculate this constant algorithmically from the button's size.
+  const int kDisplayFontHeight = 16;
+  label()->SetFontList(
+      label()->font_list().DeriveWithHeightUpperBound(kDisplayFontHeight));
+
+  bool apply_ink_drop = ShouldApplyInkDrop();
+  if (render_native_nav_buttons_) {
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+    SetBackground(nav_button_provider->CreateAvatarButtonBackground(this));
+    SetBorder(nullptr);
+    generic_avatar_ =
+        gfx::CreateVectorIcon(kProfileSwitcherOutlineIcon,
+                              kGenericAvatarIconSize, gfx::kChromeIconGrey);
+#endif
+  } else if (apply_ink_drop) {
+    SetInkDropMode(InkDropMode::ON);
+    SetFocusPainter(nullptr);
+#if defined(OS_LINUX)
+    set_ink_drop_base_color(SK_ColorWHITE);
+    SetBorder(std::make_unique<AvatarButtonThemedBorder>());
+    generic_avatar_ =
+        gfx::CreateVectorIcon(kProfileSwitcherOutlineIcon,
+                              kGenericAvatarIconSize, gfx::kChromeIconGrey);
+#elif defined(OS_WIN)
+    DCHECK_EQ(AvatarButtonStyle::NATIVE, button_style);
+    SetBorder(views::CreateEmptyBorder(kBorderInsets));
+  } else if (button_style == AvatarButtonStyle::THEMED) {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_THEMED_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+  } else if (base::win::GetVersion() < base::win::VERSION_WIN8) {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_GLASS_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+  } else {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_NATIVE_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+#endif
+  }
+
+  profile_shutdown_notifier_ =
+      AvatarButtonShutdownNotifierFactory::GetInstance()
+          ->Get(profile_)
+          ->Subscribe(base::Bind(&AvatarButton::OnProfileShutdown,
+                                 base::Unretained(this)));
+}
+
+AvatarButton::~AvatarButton() {}
+
+void AvatarButton::SetupThemeColorButton() {
+#if defined(OS_WIN)
+  if (IsCondensible()) {
+    // TODO(bsep): This needs to also be called when the Windows accent color
+    // updates, but there is currently no signal for that.
+    const SkColor base_color = BaseColorForButton(GetThemeProvider());
+    set_ink_drop_base_color(base_color);
+    generic_avatar_ = AvatarIconWithBaseColor(base_color);
+  }
+#elif defined(OS_MACOSX)
+  const SkColor base_color = BaseColorForButton(GetThemeProvider());
+  SetEnabledTextColors(base_color);
+  generic_avatar_ = AvatarIconWithBaseColor(base_color);
+#endif
+}
+
+void AvatarButton::OnAvatarButtonPressed(const ui::Event* event) {
+  views::Widget* bubble_widget = ProfileChooserView::GetCurrentBubbleWidget();
+  if (bubble_widget && !widget_observer_.IsObserving(bubble_widget)) {
+    widget_observer_.Add(bubble_widget);
+    pressed_lock_ = std::make_unique<PressedLock>(
+        this, false, ui::LocatedEvent::FromIfValid(event));
+  }
+}
+
+void AvatarButton::AddedToWidget() {
+  SetupThemeColorButton();
+  Update();
+}
+
+void AvatarButton::OnGestureEvent(ui::GestureEvent* event) {
+  // TODO(wjmaclean): The check for ET_GESTURE_LONG_PRESS is done here since
+  // no other UI button based on Button appears to handle mouse
+  // right-click. If other cases are identified, it may make sense to move this
+  // check to Button.
+  if (event->type() == ui::ET_GESTURE_LONG_PRESS)
+    NotifyClick(*event);
+  else
+    MenuButton::OnGestureEvent(event);
+}
+
+gfx::Size AvatarButton::GetMinimumSize() const {
+  if (IsCondensible()) {
+    // Returns the size of the button when it is atop the tabstrip. Called by
+    // GlassBrowserFrameView::LayoutProfileSwitcher().
+    // TODO(emx): Calculate the height based on the top of the new tab button.
+    return gfx::Size(kCondensibleButtonMinWidth, 20);
+  }
+
+  return MenuButton::GetMinimumSize();
+}
+
+gfx::Size AvatarButton::CalculatePreferredSize() const {
+  if (render_native_nav_buttons_)
+    return MenuButton::CalculatePreferredSize();
+
+  // TODO(estade): Calculate the height instead of hardcoding to 20 for the
+  // not-condensible case.
+  gfx::Size size(MenuButton::CalculatePreferredSize().width(), 20);
+
+  if (IsCondensible()) {
+    // Returns the normal size of the button (when it does not overlap the
+    // tabstrip).
+    size.set_width(std::min(std::max(size.width(), kCondensibleButtonMinWidth),
+                            kCondensibleButtonMaxWidth));
+#if defined(OS_WIN)
+    size.set_height(MinimizeButtonMetrics::GetCaptionButtonHeightInDIPs());
+#endif
+  }
+#if defined(OS_MACOSX)
+  size.set_height(kMacButtonHeight);
+#endif
+  return size;
+}
+
+std::unique_ptr<views::InkDropMask> AvatarButton::CreateInkDropMask() const {
+#if defined(OS_MACOSX)
+  // On Mac, this looks and behaves like a regular MD button, so we need a hover
+  // background.
+  // TODO (lgrey): Determine and set the correct insets.
+  constexpr int kHoverCornerRadius = 2;
+  return std::make_unique<views::RoundRectInkDropMask>(size(), gfx::Insets(),
+                                                       kHoverCornerRadius);
+#else
+  if (button_style_ == AvatarButtonStyle::THEMED)
+    return AvatarButtonThemedBorder::CreateInkDropMask(size());
+  return MenuButton::CreateInkDropMask();
+#endif
+}
+
+std::unique_ptr<views::InkDropHighlight> AvatarButton::CreateInkDropHighlight()
+    const {
+  if (button_style_ == AvatarButtonStyle::THEMED)
+    return MenuButton::CreateInkDropHighlight();
+
+  auto ink_drop_highlight = std::make_unique<views::InkDropHighlight>(
+      size(), 0, gfx::RectF(GetLocalBounds()).CenterPoint(),
+      GetInkDropBaseColor());
+  constexpr float kInkDropHighlightOpacity = 0.08f;
+  ink_drop_highlight->set_visible_opacity(kInkDropHighlightOpacity);
+  return ink_drop_highlight;
+}
+
+SkColor AvatarButton::GetInkDropBaseColor() const {
+#if defined(OS_MACOSX)
+  return GetThemeProvider()->GetColor(
+      ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON);
+#else
+  return MenuButton::GetInkDropBaseColor();
+#endif
+}
+
+bool AvatarButton::ShouldEnterPushedState(const ui::Event& event) {
+  if (ProfileChooserView::IsShowing())
+    return false;
+
+  return MenuButton::ShouldEnterPushedState(event);
+}
+
+bool AvatarButton::ShouldUseFloodFillInkDrop() const {
+  return true;
+}
+
+void AvatarButton::OnAvatarErrorChanged() {
+  Update();
+}
+
+void AvatarButton::OnProfileAdded(const base::FilePath& profile_path) {
+  Update();
+}
+
+void AvatarButton::OnProfileWasRemoved(const base::FilePath& profile_path,
+                                       const base::string16& profile_name) {
+  // If deleting the active profile, don't bother updating the avatar
+  // button, as the browser window is being closed anyway.
+  if (profile_->GetPath() != profile_path)
+    Update();
+}
+
+void AvatarButton::OnProfileNameChanged(
+    const base::FilePath& profile_path,
+    const base::string16& old_profile_name) {
+  if (profile_->GetPath() == profile_path)
+    Update();
+}
+
+void AvatarButton::OnProfileSupervisedUserIdChanged(
+    const base::FilePath& profile_path) {
+  if (profile_->GetPath() == profile_path)
+    Update();
+}
+
+void AvatarButton::OnWidgetDestroying(views::Widget* widget) {
+  pressed_lock_.reset();
+  if (render_native_nav_buttons_)
+    SchedulePaint();
+  widget_observer_.Remove(widget);
+}
+
+void AvatarButton::OnProfileShutdown() {
+  // It looks like in some mysterious cases, the AvatarButton outlives the
+  // profile (see http://crbug.com/id=579690). The avatar button is owned by
+  // the browser frame (which is owned by the BrowserWindow), and there is an
+  // expectation for the UI to be destroyed before the profile is destroyed.
+  CHECK(false) << "Avatar button must not outlive the profile.";
+}
+
+void AvatarButton::Update() {
+  // It looks like in some mysterious cases, the AvatarButton outlives the
+  // profile manager (see http://crbug.com/id=579690). The avatar button is
+  // owned by the browser frame (which is owned by the BrowserWindow), and
+  // there is an expectation for the UI to be destroyed before the profile
+  // manager is destroyed.
+  CHECK(g_browser_process->profile_manager())
+      << "Avatar button must not outlive the profile manager";
+
+  ProfileAttributesStorage& storage =
+      g_browser_process->profile_manager()->GetProfileAttributesStorage();
+
+  // If we have a single local profile, then use the generic avatar
+  // button instead of the profile name. Never use the generic button if
+  // the active profile is Guest.
+  const bool use_generic_button =
+      !profile_->IsGuestSession() && storage.GetNumberOfProfiles() == 1 &&
+      !SigninManagerFactory::GetForProfile(profile_)->IsAuthenticated();
+
+  // Always set the accessible name as accessible text, but don't display it if
+  // is just a generic button.
+  base::string16 name =
+      use_generic_button
+          ? l10n_util::GetStringUTF16(IDS_GENERIC_USER_AVATAR_LABEL)
+          : profiles::GetAvatarButtonTextForProfile(profile_);
+  if (use_generic_button) {
+    SetText(base::string16());
+    SetAccessibleName(name);  // Must be set after setting text to override it.
+  } else {
+    SetText(name);
+  }
+
+#if !defined(OS_MACOSX)
+  // If the button has no text, clear the text shadows to make sure the
+  // image is centered correctly. macOS doesn't use a shadow.
+  SetTextShadows(
+      use_generic_button
+          ? gfx::ShadowValues()
+          : gfx::ShadowValues(
+                10, gfx::ShadowValue(gfx::Vector2d(), 2.0f, SK_ColorDKGRAY)));
+#endif
+
+  if (use_generic_button) {
+    SetImage(views::Button::STATE_NORMAL, generic_avatar_);
+  } else if (profile_->IsSyncAllowed() && error_controller_.HasAvatarError()) {
+    // When DICE is enabled and the error is an auth error, the sync-paused icon
+    // is shown.
+    int dummy;
+    const bool should_show_sync_paused_ui =
+        AccountConsistencyModeManager::IsDiceEnabledForProfile(profile_) &&
+        sync_ui_util::GetMessagesForAvatarSyncError(
+            profile_, *SigninManagerFactory::GetForProfile(profile_), &dummy,
+            &dummy) == sync_ui_util::AUTH_ERROR;
+    SetImage(
+        views::Button::STATE_NORMAL,
+        should_show_sync_paused_ui
+            ? gfx::CreateVectorIcon(kSyncPausedIcon, 16, gfx::kGoogleBlue500)
+            : gfx::CreateVectorIcon(kSyncProblemIcon, 16, gfx::kGoogleRed700));
+  } else {
+    SetImage(views::Button::STATE_NORMAL, gfx::ImageSkia());
+  }
+
+  // If we are not using the generic button, then reset the spacing between
+  // the text and the possible authentication error icon.
+  const int kDefaultImageTextSpacing = 5;
+  SetImageLabelSpacing(use_generic_button ? 0 : kDefaultImageTextSpacing);
+
+  PreferredSizeChanged();
+}
+
+void AvatarButton::SetButtonAvatar(int avatar_idr) {
+  ui::ResourceBundle* rb = &ui::ResourceBundle::GetSharedInstance();
+  generic_avatar_ = *rb->GetImageNamed(avatar_idr).ToImageSkia();
+}
+
+// TODO(estade): all versions of this button should condense.
+bool AvatarButton::IsCondensible() const {
+#if defined(OS_WIN)
+  return (base::win::GetVersion() >= base::win::VERSION_WIN10) &&
+         button_style_ == AvatarButtonStyle::NATIVE;
+#else
+  return false;
+#endif
+}
+bool AvatarButton::ShouldApplyInkDrop() const {
+#if defined(OS_LINUX)
+  DCHECK_EQ(AvatarButtonStyle::THEMED, button_style_);
+  return true;
+#elif defined(OS_MACOSX)
+  return true;
+#else
+  if (render_native_nav_buttons_)
+    return false;
+  return IsCondensible();
+#endif
+}
diff --git a/chrome/browser/ui/views/profiles/profile_menu_view.cc b/chrome/browser/ui/views/profiles/profile_menu_view.cc
index 3c714bfb47b3..6c93f2d86511 100644
--- a/chrome/browser/ui/views/profiles/profile_menu_view.cc
+++ b/chrome/browser/ui/views/profiles/profile_menu_view.cc
@@ -257,8 +257,10 @@ void ProfileMenuView::OnPasswordsButtonClicked() {
   // TODO(crbug.com/995757): Remove user action.
   base::RecordAction(
       base::UserMetricsAction("ProfileChooser_PasswordsClicked"));
+#if 0
   NavigateToManagePasswordsPage(
       browser(), password_manager::ManagePasswordsReferrer::kProfileChooser);
+#endif
 }
 
 void ProfileMenuView::OnCreditCardsButtonClicked() {
diff --git a/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc b/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc
index f314c2f86a0e..48fdf2ee1d43 100644
--- a/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc
+++ b/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc
@@ -305,5 +305,7 @@ void RelaunchNotificationController::Close() {
 }
 
 void RelaunchNotificationController::OnRelaunchDeadlineExpired() {
+#if 0
   chrome::RelaunchIgnoreUnloadHandlers();
+#endif
 }
diff --git a/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc b/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
index 48b7c642b682..7806dffd904e 100644
--- a/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
+++ b/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
@@ -30,6 +30,7 @@ using views::BoxLayout;
 namespace {
 
 // Fixed height of the illustration shown on the top of the dialog.
+#if 0
 constexpr int kSafeBrowsingIllustrationHeight = 148;
 
 // Fixed background color of the illustration shown on the top of the dialog in
@@ -108,6 +109,7 @@ base::string16 GetOkButtonLabel(
       return l10n_util::GetStringUTF16(IDS_PAGE_INFO_PROTECT_ACCOUNT_BUTTON);
   }
 }
+#endif
 
 }  // namespace
 
@@ -137,6 +139,7 @@ PasswordReuseModalWarningDialog::PasswordReuseModalWarningDialog(
       service_(service),
       url_(web_contents->GetLastCommittedURL()),
       password_type_(password_type) {
+#if 0
   DialogDelegate::set_button_label(ui::DIALOG_BUTTON_OK,
                                    GetOkButtonLabel(password_type_));
   DialogDelegate::set_button_label(
@@ -165,13 +168,17 @@ PasswordReuseModalWarningDialog::PasswordReuseModalWarningDialog(
             : l10n_util::GetStringUTF16(IDS_PAGE_INFO_CHANGE_PASSWORD_DETAILS));
     CreateGaiaPasswordReuseModalWarningDialog(message_body_label);
   }
+#endif
 }
 
 PasswordReuseModalWarningDialog::~PasswordReuseModalWarningDialog() {
+#if 0
   if (service_)
     service_->RemoveObserver(this);
+#endif
 }
 
+#if 0
 void PasswordReuseModalWarningDialog::
     CreateSavedPasswordReuseModalWarningDialog(
         const base::string16 message_body,
@@ -221,6 +228,7 @@ void PasswordReuseModalWarningDialog::CreateGaiaPasswordReuseModalWarningDialog(
   }
   AddChildView(message_body_label);
 }
+#endif
 
 gfx::Size PasswordReuseModalWarningDialog::CalculatePreferredSize() const {
   constexpr int kDialogWidth = 400;
diff --git a/chrome/browser/ui/views/tabs/tab_strip.cc b/chrome/browser/ui/views/tabs/tab_strip.cc
index 6c808792ca0a..842740e3216f 100644
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -131,21 +131,9 @@ class TabHoverCardEventSniffer : public ui::EventHandler {
       : hover_card_(hover_card),
         tab_strip_(tab_strip),
         widget_(tab_strip->GetWidget()) {
-#if defined(OS_MACOSX)
-    if (widget_->GetRootView())
-      widget_->GetRootView()->AddPreTargetHandler(this);
-#else
-    if (widget_->GetNativeWindow())
-      widget_->GetNativeWindow()->AddPreTargetHandler(this);
-#endif
   }
 
   ~TabHoverCardEventSniffer() override {
-#if defined(OS_MACOSX)
-    widget_->GetRootView()->RemovePreTargetHandler(this);
-#else
-    widget_->GetNativeWindow()->RemovePreTargetHandler(this);
-#endif
   }
 
  protected:
diff --git a/chrome/browser/ui/views/tabs/window_finder_android.cc b/chrome/browser/ui/views/tabs/window_finder_android.cc
new file mode 100644
index 000000000000..e387278647d9
--- /dev/null
+++ b/chrome/browser/ui/views/tabs/window_finder_android.cc
@@ -0,0 +1,15 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/tabs/window_finder.h"
+
+#include "base/stl_util.h"
+#include "ui/display/screen.h"
+#include "ui/views/widget/widget.h"
+
+gfx::NativeWindow WindowFinder::GetLocalProcessWindowAtPoint(
+    const gfx::Point& screen_point,
+    const std::set<gfx::NativeWindow>& ignore) {
+  return nullptr;
+}
diff --git a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
index f7b987878c46..fbf3cf242b82 100644
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -434,6 +434,8 @@ WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,
     return &NewWebUI<UserActionsUI>;
   if (url.host_piece() == chrome::kChromeUIVersionHost)
     return &NewWebUI<VersionUI>;
+  if (url.host_piece() == chrome::kChromeUIExtensionsHost)
+    return &NewWebUI<extensions::ExtensionsUI>;
 
 #if !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
diff --git a/chrome/browser/ui/webui/devtools_ui_data_source.cc b/chrome/browser/ui/webui/devtools_ui_data_source.cc
index 0cfe18bc0cb1..e7d45dda69a6 100644
--- a/chrome/browser/ui/webui/devtools_ui_data_source.cc
+++ b/chrome/browser/ui/webui/devtools_ui_data_source.cc
@@ -186,6 +186,7 @@ bool DevToolsDataSource::ShouldServeMimeTypeAsContentTypeHeader() {
 void DevToolsDataSource::StartBundledDataRequest(
     const std::string& path,
     content::URLDataSource::GotDataCallback callback) {
+#if 0
   scoped_refptr<base::RefCountedMemory> bytes =
       content::DevToolsFrontendHost::GetFrontendResourceBytes(path);
 
@@ -194,6 +195,7 @@ void DevToolsDataSource::StartBundledDataRequest(
       << ". If you compiled with debug_devtools=1, try running with "
          "--debug-devtools.";
   std::move(callback).Run(bytes);
+#endif
 }
 
 void DevToolsDataSource::StartRemoteDataRequest(
diff --git a/chrome/browser/ui/webui/discards/BUILD.gn b/chrome/browser/ui/webui/discards/BUILD.gn
index cf71fc8ea10a..a3d581e4fecb 100644
--- a/chrome/browser/ui/webui/discards/BUILD.gn
+++ b/chrome/browser/ui/webui/discards/BUILD.gn
@@ -4,7 +4,7 @@
 
 import("//mojo/public/tools/bindings/mojom.gni")
 
-if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
   mojom("mojo_bindings") {
     sources = [
       "discards.mojom",
diff --git a/chrome/browser/ui/webui/media_router/media_router_ui.cc b/chrome/browser/ui/webui/media_router/media_router_ui.cc
new file mode 100644
index 000000000000..e2f3af9e14a8
--- /dev/null
+++ b/chrome/browser/ui/webui/media_router/media_router_ui.cc
@@ -0,0 +1,716 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/webui/media_router/media_router_ui.h"
+
+#include <algorithm>
+#include <string>
+#include <unordered_map>
+#include <utility>
+
+#include "base/guid.h"
+#include "base/macros.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/trace_event/trace_event.h"
+#include "build/build_config.h"
+#include "chrome/browser/media/router/issue_manager.h"
+#include "chrome/browser/media/router/issues_observer.h"
+#include "chrome/browser/media/router/media_router.h"
+#include "chrome/browser/media/router/media_router_factory.h"
+#include "chrome/browser/media/router/media_router_metrics.h"
+#include "chrome/browser/media/router/media_sinks_observer.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/sessions/session_tab_helper.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/browser_navigator.h"
+#include "chrome/browser/ui/browser_navigator_params.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/media_router/media_router_ui_helper.h"
+#include "chrome/browser/ui/webui/media_router/media_router_localized_strings_provider.h"
+#include "chrome/browser/ui/webui/media_router/media_router_resources_provider.h"
+#include "chrome/browser/ui/webui/media_router/media_router_webui_message_handler.h"
+#include "chrome/common/chrome_features.h"
+#include "chrome/common/media_router/issue.h"
+#include "chrome/common/media_router/media_route.h"
+#include "chrome/common/media_router/media_sink.h"
+#include "chrome/common/media_router/media_source.h"
+#include "chrome/common/media_router/media_source_helper.h"
+#include "chrome/common/pref_names.h"
+#include "chrome/common/url_constants.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/prefs/pref_service.h"
+#include "components/prefs/scoped_user_pref_update.h"
+#include "content/public/browser/navigation_handle.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/browser/web_ui.h"
+#include "content/public/browser/web_ui_data_source.h"
+#include "content/public/common/fullscreen_video_element.mojom.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/constants.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+#include "third_party/blink/public/common/associated_interfaces/associated_interface_provider.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/web_dialogs/web_dialog_delegate.h"
+#include "url/origin.h"
+
+#if !defined(OS_MACOSX) || BUILDFLAG(MAC_VIEWS_BROWSER)
+#include "chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.h"
+#include "ui/display/display.h"
+#endif
+
+namespace media_router {
+
+// This class calls to refresh the UI when the highest priority issue is
+// updated.
+class MediaRouterUI::UIIssuesObserver : public IssuesObserver {
+ public:
+  UIIssuesObserver(IssueManager* issue_manager, MediaRouterUI* ui)
+      : IssuesObserver(issue_manager), ui_(ui) {
+    DCHECK(ui);
+  }
+
+  ~UIIssuesObserver() override {}
+
+  // IssuesObserver implementation.
+  void OnIssue(const Issue& issue) override { ui_->SetIssue(issue); }
+  void OnIssuesCleared() override { ui_->ClearIssue(); }
+
+ private:
+  // Reference back to the owning MediaRouterUI instance.
+  MediaRouterUI* ui_;
+
+  DISALLOW_COPY_AND_ASSIGN(UIIssuesObserver);
+};
+
+// Observes a WebContents and requests fullscreening of its first
+// video element.  The request is sent after the WebContents is loaded and tab
+// capture has begun. Marked final to prevent inheritance so delete calls are
+// contained to scenarios documented below.
+class MediaRouterUI::WebContentsFullscreenOnLoadedObserver final
+    : public content::WebContentsObserver {
+ public:
+  WebContentsFullscreenOnLoadedObserver(const GURL& file_url,
+                                        content::WebContents* web_contents)
+      : file_url_(file_url), capture_poll_timer_(false, false) {
+    DCHECK(file_url_.SchemeIsFile());
+    DCHECK(fullscreen_request_time_.is_null());
+
+    // If the WebContents is loading, start listening, otherwise just call the
+    // fullscreen function.
+
+    // This class destroys itself in the following situations (at least one of
+    // which will occur):
+    //   * after loading is complete and,
+    //   ** capture has begun and fullscreen requested,
+    //   ** kMaxSecondsToWaitForCapture seconds have passed without capture,
+    //   * another navigation is started,
+    //   * the WebContents is destroyed.
+    if (web_contents->IsLoading()) {
+      Observe(web_contents);
+    } else {
+      FullScreenFirstVideoElement(web_contents);
+    }
+  }
+  ~WebContentsFullscreenOnLoadedObserver() override {}
+
+  // content::WebContentsObserver implementation.
+  void DidStopLoading() override {
+    FullScreenFirstVideoElement(web_contents());
+  }
+
+  void DidStartNavigation(
+      content::NavigationHandle* navigation_handle) override {
+    // If the user takes over and navigates away from the file, stop listening.
+    // (It is possible however for this listener to be created before the
+    // navigation to the requested file triggers, so provided we're still on the
+    // same URL, go ahead and keep listening).
+    if (file_url_ != navigation_handle->GetURL()) {
+      delete this;
+    }
+  }
+
+  void WebContentsDestroyed() override {
+    // If the WebContents is destroyed we will never trigger and need to clean
+    // up.
+    delete this;
+  }
+
+ private:
+  const GURL file_url_;
+
+  // Time intervals used by the logic that detects if capture has started.
+  const int kMaxSecondsToWaitForCapture = 10;
+  const int kPollIntervalInSeconds = 1;
+
+  // The time at which fullscreen was requested.
+  base::TimeTicks fullscreen_request_time_;
+
+  // Poll timer to monitor the capturer count when fullscreening local files.
+  //
+  // TODO(crbug.com/540965): Add a method to WebContentsObserver to report
+  // capturer count changes and get rid of this polling-based approach.
+  base::Timer capture_poll_timer_;
+
+  // Sends a request for full screen to the WebContents targeted at the first
+  // video element.  The request is only sent after capture has begun.
+  void FullScreenFirstVideoElement(content::WebContents* web_contents) {
+    if (file_url_ != web_contents->GetLastCommittedURL()) {
+      // The user has navigated before the casting started. Do not attempt to
+      // fullscreen and cleanup.
+      return;
+    }
+
+    fullscreen_request_time_ = base::TimeTicks::Now();
+    FullscreenIfContentCaptured(web_contents);
+  }
+
+  void FullscreenIfContentCaptured(content::WebContents* web_contents) {
+    if (web_contents->IsBeingCaptured()) {
+      content::mojom::FullscreenVideoElementHandlerAssociatedPtr client;
+      web_contents->GetMainFrame()
+          ->GetRemoteAssociatedInterfaces()
+          ->GetInterface(&client);
+      client->RequestFullscreenVideoElement();
+      delete this;
+      return;
+    } else if (base::TimeTicks::Now() - fullscreen_request_time_ >
+               base::TimeDelta::FromSeconds(kMaxSecondsToWaitForCapture)) {
+      // If content capture hasn't started within the timeout skip fullscreen.
+      DLOG(WARNING) << "Capture of local content did not start within timeout";
+      delete this;
+      return;
+    }
+
+    capture_poll_timer_.Start(
+        FROM_HERE, base::TimeDelta::FromSeconds(kPollIntervalInSeconds),
+        base::BindRepeating(
+            &WebContentsFullscreenOnLoadedObserver::FullscreenIfContentCaptured,
+            base::Unretained(this), web_contents));
+  }
+};
+
+MediaRouterUI::MediaRouterUI(content::WebUI* web_ui)
+    : ConstrainedWebDialogUI(web_ui),
+      ui_initialized_(false),
+      weak_factory_(this) {
+  auto handler = std::make_unique<MediaRouterWebUIMessageHandler>(this);
+  handler_ = handler.get();
+
+  // Create a WebUIDataSource containing the chrome://media-router page's
+  // content.
+  std::unique_ptr<content::WebUIDataSource> html_source(
+      content::WebUIDataSource::Create(chrome::kChromeUIMediaRouterHost));
+
+  AddLocalizedStrings(html_source.get());
+  AddMediaRouterUIResources(html_source.get());
+  // Ownership of |html_source| is transferred to the BrowserContext.
+  content::WebUIDataSource::Add(Profile::FromWebUI(web_ui),
+                                html_source.release());
+
+  web_ui->AddMessageHandler(std::move(handler));
+}
+
+MediaRouterUI::~MediaRouterUI() = default;
+
+void MediaRouterUI::Close() {
+  ConstrainedWebDialogDelegate* delegate = GetConstrainedDelegate();
+  if (delegate) {
+    delegate->GetWebDialogDelegate()->OnDialogClosed(std::string());
+    delegate->OnDialogCloseFromWebUI();
+  }
+}
+
+void MediaRouterUI::OnUIInitialized() {
+  TRACE_EVENT_NESTABLE_ASYNC_END0("media_router", "UI", initiator());
+
+  ui_initialized_ = true;
+
+  // TODO(imcheng): We should be able to instantiate |issue_observer_| during
+  // InitCommon by storing an initial Issue in this class.
+  // Register for Issue updates.
+  issues_observer_ =
+      std::make_unique<UIIssuesObserver>(GetIssueManager(), this);
+  issues_observer_->Init();
+}
+
+bool MediaRouterUI::CreateRoute(const MediaSink::Id& sink_id,
+                                MediaCastMode cast_mode) {
+  // Default the tab casting the content to the initiator, and change if
+  // necessary.
+  content::WebContents* tab_contents = initiator();
+
+  base::Optional<RouteParameters> params;
+  if (cast_mode == MediaCastMode::LOCAL_FILE) {
+    GURL url = media_router_file_dialog_->GetLastSelectedFileUrl();
+    tab_contents = OpenTabWithUrl(url);
+    params = GetLocalFileRouteParameters(sink_id, url, tab_contents);
+  } else {
+    params = GetRouteParameters(sink_id, cast_mode);
+  }
+  if (!params) {
+    SendIssueForUnableToCast(cast_mode);
+    return false;
+  }
+
+  GetIssueManager()->ClearNonBlockingIssues();
+  GetMediaRouter()->CreateRoute(params->source_id, sink_id, params->origin,
+                                tab_contents,
+                                std::move(params->route_response_callbacks),
+                                params->timeout, params->incognito);
+  return true;
+}
+
+bool MediaRouterUI::ConnectRoute(const MediaSink::Id& sink_id,
+                                 const MediaRoute::Id& route_id) {
+  base::Optional<RouteParameters> params =
+      GetRouteParameters(sink_id, MediaCastMode::PRESENTATION);
+  if (!params) {
+    SendIssueForUnableToCast(MediaCastMode::PRESENTATION);
+    return false;
+  }
+  GetIssueManager()->ClearNonBlockingIssues();
+  GetMediaRouter()->ConnectRouteByRouteId(
+      params->source_id, route_id, params->origin, initiator(),
+      std::move(params->route_response_callbacks), params->timeout,
+      params->incognito);
+  return true;
+}
+
+void MediaRouterUI::AddIssue(const IssueInfo& issue) {
+  GetIssueManager()->AddIssue(issue);
+}
+
+void MediaRouterUI::ClearIssue(const Issue::Id& issue_id) {
+  GetIssueManager()->ClearIssue(issue_id);
+}
+
+void MediaRouterUI::OpenFileDialog() {
+  if (!media_router_file_dialog_) {
+    media_router_file_dialog_ = std::make_unique<MediaRouterFileDialog>(this);
+  }
+
+  media_router_file_dialog_->OpenFileDialog(GetBrowser());
+}
+
+void MediaRouterUI::SearchSinksAndCreateRoute(
+    const MediaSink::Id& sink_id,
+    const std::string& search_criteria,
+    const std::string& domain,
+    MediaCastMode cast_mode) {
+  std::unique_ptr<MediaSource> source =
+      query_result_manager()->GetSourceForCastModeAndSink(cast_mode, sink_id);
+  const std::string source_id = source ? source->id() : "";
+
+  // The CreateRoute() part of the function is accomplished in the callback
+  // OnSearchSinkResponseReceived().
+  GetMediaRouter()->SearchSinks(
+      sink_id, source_id, search_criteria, domain,
+      base::BindRepeating(&MediaRouterUI::OnSearchSinkResponseReceived,
+                          weak_factory_.GetWeakPtr(), cast_mode));
+}
+
+bool MediaRouterUI::UserSelectedTabMirroringForCurrentOrigin() const {
+  const base::ListValue* origins =
+      Profile::FromWebUI(web_ui())->GetPrefs()->GetList(
+          ::prefs::kMediaRouterTabMirroringSources);
+  return origins->Find(base::Value(GetSerializedInitiatorOrigin())) !=
+         origins->end();
+}
+
+void MediaRouterUI::RecordCastModeSelection(MediaCastMode cast_mode) {
+  ListPrefUpdate update(Profile::FromWebUI(web_ui())->GetPrefs(),
+                        ::prefs::kMediaRouterTabMirroringSources);
+
+  switch (cast_mode) {
+    case MediaCastMode::PRESENTATION:
+      update->Remove(base::Value(GetSerializedInitiatorOrigin()), nullptr);
+      break;
+    case MediaCastMode::TAB_MIRROR:
+      update->AppendIfNotPresent(
+          std::make_unique<base::Value>(GetSerializedInitiatorOrigin()));
+      break;
+    case MediaCastMode::DESKTOP_MIRROR:
+      // Desktop mirroring isn't domain-specific, so we don't record the
+      // selection.
+      break;
+    case MediaCastMode::LOCAL_FILE:
+      // Local media isn't domain-specific, so we don't record the selection.
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+}
+
+std::string MediaRouterUI::GetPresentationRequestSourceName() const {
+  GURL gurl = GetFrameURL();
+  return gurl.SchemeIs(extensions::kExtensionScheme)
+             ? GetExtensionName(gurl, extensions::ExtensionRegistry::Get(
+                                          Profile::FromWebUI(web_ui())))
+             : GetHostFromURL(gurl);
+}
+
+const std::set<MediaCastMode>& MediaRouterUI::cast_modes() const {
+  return cast_modes_;
+}
+
+void MediaRouterUI::SetUIInitializationTimer(const base::Time& start_time) {
+  DCHECK(!start_time.is_null());
+  start_time_ = start_time;
+}
+
+void MediaRouterUI::OnUIInitiallyLoaded() {
+  if (!start_time_.is_null()) {
+    MediaRouterMetrics::RecordMediaRouterDialogPaint(base::Time::Now() -
+                                                     start_time_);
+  }
+}
+
+void MediaRouterUI::OnUIInitialDataReceived() {
+  if (!start_time_.is_null()) {
+    MediaRouterMetrics::RecordMediaRouterDialogLoaded(base::Time::Now() -
+                                                      start_time_);
+    start_time_ = base::Time();
+  }
+}
+
+void MediaRouterUI::UpdateMaxDialogHeight(int height) {
+  if (ui_initialized_) {
+    handler_->UpdateMaxDialogHeight(height);
+  }
+}
+
+MediaRouteController* MediaRouterUI::GetMediaRouteController() const {
+  return route_controller_observer_
+             ? route_controller_observer_->controller().get()
+             : nullptr;
+}
+
+void MediaRouterUI::OnMediaControllerUIAvailable(
+    const MediaRoute::Id& route_id) {
+#if 0
+  scoped_refptr<MediaRouteController> controller =
+      GetMediaRouter()->GetRouteController(route_id);
+  if (!controller) {
+    DVLOG(1) << "Requested a route controller with an invalid route ID.";
+    return;
+  }
+  DVLOG_IF(1, route_controller_observer_)
+      << "Route controller observer unexpectedly exists.";
+  route_controller_observer_ =
+      std::make_unique<UIMediaRouteControllerObserver>(this, controller);
+#endif
+}
+
+void MediaRouterUI::OnMediaControllerUIClosed() {
+  route_controller_observer_.reset();
+}
+
+void MediaRouterUI::InitForTest(
+    MediaRouter* router,
+    content::WebContents* initiator,
+    MediaRouterWebUIMessageHandler* handler,
+    std::unique_ptr<StartPresentationContext> context,
+    std::unique_ptr<MediaRouterFileDialog> file_dialog) {
+  handler_ = handler;
+  set_start_presentation_context_for_test(std::move(context));
+  InitForTest(std::move(file_dialog));
+  InitCommon(initiator);
+  if (start_presentation_context()) {
+    OnDefaultPresentationChanged(
+        start_presentation_context()->presentation_request());
+  }
+
+  OnUIInitialized();
+}
+
+void MediaRouterUI::InitForTest(
+    std::unique_ptr<MediaRouterFileDialog> file_dialog) {
+  media_router_file_dialog_ = std::move(file_dialog);
+}
+
+MediaRouterUI::UIMediaRouteControllerObserver::UIMediaRouteControllerObserver(
+    MediaRouterUI* ui,
+    scoped_refptr<MediaRouteController> controller)
+    : MediaRouteController::Observer(std::move(controller)), ui_(ui) {
+  if (controller_->current_media_status())
+    OnMediaStatusUpdated(controller_->current_media_status().value());
+}
+
+MediaRouterUI::UIMediaRouteControllerObserver::
+    ~UIMediaRouteControllerObserver() {}
+
+void MediaRouterUI::UIMediaRouteControllerObserver::OnMediaStatusUpdated(
+    const MediaStatus& status) {
+  ui_->UpdateMediaRouteStatus(status);
+}
+
+void MediaRouterUI::UIMediaRouteControllerObserver::OnControllerInvalidated() {
+  ui_->OnRouteControllerInvalidated();
+}
+
+Browser* MediaRouterUI::GetBrowser() {
+  CHECK(initiator());
+  return chrome::FindBrowserWithWebContents(initiator());
+}
+
+content::WebContents* MediaRouterUI::OpenTabWithUrl(const GURL url) {
+  // Check if the current page is a new tab. If so open file in current page.
+  // If not then open a new page.
+  if (initiator()->GetVisibleURL() == chrome::kChromeUINewTabURL) {
+    content::NavigationController::LoadURLParams load_params(url);
+    load_params.transition_type = ui::PAGE_TRANSITION_GENERATED;
+    initiator()->GetController().LoadURLWithParams(load_params);
+    return initiator();
+  } else {
+    return chrome::AddSelectedTabWithURL(GetBrowser(), url,
+                                         ui::PAGE_TRANSITION_LINK);
+  }
+}
+
+void MediaRouterUI::FileDialogFileSelected(
+    const ui::SelectedFileInfo& file_info) {
+  handler_->UserSelectedLocalMediaFile(file_info.display_name);
+}
+
+void MediaRouterUI::FileDialogSelectionFailed(const IssueInfo& issue) {
+  AddIssue(issue);
+}
+
+void MediaRouterUI::SetIssue(const Issue& issue) {
+  if (ui_initialized_)
+    handler_->UpdateIssue(issue);
+}
+
+void MediaRouterUI::ClearIssue() {
+  if (ui_initialized_)
+    handler_->ClearIssue();
+}
+
+void MediaRouterUI::OnRoutesUpdated(
+    const std::vector<MediaRoute>& routes,
+    const std::vector<MediaRoute::Id>& joinable_route_ids) {
+  MediaRouterUIBase::OnRoutesUpdated(routes, joinable_route_ids);
+  joinable_route_ids_.clear();
+
+  for (const MediaRoute& route : routes) {
+    if (route.for_display() &&
+        base::ContainsValue(joinable_route_ids, route.media_route_id())) {
+      joinable_route_ids_.push_back(route.media_route_id());
+    }
+  }
+
+  if (ui_initialized_) {
+    handler_->UpdateRoutes(MediaRouterUIBase::routes(), joinable_route_ids_,
+                           routes_and_cast_modes());
+  }
+  UpdateRoutesToCastModesMapping();
+}
+
+void MediaRouterUI::OnRouteResponseReceived(
+    int route_request_id,
+    const MediaSink::Id& sink_id,
+    MediaCastMode cast_mode,
+    const base::string16& presentation_request_source_name,
+    const RouteRequestResult& result) {
+  MediaRouterUIBase::OnRouteResponseReceived(
+      route_request_id, sink_id, cast_mode, presentation_request_source_name,
+      result);
+  handler_->OnCreateRouteResponseReceived(sink_id, result.route());
+  if (result.result_code() == RouteRequestResult::TIMED_OUT)
+    SendIssueForRouteTimeout(cast_mode, presentation_request_source_name);
+}
+
+void MediaRouterUI::MaybeReportFileInformation(
+    const RouteRequestResult& result) {
+  if (result.result_code() == RouteRequestResult::OK)
+    media_router_file_dialog_->MaybeReportLastSelectedFileInformation();
+}
+
+void MediaRouterUI::HandleCreateSessionRequestRouteResponse(
+    const RouteRequestResult&) {
+  Close();
+}
+
+void MediaRouterUI::OnSearchSinkResponseReceived(
+    MediaCastMode cast_mode,
+    const MediaSink::Id& found_sink_id) {
+  DVLOG(1) << "OnSearchSinkResponseReceived";
+  handler_->ReturnSearchResult(found_sink_id);
+
+  CreateRoute(found_sink_id, cast_mode);
+}
+
+void MediaRouterUI::SendIssueForRouteTimeout(
+    MediaCastMode cast_mode,
+    const base::string16& presentation_request_source_name) {
+  std::string issue_title;
+  switch (cast_mode) {
+    case PRESENTATION:
+      DLOG_IF(ERROR, presentation_request_source_name.empty())
+          << "Empty presentation request source name.";
+      issue_title =
+          l10n_util::GetStringFUTF8(IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT,
+                                    presentation_request_source_name);
+      break;
+    case TAB_MIRROR:
+      issue_title = l10n_util::GetStringUTF8(
+          IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_TAB);
+      break;
+    case DESKTOP_MIRROR:
+      issue_title = l10n_util::GetStringUTF8(
+          IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_DESKTOP);
+      break;
+    default:
+      NOTREACHED();
+  }
+
+  AddIssue(IssueInfo(issue_title, IssueInfo::Action::DISMISS,
+                     IssueInfo::Severity::NOTIFICATION));
+}
+
+void MediaRouterUI::SendIssueForUnableToCast(MediaCastMode cast_mode) {
+  // For a generic error, claim a tab error unless it was specifically desktop
+  // mirroring.
+  std::string issue_title =
+      (cast_mode == MediaCastMode::DESKTOP_MIRROR)
+          ? l10n_util::GetStringUTF8(
+                IDS_MEDIA_ROUTER_ISSUE_UNABLE_TO_CAST_DESKTOP)
+          : l10n_util::GetStringUTF8(
+                IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_TAB);
+  AddIssue(IssueInfo(issue_title, IssueInfo::Action::DISMISS,
+                     IssueInfo::Severity::WARNING));
+}
+
+void MediaRouterUI::InitCommon(content::WebContents* initiator) {
+  MediaRouterUIBase::InitCommon(initiator);
+  UpdateCastModes();
+  // Presentation requests from content must show the origin requesting
+  // presentation: crbug.com/704964
+  if (start_presentation_context())
+    forced_cast_mode_ = MediaCastMode::PRESENTATION;
+}
+
+void MediaRouterUI::OnDefaultPresentationChanged(
+    const content::PresentationRequest& presentation_request) {
+  MediaRouterUIBase::OnDefaultPresentationChanged(presentation_request);
+  UpdateCastModes();
+}
+
+void MediaRouterUI::OnDefaultPresentationRemoved() {
+  MediaRouterUIBase::OnDefaultPresentationRemoved();
+
+  // This should not be set if the dialog was initiated with a default
+  // presentation request from the top level frame.  However, clear it just to
+  // be safe.
+  forced_cast_mode_ = base::nullopt;
+  UpdateCastModes();
+}
+
+base::Optional<RouteParameters> MediaRouterUI::GetLocalFileRouteParameters(
+    const MediaSink::Id& sink_id,
+    const GURL& file_url,
+    content::WebContents* tab_contents) {
+  RouteParameters params;
+  SessionID::id_type tab_id = SessionTabHelper::IdForTab(tab_contents).id();
+  params.source_id = MediaSourceForTab(tab_id).id();
+
+  // Use a placeholder URL as origin for local file casting, which is
+  // essentially mirroring.
+  params.origin = url::Origin::Create(GURL(chrome::kChromeUIMediaRouterURL));
+
+  params.route_response_callbacks.push_back(base::BindOnce(
+      &MediaRouterUI::OnRouteResponseReceived, weak_factory_.GetWeakPtr(),
+      current_route_request_id(), sink_id, MediaCastMode::LOCAL_FILE,
+      base::UTF8ToUTF16(GetTruncatedPresentationRequestSourceName())));
+
+  params.route_response_callbacks.push_back(
+      base::BindOnce(&MediaRouterUIBase::MaybeReportCastingSource,
+                     weak_factory_.GetWeakPtr(), MediaCastMode::LOCAL_FILE));
+
+  params.route_response_callbacks.push_back(base::BindOnce(
+      &MediaRouterUI::MaybeReportFileInformation, weak_factory_.GetWeakPtr()));
+
+  params.route_response_callbacks.push_back(
+      base::BindOnce(&MediaRouterUI::FullScreenFirstVideoElement,
+                     weak_factory_.GetWeakPtr(), file_url, tab_contents));
+
+  params.timeout = GetRouteRequestTimeout(MediaCastMode::LOCAL_FILE);
+  CHECK(initiator());
+  params.incognito = initiator()->GetBrowserContext()->IsOffTheRecord();
+
+  return base::make_optional(std::move(params));
+}
+
+// TODO(crbug.com/792547): Refactor FullScreenFirstVideoElement() and
+// MaybeReportFileInformation() into a local media casting specific location
+// instead of here in the main ui.
+void MediaRouterUI::FullScreenFirstVideoElement(
+    const GURL& file_url,
+    content::WebContents* web_contents,
+    const RouteRequestResult& result) {
+  if (result.result_code() == RouteRequestResult::OK) {
+    new WebContentsFullscreenOnLoadedObserver(file_url, web_contents);
+  }
+}
+
+void MediaRouterUI::UpdateCastModes() {
+  // Gets updated cast modes from |query_result_manager()| and forwards it to
+  // UI.
+  cast_modes_ = query_result_manager()->GetSupportedCastModes();
+  if (ui_initialized_) {
+    handler_->UpdateCastModes(cast_modes(), GetPresentationRequestSourceName(),
+                              forced_cast_mode());
+  }
+}
+
+void MediaRouterUI::UpdateRoutesToCastModesMapping() {
+  std::unordered_map<MediaSource::Id, MediaCastMode> available_source_map;
+  for (const auto& cast_mode : cast_modes()) {
+    for (const auto& source : GetSourcesForCastMode(cast_mode))
+      available_source_map.insert(std::make_pair(source.id(), cast_mode));
+  }
+
+  routes_and_cast_modes_.clear();
+  for (const auto& route : routes()) {
+    auto source_entry = available_source_map.find(route.media_source().id());
+    if (source_entry != available_source_map.end()) {
+      routes_and_cast_modes_.insert(
+          std::make_pair(route.media_route_id(), source_entry->second));
+    }
+  }
+}
+
+std::string MediaRouterUI::GetSerializedInitiatorOrigin() const {
+  url::Origin origin =
+      initiator() ? url::Origin::Create(initiator()->GetLastCommittedURL())
+                  : url::Origin();
+  return origin.Serialize();
+}
+
+void MediaRouterUI::OnRouteControllerInvalidated() {
+  route_controller_observer_.reset();
+  handler_->OnRouteControllerInvalidated();
+}
+void MediaRouterUI::UpdateMediaRouteStatus(const MediaStatus& status) {
+  handler_->UpdateMediaRouteStatus(status);
+}
+
+IssueManager* MediaRouterUI::GetIssueManager() {
+  return GetMediaRouter()->GetIssueManager();
+}
+
+void MediaRouterUI::UpdateSinks() {
+  if (ui_initialized_)
+    handler_->UpdateSinks(GetEnabledSinks());
+}
+
+MediaRouter* MediaRouterUI::GetMediaRouter() const {
+  return MediaRouterFactory::GetApiForBrowserContext(
+      web_ui()->GetWebContents()->GetBrowserContext());
+}
+
+}  // namespace media_router
diff --git a/chrome/browser/ui/webui/settings/about_handler.cc b/chrome/browser/ui/webui/settings/about_handler.cc
index 21c3de52e0d5..38beabfe60e8 100644
--- a/chrome/browser/ui/webui/settings/about_handler.cc
+++ b/chrome/browser/ui/webui/settings/about_handler.cc
@@ -421,6 +421,7 @@ void AboutHandler::RegisterMessages() {
 }
 
 void AboutHandler::OnJavascriptAllowed() {
+#if 0
   apply_changes_from_upgrade_observer_ = true;
   version_updater_.reset(VersionUpdater::Create(web_ui()->GetWebContents()));
   policy_registrar_ = std::make_unique<policy::PolicyChangeRegistrar>(
@@ -430,6 +431,7 @@ void AboutHandler::OnJavascriptAllowed() {
       policy::key::kDeviceAutoUpdateDisabled,
       base::Bind(&AboutHandler::OnDeviceAutoUpdatePolicyChanged,
                  base::Unretained(this)));
+#endif
 }
 
 void AboutHandler::OnJavascriptDisallowed() {
diff --git a/chrome/browser/ui/webui/settings/change_password_handler.cc b/chrome/browser/ui/webui/settings/change_password_handler.cc
index b34815f9c76f..bf86d6d1e9b8 100644
--- a/chrome/browser/ui/webui/settings/change_password_handler.cc
+++ b/chrome/browser/ui/webui/settings/change_password_handler.cc
@@ -58,24 +58,9 @@ void ChangePasswordHandler::HandleInitialize(const base::ListValue* args) {
 }
 
 void ChangePasswordHandler::HandleChangePassword(const base::ListValue* args) {
-  service_->OnUserAction(
-      web_ui()->GetWebContents(),
-      service_->reused_password_account_type_for_last_shown_warning(),
-      RequestOutcome::UNKNOWN,
-      LoginReputationClientResponse::VERDICT_TYPE_UNSPECIFIED, "unused_token",
-      safe_browsing::WarningUIType::CHROME_SETTINGS,
-      safe_browsing::WarningAction::CHANGE_PASSWORD);
 }
 
 void ChangePasswordHandler::UpdateChangePasswordCardVisibility() {
-  FireWebUIListener(
-      "change-password-visibility",
-      base::Value(
-          service_->IsWarningEnabled(
-              service_
-                  ->reused_password_account_type_for_last_shown_warning()) &&
-          safe_browsing::ChromePasswordProtectionService::
-              ShouldShowChangePasswordSettingUI(profile_)));
 }
 
 }  // namespace settings
diff --git a/chrome/browser/ui/webui/settings/printing_handler.cc b/chrome/browser/ui/webui/settings/printing_handler.cc
index deaa3ab5352c..626c7a784d0f 100644
--- a/chrome/browser/ui/webui/settings/printing_handler.cc
+++ b/chrome/browser/ui/webui/settings/printing_handler.cc
@@ -28,8 +28,10 @@ void PrintingHandler::OnJavascriptAllowed() {}
 void PrintingHandler::OnJavascriptDisallowed() {}
 
 void PrintingHandler::HandleOpenSystemPrintDialog(const base::ListValue* args) {
+#if 0
   printing::PrinterManagerDialog::ShowPrinterManagerDialog(
       Profile::FromWebUI(web_ui()));
+#endif
 }
 
 }  // namespace settings
diff --git a/chrome/browser/ui/webui/settings/safety_check_handler.cc b/chrome/browser/ui/webui/settings/safety_check_handler.cc
index be365ff44891..d5bc8cfbe612 100644
--- a/chrome/browser/ui/webui/settings/safety_check_handler.cc
+++ b/chrome/browser/ui/webui/settings/safety_check_handler.cc
@@ -11,10 +11,12 @@ SafetyCheckHandler::SafetyCheckHandler() = default;
 SafetyCheckHandler::~SafetyCheckHandler() = default;
 
 void SafetyCheckHandler::PerformSafetyCheck() {
+#if 0
   version_updater_.reset(VersionUpdater::Create(web_ui()->GetWebContents()));
   CheckUpdates(version_updater_.get(),
                base::Bind(&SafetyCheckHandler::OnUpdateCheckResult,
                           base::Unretained(this)));
+#endif
 }
 
 void SafetyCheckHandler::CheckUpdates(
diff --git a/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc b/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
index 8dc520241ba0..fb9e599b3962 100644
--- a/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
+++ b/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
@@ -3172,7 +3172,8 @@ void AddSiteSettingsStrings(content::WebUIDataSource* html_source,
 
   html_source->AddBoolean(
       "enableInsecureContentContentSetting",
-      base::FeatureList::IsEnabled(features::kMixedContentSiteSetting));
+      false);
+//      base::FeatureList::IsEnabled(features::kMixedContentSiteSetting));
 
   html_source->AddBoolean(
       "showImprovedCookieControlsForThirdParties",
diff --git a/chrome/browser/ui/webui/settings/system_handler.cc b/chrome/browser/ui/webui/settings/system_handler.cc
index 7c7082779b94..43a04da87dda 100644
--- a/chrome/browser/ui/webui/settings/system_handler.cc
+++ b/chrome/browser/ui/webui/settings/system_handler.cc
@@ -35,7 +35,7 @@ void SystemHandler::RegisterMessages() {
 
 void SystemHandler::HandleShowProxySettings(const base::ListValue* /*args*/) {
   base::RecordAction(base::UserMetricsAction("Options_ShowProxySettings"));
-  settings_utils::ShowNetworkProxySettings(web_ui()->GetWebContents());
+//  settings_utils::ShowNetworkProxySettings(web_ui()->GetWebContents());
 }
 
 }  // namespace settings
diff --git a/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc b/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
index fbf48642e0dd..567cf2fc39f0 100644
--- a/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
+++ b/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
@@ -248,6 +248,7 @@ void LockProfileAndShowUserManager(const base::FilePath& profile_path) {
 void OnSyncSetupComplete(Profile* profile,
                          const std::string& username,
                          const std::string& password) {
+#if 0
   DCHECK(signin_util::IsForceSigninEnabled());
   signin::IdentityManager* identity_manager =
       IdentityManagerFactory::GetForProfile(profile);
@@ -273,6 +274,7 @@ void OnSyncSetupComplete(Profile* profile,
         BrowserList::CloseCallback(),
         /*skip_beforeunload=*/true);
   }
+#endif
 }
 
 }  // namespace
@@ -409,11 +411,13 @@ void InlineSigninHelper::OnClientOAuthSuccessAndBrowserOpened(
       // Display a confirmation dialog to the user.
       base::RecordAction(
           base::UserMetricsAction("Signin_Show_UntrustedSigninPrompt"));
+#if 0
       Browser* browser = chrome::FindLastActiveWithProfile(profile_);
       browser->window()->ShowOneClickSigninConfirmation(
           base::UTF8ToUTF16(email_),
           base::BindOnce(&InlineSigninHelper::UntrustedSigninConfirmed,
                          base::Unretained(this), result.refresh_token));
+#endif
       return;
     }
     CreateSyncStarter(result.refresh_token);
diff --git a/chrome/browser/ui/window_sizer/window_sizer_android.cc b/chrome/browser/ui/window_sizer/window_sizer_android.cc
new file mode 100644
index 000000000000..a75302b74d6c
--- /dev/null
+++ b/chrome/browser/ui/window_sizer/window_sizer_android.cc
@@ -0,0 +1,17 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/window_sizer/window_sizer.h"
+
+// This doesn't matter for aura, which has different tiling.
+// static
+const int WindowSizer::kWindowTilePixels = 10;
+const int WindowSizer::kWindowMaxDefaultWidth = 1050;
+
+// static
+gfx::Point WindowSizer::GetDefaultPopupOrigin(const gfx::Size& size) {
+  // TODO(skuhne): Check if this isn't needed anymore (since it is implemented
+  // in WindowPositioner) and remove it.
+  return gfx::Point();
+}
diff --git a/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc b/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc
index 828d0552721c..470f3599a014 100644
--- a/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc
+++ b/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc
@@ -81,6 +81,7 @@ std::string ChromeZoomLevelPrefs::GetPartitionKeyForTesting(
 }
 
 void ChromeZoomLevelPrefs::SetDefaultZoomLevelPref(double level) {
+#if 0
   if (blink::PageZoomValuesEqual(level, host_zoom_map_->GetDefaultZoomLevel()))
     return;
 
@@ -92,16 +93,12 @@ void ChromeZoomLevelPrefs::SetDefaultZoomLevelPref(double level) {
   default_zoom_changed_callbacks_.Notify();
   if (zoom_event_manager_)
     zoom_event_manager_->OnDefaultZoomLevelChanged();
+#endif
 }
 
 double ChromeZoomLevelPrefs::GetDefaultZoomLevelPref() const {
   double default_zoom_level = 0.0;
 
-  const base::DictionaryValue* default_zoom_level_dictionary =
-      pref_service_->GetDictionary(prefs::kPartitionDefaultZoomLevel);
-  // If no default has been previously set, the default returned is the
-  // value used to initialize default_zoom_level in this function.
-  default_zoom_level_dictionary->GetDouble(partition_key_, &default_zoom_level);
   return default_zoom_level;
 }
 
@@ -219,26 +216,4 @@ void ChromeZoomLevelPrefs::ExtractPerHostZoomLevels(
 void ChromeZoomLevelPrefs::InitHostZoomMap(
     content::HostZoomMap* host_zoom_map) {
   // This init function must be called only once.
-  DCHECK(!host_zoom_map_);
-  DCHECK(host_zoom_map);
-  host_zoom_map_ = host_zoom_map;
-
-  // Initialize the default zoom level.
-  host_zoom_map_->SetDefaultZoomLevel(GetDefaultZoomLevelPref());
-
-  // Initialize the HostZoomMap with per-host zoom levels from the persisted
-  // zoom-level preference values.
-  const base::DictionaryValue* host_zoom_dictionaries =
-      pref_service_->GetDictionary(prefs::kPartitionPerHostZoomLevels);
-  const base::DictionaryValue* host_zoom_dictionary = nullptr;
-  if (host_zoom_dictionaries->GetDictionary(partition_key_,
-                                            &host_zoom_dictionary)) {
-    // Since we're calling this before setting up zoom_subscription_ below we
-    // don't need to worry that host_zoom_dictionary is indirectly affected
-    // by calls to HostZoomMap::SetZoomLevelForHost().
-    ExtractPerHostZoomLevels(host_zoom_dictionary,
-                             true /* sanitize_partition_host_zoom_levels */);
-  }
-  zoom_subscription_ = host_zoom_map_->AddZoomLevelChangedCallback(base::Bind(
-      &ChromeZoomLevelPrefs::OnZoomLevelChanged, base::Unretained(this)));
 }
diff --git a/chrome/browser/web_applications/BUILD.gn b/chrome/browser/web_applications/BUILD.gn
index 767ce88329cc..5fe1aa2771f9 100644
--- a/chrome/browser/web_applications/BUILD.gn
+++ b/chrome/browser/web_applications/BUILD.gn
@@ -153,7 +153,6 @@ source_set("web_applications_unit_tests") {
     "//chrome/browser",
     "//chrome/browser/web_applications/components",
     "//chrome/common",
-    "//chrome/test:test_support",
     "//content/public/browser",
     "//content/test:test_support",
     "//skia",
@@ -184,8 +183,6 @@ source_set("web_applications_browser_tests") {
     ":web_applications",
     ":web_applications_test_support",
     "//chrome/browser/web_applications/components",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
   ]
 }
 
diff --git a/chrome/browser/web_applications/components/BUILD.gn b/chrome/browser/web_applications/components/BUILD.gn
index 9dd348c9ffdd..c9ed969dffb0 100644
--- a/chrome/browser/web_applications/components/BUILD.gn
+++ b/chrome/browser/web_applications/components/BUILD.gn
@@ -98,6 +98,14 @@ source_set("components") {
     ]
   }
 
+  if (is_android) {
+    sources += [
+      "web_app_shortcut_android.h",
+      "web_app_shortcut_android.cc",
+    ]
+  }
+
+
   if (is_win) {
     sources += [
       "web_app_file_handler_registration_win.cc",
@@ -162,7 +170,6 @@ source_set("unit_tests") {
     "//chrome/app/theme:theme_resources",
     "//chrome/browser/web_applications:web_app_test_group",
     "//chrome/browser/web_applications:web_applications_test_support",
-    "//chrome/test:test_support",
     "//content/public/browser",
     "//skia",
     "//testing/gmock",
@@ -188,8 +195,6 @@ source_set("browser_tests") {
     ":components",
     "//chrome/app:command_ids",
     "//chrome/browser/web_applications:web_applications_test_support",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
     "//net:test_support",
   ]
 }
diff --git a/chrome/browser/web_applications/components/web_app_shortcut_android.cc b/chrome/browser/web_applications/components/web_app_shortcut_android.cc
new file mode 100644
index 000000000000..6ecf48e150a0
--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.cc
@@ -0,0 +1,122 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/web_applications/components/web_app_shortcut_android.h"
+
+#include <fcntl.h>
+
+#include "base/base_paths.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/i18n/file_util_icu.h"
+#include "base/nix/xdg_util.h"
+#include "base/path_service.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/process/kill.h"
+#include "base/process/launch.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "chrome/browser/shell_integration.h"
+#include "chrome/browser/web_applications/components/web_app_helpers.h"
+#include "chrome/browser/web_applications/components/web_app_shortcut.h"
+#include "chrome/common/buildflags.h"
+#include "chrome/common/chrome_constants.h"
+
+namespace {
+
+#if 0 // BUILDFLAG(ENABLE_APP_LIST)
+// The Categories for the App Launcher desktop shortcut. Should be the same as
+// the Chrome desktop shortcut, so they are in the same sub-menu.
+const char kAppListCategories[] = "Network;WebBrowser;";
+#endif
+
+}  // namespace
+
+namespace web_app {
+
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id) {
+  DCHECK(!app_id.empty());
+
+  // Use a prefix, because xdg-desktop-menu requires it.
+  std::string filename(chrome::kBrowserProcessExecutableName);
+  filename.append("-").append(app_id).append("-").append(
+      profile_path.BaseName().value());
+  base::i18n::ReplaceIllegalCharactersInPath(&filename, '_');
+  // Spaces in filenames break xdg-desktop-menu
+  // (see https://bugs.freedesktop.org/show_bug.cgi?id=66605).
+  base::ReplaceChars(filename, " ", "_", &filename);
+  return base::FilePath(filename.append(".desktop"));
+}
+
+void DeleteShortcutOnDesktop(const base::FilePath& shortcut_filename) {
+}
+
+void DeleteShortcutInApplicationsMenu(
+    const base::FilePath& shortcut_filename,
+    const base::FilePath& directory_filename) {
+}
+
+bool CreateDesktopShortcut(
+    const web_app::ShortcutInfo& shortcut_info,
+    const web_app::ShortcutLocations& creation_locations) {
+  return false;
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id) {
+  base::FilePath desktop_path;
+  // If Get returns false, just leave desktop_path empty.
+  base::PathService::Get(base::DIR_USER_DESKTOP, &desktop_path);
+  return GetExistingShortcutLocations(env, profile_path, extension_id,
+                                      desktop_path);
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  web_app::ShortcutLocations locations;
+  return locations;
+}
+
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id) {
+}
+
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path) {
+}
+
+namespace internals {
+
+bool CreatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutLocations& creation_locations,
+                             ShortcutCreationReason /*creation_reason*/,
+                             const ShortcutInfo& shortcut_info) {
+  return false;
+}
+
+void DeletePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void UpdatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const base::string16& /*old_app_title*/,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
+}
+
+}  // namespace internals
+
+}  // namespace web_app
diff --git a/chrome/browser/web_applications/components/web_app_shortcut_android.h b/chrome/browser/web_applications/components/web_app_shortcut_android.h
new file mode 100644
index 000000000000..7ffccdf1fa46
--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.h
@@ -0,0 +1,62 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+#define CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+
+#include <string>
+
+namespace base {
+class FilePath;
+class Environment;
+}  // namespace base
+
+namespace web_app {
+
+struct ShortcutInfo;
+struct ShortcutLocations;
+
+// Create shortcuts on the desktop or in the application menu (as specified by
+// |shortcut_info|), for the web page or extension in |shortcut_info|.
+// For extensions, duplicate shortcuts are avoided, so if a requested shortcut
+// already exists it is deleted first.
+bool CreateDesktopShortcut(const ShortcutInfo& shortcut_info,
+                           const ShortcutLocations& creation_locations);
+
+// Returns filename for .desktop file based on |profile_path| and
+// |app_id|, sanitized for security.
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id);
+
+// Returns the set of locations in which shortcuts are installed for the
+// extension with |extension_id| in |profile_path|.
+// This searches the file system for .desktop files in appropriate locations. A
+// shortcut with NoDisplay=true causes hidden to become true, instead of
+// creating at APP_MENU_LOCATIONS_SUBDIR_CHROMEAPPS.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id);
+
+// Version of GetExistingShortcutLocations which takes an explicit path
+// to the user's desktop directory. Useful for testing.
+// If |desktop_path| is empty, the desktop is not searched.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// been added for the extension with |extension_id| in |profile_path|.
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// for the profile in |profile_path|.
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path);
+
+}  // namespace web_app
+
+#endif  // CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
diff --git a/chrome/browser/web_applications/extensions/BUILD.gn b/chrome/browser/web_applications/extensions/BUILD.gn
index bcebc3167309..5e4c6029424a 100644
--- a/chrome/browser/web_applications/extensions/BUILD.gn
+++ b/chrome/browser/web_applications/extensions/BUILD.gn
@@ -66,7 +66,6 @@ source_set("unit_tests") {
     "//chrome/browser/web_applications:web_applications_test_support",
     "//chrome/browser/web_applications/components",
     "//chrome/common",
-    "//chrome/test:test_support",
     "//components/crx_file:crx_file",
     "//content/public/browser",
     "//content/test:test_support",
@@ -101,8 +100,6 @@ source_set("browser_tests") {
     "//chrome/browser/web_applications:web_applications_on_extensions_test_support",
     "//chrome/browser/web_applications:web_applications_test_support",
     "//chrome/browser/web_applications/components",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
     "//extensions:test_support",
     "//extensions/browser",
     "//extensions/common",
diff --git a/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc b/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
index 17450e25fcec..b72965362986 100644
--- a/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
+++ b/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
@@ -93,12 +93,14 @@ void UpdateAllShortcutsForShortcutInfo(
     const base::string16& old_app_title,
     base::OnceClosure callback,
     std::unique_ptr<ShortcutInfo> shortcut_info) {
+#if 0
   base::FilePath shortcut_data_dir =
       internals::GetShortcutDataDir(*shortcut_info);
   internals::PostShortcutIOTaskAndReply(
       base::BindOnce(&internals::UpdatePlatformShortcuts,
                      std::move(shortcut_data_dir), old_app_title),
       std::move(shortcut_info), std::move(callback));
+#endif
 }
 
 }  // namespace
@@ -253,14 +255,6 @@ void CreateShortcuts(ShortcutCreationReason reason,
 
 void DeleteAllShortcuts(Profile* profile, const extensions::Extension* app) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  std::unique_ptr<ShortcutInfo> shortcut_info(
-      ShortcutInfoForExtensionAndProfile(app, profile));
-  base::FilePath shortcut_data_dir =
-      internals::GetShortcutDataDir(*shortcut_info);
-  internals::PostShortcutIOTask(
-      base::BindOnce(&internals::DeletePlatformShortcuts, shortcut_data_dir),
-      std::move(shortcut_info));
 }
 
 void UpdateAllShortcuts(const base::string16& old_app_title,
diff --git a/chrome/browser/web_applications/web_app_android.cc b/chrome/browser/web_applications/web_app_android.cc
new file mode 100644
index 000000000000..4845c0cacf57
--- /dev/null
+++ b/chrome/browser/web_applications/web_app_android.cc
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/web_applications/web_app.h"
+
+#include <utility>
+
+#include "base/environment.h"
+#include "base/logging.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "chrome/browser/shell_integration_linux.h"
+
+namespace web_app {
+
+void UpdateShortcutsForAllApps(Profile* profile,
+                               const base::Closure& callback) {
+}
+
+namespace internals {
+
+bool CreatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutLocations& creation_locations,
+                             ShortcutCreationReason /*creation_reason*/,
+                             const ShortcutInfo& shortcut_info) {
+  return false;
+}
+
+void DeletePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void UpdatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const base::string16& /*old_app_title*/,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
+}
+
+}  // namespace internals
+
+}  // namespace web_app
diff --git a/chrome/chrome_paks.gni b/chrome/chrome_paks.gni
index 6469473e6a79..7b2d4145cdac 100644
--- a/chrome/chrome_paks.gni
+++ b/chrome/chrome_paks.gni
@@ -121,31 +121,31 @@ template("chrome_extra_paks") {
       sources += invoker.additional_paks
     }
 
-    if (!is_android) {
+    if (true || !is_android) {
       # New paks should be added here by default.
       sources += [
-        "$root_gen_dir/chrome/bookmarks_resources.pak",
+#        "$root_gen_dir/chrome/bookmarks_resources.pak",
         "$root_gen_dir/chrome/component_extension_resources.pak",
-        "$root_gen_dir/chrome/dev_ui_resources.pak",
-        "$root_gen_dir/chrome/downloads_resources.pak",
-        "$root_gen_dir/chrome/history_resources.pak",
-        "$root_gen_dir/chrome/local_ntp_resources.pak",
-        "$root_gen_dir/chrome/new_tab_page_resources.pak",
+#        "$root_gen_dir/chrome/dev_ui_resources.pak",
+#        "$root_gen_dir/chrome/downloads_resources.pak",
+#        "$root_gen_dir/chrome/history_resources.pak",
+#        "$root_gen_dir/chrome/local_ntp_resources.pak",
+#        "$root_gen_dir/chrome/new_tab_page_resources.pak",
         "$root_gen_dir/chrome/settings_resources.pak",
-        "$root_gen_dir/content/browser/devtools/devtools_resources.pak",
-        "$root_gen_dir/headless/headless_lib_resources.pak",
+#        "$root_gen_dir/content/browser/devtools/devtools_resources.pak",
+#        "$root_gen_dir/headless/headless_lib_resources.pak",
       ]
       deps += [
-        "//chrome/browser/resources:bookmarks_resources",
-        "//chrome/browser/resources:component_extension_resources",
-        "//chrome/browser/resources:dev_ui_paks",
-        "//chrome/browser/resources:downloads_resources",
-        "//chrome/browser/resources:history_resources",
-        "//chrome/browser/resources:local_ntp_resources",
-        "//chrome/browser/resources:new_tab_page_resources",
-        "//chrome/browser/resources:settings_resources",
-        "//content/browser/devtools:devtools_resources",
-        "//headless:resources",
+#        "//chrome/browser/resources:bookmarks_resources",
+         "//chrome/browser/resources:component_extension_resources",
+#        "//chrome/browser/resources:dev_ui_paks",
+#        "//chrome/browser/resources:downloads_resources",
+#        "//chrome/browser/resources:history_resources",
+#        "//chrome/browser/resources:local_ntp_resources",
+#        "//chrome/browser/resources:new_tab_page_resources",
+         "//chrome/browser/resources:settings_resources",
+#        "//content/browser/devtools:devtools_resources",
+#        "//headless:resources",
       ]
     }
     if (is_chromeos) {
diff --git a/chrome/common/BUILD.gn b/chrome/common/BUILD.gn
index 76d1a2aaa9e2..c19894df3e6e 100644
--- a/chrome/common/BUILD.gn
+++ b/chrome/common/BUILD.gn
@@ -427,7 +427,8 @@ static_library("common") {
       "media/chrome_media_drm_bridge_client.cc",
       "media/chrome_media_drm_bridge_client.h",
     ]
-  } else {
+  }
+  if (true) {
     # Non-Android.
     public_deps += [ "//chrome/common/importer" ]
   }
diff --git a/chrome/common/chrome_features.cc b/chrome/common/chrome_features.cc
index 92da6a9b69af..0beef57a2ce3 100644
--- a/chrome/common/chrome_features.cc
+++ b/chrome/common/chrome_features.cc
@@ -61,7 +61,7 @@ const base::Feature kAppNotificationStatusMessaging{
     "AppNotificationStatusMessaging", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // App Service related flags. See chrome/services/app_service/README.md.
 const base::Feature kAppServiceInstanceRegistry{
     "AppServiceInstanceRegistry", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -345,7 +345,7 @@ const base::Feature kEnableAmbientAuthenticationInGuestSession{
     "EnableAmbientAuthenticationInGuestSession",
     base::FEATURE_ENABLED_BY_DEFAULT};
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Upload enterprise cloud reporting without the extension.
 const base::Feature kEnterpriseReportingInBrowser{
     "EnterpriseReportingInBrowser", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -423,7 +423,7 @@ const base::Feature kHappinessTrackingSystem{"HappinessTrackingSystem",
                                              base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Enables or disables the Happiness Tracking System for Desktop Chrome.
 const base::Feature kHappinessTrackingSurveysForDesktop{
     "HappinessTrackingSurveysForDesktop", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -524,14 +524,7 @@ const base::Feature kAcknowledgeNtpOverrideOnDeactivate{
     "AcknowledgeNtpOverrideOnDeactivate", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
 
-// Enables showing an entry for mixed content in site settings, which controls
-// allowing blockable mixed content. When enabled, the mixed content shield is
-// not shown on the omnibox, since its functionality is replaced by the
-// setting.
-const base::Feature kMixedContentSiteSetting{"MixedContentSiteSetting",
-                                             base::FEATURE_DISABLED_BY_DEFAULT};
-
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 const base::Feature kOnConnectNative{"OnConnectNative",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
diff --git a/chrome/common/chrome_features.h b/chrome/common/chrome_features.h
index dece93c2ac41..842f6aab723f 100644
--- a/chrome/common/chrome_features.h
+++ b/chrome/common/chrome_features.h
@@ -51,7 +51,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppNotificationStatusMessaging;
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppServiceInstanceRegistry;
 COMPONENT_EXPORT(CHROME_FEATURES)
@@ -189,7 +189,7 @@ extern const base::Feature kEnableAmbientAuthenticationInGuestSession;
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnableAmbientAuthenticationInIncognito;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnterpriseReportingInBrowser;
 #endif
@@ -257,7 +257,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSystem;
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSurveysForDesktop;
 
@@ -326,7 +326,7 @@ extern const base::Feature kAcknowledgeNtpOverrideOnDeactivate;
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kMixedContentSiteSetting;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kOnConnectNative;
 #endif
 
diff --git a/chrome/common/chrome_paths.cc b/chrome/common/chrome_paths.cc
index 1ca92ba2c97c..cfc50aef8875 100644
--- a/chrome/common/chrome_paths.cc
+++ b/chrome/common/chrome_paths.cc
@@ -545,7 +545,7 @@ bool PathProvider(int key, base::FilePath* result) {
 #endif
       break;
 
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if true || defined(OS_LINUX) || defined(OS_MACOSX)
     case chrome::DIR_NATIVE_MESSAGING:
 #if defined(OS_MACOSX)
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
diff --git a/chrome/common/chrome_paths.h b/chrome/common/chrome_paths.h
index 3f73d868b54e..3be451fbc0da 100644
--- a/chrome/common/chrome_paths.h
+++ b/chrome/common/chrome_paths.h
@@ -122,7 +122,7 @@ enum {
   DIR_SUPERVISED_USER_INSTALLED_WHITELISTS,  // Directory where sanitized
                                              // supervised user whitelists are
                                              // installed.
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if true || defined(OS_LINUX) || defined(OS_MACOSX)
   DIR_NATIVE_MESSAGING,       // System directory where native messaging host
                               // manifest files are stored.
   DIR_USER_NATIVE_MESSAGING,  // Directory with Native Messaging Hosts
diff --git a/chrome/common/chrome_switches.cc b/chrome/common/chrome_switches.cc
index 1af109002ed5..40e5cc9de0c1 100644
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -868,7 +868,7 @@ const char kAllowNaClFileHandleAPI[]        = "allow-nacl-file-handle-api";
 const char kAllowNaClSocketAPI[]            = "allow-nacl-socket-api";
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || true
 const char kEnableNewAppMenuIcon[] = "enable-new-app-menu-icon";
 
 // Causes the browser to launch directly in guest mode.
diff --git a/chrome/common/chrome_switches.h b/chrome/common/chrome_switches.h
index 16b22add7446..1c7266bd7936 100644
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -266,7 +266,7 @@ extern const char kAllowNaClFileHandleAPI[];
 extern const char kAllowNaClSocketAPI[];
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || true
 extern const char kEnableNewAppMenuIcon[];
 extern const char kGuest[];
 #endif
diff --git a/chrome/common/extensions/api/api_sources.gni b/chrome/common/extensions/api/api_sources.gni
index 582dd954152b..21c82271deab 100644
--- a/chrome/common/extensions/api/api_sources.gni
+++ b/chrome/common/extensions/api/api_sources.gni
@@ -72,7 +72,7 @@ schema_sources_ = [
   "windows.json",
 ]
 
-if (!is_android) {
+if (true || !is_android) {
   schema_sources_ += [ "processes.idl" ]
 }
 
diff --git a/chrome/common/features.gni b/chrome/common/features.gni
index d3939aa0de92..6e00e2bcfc05 100644
--- a/chrome/common/features.gni
+++ b/chrome/common/features.gni
@@ -30,8 +30,8 @@ declare_args() {
   builtin_cert_verifier_policy_supported = is_chromeos || is_desktop_linux
 
   # Enables support for background apps.
-  enable_background_contents = !is_android && !is_chromecast
-  enable_background_mode = !is_android && !is_chromecast && !is_chromeos
+  enable_background_contents = !is_chromecast
+  enable_background_mode = !is_chromecast && !is_chromeos
 
   # Enable the printing system dialog for platforms that support printing
   # and have a system dialog.
diff --git a/chrome/common/importer/BUILD.gn b/chrome/common/importer/BUILD.gn
index 9dffb6e3625f..c479c2cdcfc6 100644
--- a/chrome/common/importer/BUILD.gn
+++ b/chrome/common/importer/BUILD.gn
@@ -23,6 +23,7 @@ source_set("importer") {
     "firefox_importer_utils.cc",
     "firefox_importer_utils.h",
     "firefox_importer_utils_linux.cc",
+    "firefox_importer_utils_android.cc",
     "firefox_importer_utils_mac.mm",
     "firefox_importer_utils_win.cc",
     "ie_importer_utils_win.cc",
diff --git a/chrome/common/importer/firefox_importer_utils_android.cc b/chrome/common/importer/firefox_importer_utils_android.cc
new file mode 100644
index 000000000000..1935dcb3b96f
--- /dev/null
+++ b/chrome/common/importer/firefox_importer_utils_android.cc
@@ -0,0 +1,25 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/common/importer/firefox_importer_utils.h"
+
+#include "base/base_paths.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+
+base::FilePath GetProfilesINI() {
+  base::FilePath ini_file;
+  // The default location of the profile folder containing user data is
+  // under user HOME directory in .mozilla/firefox folder on Linux.
+  base::FilePath home;
+  base::PathService::Get(base::DIR_HOME, &home);
+  if (!home.empty()) {
+    ini_file = home.Append(".mozilla/firefox/profiles.ini");
+  }
+  if (base::PathExists(ini_file))
+    return ini_file;
+
+  return base::FilePath();
+}
diff --git a/chrome/common/media_router/BUILD.gn b/chrome/common/media_router/BUILD.gn
index 2f2532375913..2421f2d85cbd 100644
--- a/chrome/common/media_router/BUILD.gn
+++ b/chrome/common/media_router/BUILD.gn
@@ -33,7 +33,7 @@ static_library("router") {
 
   deps = []
 
-  if (!is_android) {
+  if (true || !is_android) {
     sources += [
       "discovery/media_sink_service_base.cc",
       "discovery/media_sink_service_base.h",
diff --git a/chrome/common/pref_names.cc b/chrome/common/pref_names.cc
index 59e7a98db766..619f1210ca39 100644
--- a/chrome/common/pref_names.cc
+++ b/chrome/common/pref_names.cc
@@ -1031,7 +1031,7 @@ const char kSpeechRecognitionFilterProfanities[] =
 // permitted.
 const char kAllowDeletingBrowserHistory[] = "history.deleting_enabled";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Whether the "Click here to clear your browsing data" tooltip promo has been
 // shown on the History page.
 const char kHistoryMenuPromoShown[] = "history.menu_promo_shown";
@@ -1188,7 +1188,7 @@ const char kContentSettingsPluginWhitelist[] =
     "profile.content_settings.plugin_whitelist";
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Double that indicates the default zoom level.
 const char kPartitionDefaultZoomLevel[] = "partition.default_zoom_level";
 
@@ -1466,7 +1466,7 @@ const char kWebRtcEventLogCollectionAllowed[] = "webrtc.event_logs_collection";
 // in ICE candidates.
 const char kWebRtcLocalIpsAllowedUrls[] = "webrtc.local_ips_allowed_urls";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Whether or not this profile has been shown the Welcome page.
 const char kHasSeenWelcomePage[] = "browser.has_seen_welcome_page";
 #endif
@@ -1635,7 +1635,7 @@ const char kDefaultTasksBySuffix[] =
 // send text across devices.
 const char kSharedClipboardEnabled[] = "browser.shared_clipboard_enabled";
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 // A flag to enable/disable the Click to Call feature which enables users to
 // send phone numbers from desktop to Android phones.
 const char kClickToCallEnabled[] = "browser.click_to_call_enabled";
@@ -1669,7 +1669,7 @@ const char kShutdownNumProcessesSlow[] = "shutdown.num_processes_slow";
 // before shutting everything down.
 const char kRestartLastSessionOnShutdown[] = "restart.last.session.on.shutdown";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 // Pref name for the policy controlling presentation of full-tab promotional
 // and/or educational content.
@@ -1712,7 +1712,7 @@ const char kNtpCollapsedSnapshotDocument[] = "ntp.collapsed_snapshot_document";
 
 // Keeps track of sync promo collapsed state in the Other Devices menu.
 const char kNtpCollapsedSyncPromo[] = "ntp.collapsed_sync_promo";
-#else
+
 // Holds info for New Tab Page custom background
 const char kNtpCustomBackgroundDict[] = "ntp.custom_background_dict";
 const char kNtpCustomBackgroundLocalToDevice[] =
@@ -1779,7 +1779,7 @@ const char kDevToolsTCPDiscoveryConfig[] = "devtools.tcp_discovery_config";
 // A dictionary with generic DevTools settings.
 const char kDevToolsPreferences[] = "devtools.preferences";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Tracks the number of times the dice signin promo has been shown in the user
 // menu.
 const char kDiceSigninUserMenuPromoCount[] = "sync_promo.user_menu_show_count";
@@ -2276,13 +2276,13 @@ const char kSystemTimezoneAutomaticDetectionPolicy[] =
 
 // Pref name for the policy controlling whether to enable Media Router.
 const char kEnableMediaRouter[] = "media_router.enable_media_router";
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Pref name for the policy controlling whether to force the Cast icon to be
 // shown in the toolbar/overflow menu.
 const char kShowCastIconInToolbar[] = "media_router.show_cast_icon_in_toolbar";
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Pref name for the policy controlling the way in which users are notified of
 // the need to relaunch the browser for a pending update.
 const char kRelaunchNotification[] = "browser.relaunch_notification";
@@ -2395,7 +2395,7 @@ const char kCustomHandlersEnabled[] = "custom_handlers.enabled";
 // by the cloud policy subsystem.
 const char kDevicePolicyRefreshRate[] = "policy.device_refresh_rate";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // A boolean where true means that the browser has previously attempted to
 // enable autoupdate and failed, so the next out-of-date browser start should
 // not prompt the user to enable autoupdate, it should offer to reinstall Chrome
@@ -2524,7 +2524,7 @@ const char kRecoveryComponentNeedsElevation[] =
 const char kRegisteredSupervisedUserWhitelists[] =
     "supervised_users.whitelists";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Boolean that indicates whether Chrome enterprise cloud reporting is enabled
 // or not.
 const char kCloudReportingEnabled[] =
@@ -2791,7 +2791,7 @@ const char kSitePerProcess[] = "site_isolation.site_per_process";
 const char kUserTriggeredIsolatedOrigins[] =
     "site_isolation.user_triggered_isolated_origins";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Boolean that specifies whether media (audio/video) autoplay is allowed.
 const char kAutoplayAllowed[] = "media.autoplay_allowed";
 
@@ -2863,7 +2863,7 @@ const char kSharingSyncedDevices[] = "sharing.synced_devices";
 const char kSharingFCMRegistration[] = "sharing.fcm_registration";
 const char kSharingLocalSharingInfo[] = "sharing.local_sharing_info";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Dictionary that contains all of the Hats Survey Metadata.
 const char kHatsSurveyMetadata[] = "hats.survey_metadata";
 #endif  // !defined(OS_ANDROID)
diff --git a/chrome/common/pref_names.h b/chrome/common/pref_names.h
index 1da0029dfe92..8f7622c230ea 100644
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -325,7 +325,7 @@ extern const char kDeviceLoginScreenWebUsbAllowDevicesForUrls[];
 extern const char kShowHomeButton[];
 extern const char kSpeechRecognitionFilterProfanities[];
 extern const char kAllowDeletingBrowserHistory[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHistoryMenuPromoShown[];
 #endif
 extern const char kForceGoogleSafeSearch[];
@@ -368,7 +368,7 @@ extern const char kUseCustomChromeFrame[];
 #if BUILDFLAG(ENABLE_PLUGINS)
 extern const char kContentSettingsPluginWhitelist[];
 #endif
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kPartitionDefaultZoomLevel[];
 extern const char kPartitionPerHostZoomLevels[];
 
@@ -474,7 +474,7 @@ extern const char kWebRTCUDPPortRange[];
 extern const char kWebRtcEventLogCollectionAllowed[];
 extern const char kWebRtcLocalIpsAllowedUrls[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHasSeenWelcomePage[];
 #endif
 
@@ -544,7 +544,7 @@ extern const char kDefaultTasksBySuffix[];
 
 extern const char kSharedClipboardEnabled[];
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 extern const char kClickToCallEnabled[];
 #endif  // BUILDFLAG(ENABLE_CLICK_TO_CALL)
 
@@ -560,7 +560,7 @@ extern const char kShutdownNumProcesses[];
 extern const char kShutdownNumProcessesSlow[];
 
 extern const char kRestartLastSessionOnShutdown[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 extern const char kPromotionalTabsEnabled[];
 extern const char kCommandLineFlagSecurityWarningsEnabled[];
@@ -577,7 +577,7 @@ extern const char kNtpCollapsedForeignSessions[];
 extern const char kNtpCollapsedRecentlyClosedTabs[];
 extern const char kNtpCollapsedSnapshotDocument[];
 extern const char kNtpCollapsedSyncPromo[];
-#else
+
 extern const char kNtpCustomBackgroundDict[];
 extern const char kNtpCustomBackgroundLocalToDevice[];
 extern const char kNtpPromoBlocklist[];
@@ -602,7 +602,7 @@ extern const char kDevToolsPreferences[];
 extern const char kDevToolsDiscoverTCPTargetsEnabled[];
 extern const char kDevToolsTCPDiscoveryConfig[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kDiceSigninUserMenuPromoCount[];
 #endif
 
@@ -795,11 +795,11 @@ extern const char kSystemTimezoneAutomaticDetectionPolicy[];
 #endif  // defined(OS_CHROMEOS)
 
 extern const char kEnableMediaRouter[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kShowCastIconInToolbar[];
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kRelaunchNotification[];
 extern const char kRelaunchNotificationPeriod[];
 #endif  // !defined(OS_ANDROID)
@@ -808,7 +808,7 @@ extern const char kRelaunchNotificationPeriod[];
 extern const char kRelaunchHeadsUpPeriod[];
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kAttemptedToEnableAutoupdate[];
 
 extern const char kMediaGalleriesUniqueId[];
@@ -858,7 +858,7 @@ extern const char kRecoveryComponentNeedsElevation[];
 
 extern const char kRegisteredSupervisedUserWhitelists[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kCloudReportingEnabled[];
 extern const char kCloudExtensionRequestEnabled[];
 extern const char kCloudExtensionRequestIds[];
@@ -968,7 +968,7 @@ extern const char kIsolateOrigins[];
 extern const char kSitePerProcess[];
 extern const char kUserTriggeredIsolatedOrigins[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kAutoplayAllowed[];
 extern const char kAutoplayWhitelist[];
 extern const char kBlockAutoplayEnabled[];
@@ -1005,7 +1005,7 @@ extern const char kSharingSyncedDevices[];
 extern const char kSharingFCMRegistration[];
 extern const char kSharingLocalSharingInfo[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHatsSurveyMetadata[];
 #endif  // !defined(OS_ANDROID)
 
diff --git a/chrome/common/url_constants.cc b/chrome/common/url_constants.cc
index ce5309843e4f..d6d843c482dc 100644
--- a/chrome/common/url_constants.cc
+++ b/chrome/common/url_constants.cc
@@ -381,12 +381,12 @@ const char kWindowsXPVistaDeprecationURL[] =
     "https://chrome.blogspot.com/2015/11/updates-to-chrome-platform-support.html";
 #endif
 
-#if BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
+#if true || BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
 const char kChromeSyncLearnMoreURL[] =
     "https://support.google.com/chrome/answer/165139";
 #endif  // BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
 const char kBlockedPluginLearnMoreURL[] =
     "https://support.google.com/chrome/?p=ib_blocked_plugin";
 
diff --git a/chrome/common/url_constants.h b/chrome/common/url_constants.h
index 7791697d1afb..5a8b1a6b62a9 100644
--- a/chrome/common/url_constants.h
+++ b/chrome/common/url_constants.h
@@ -341,12 +341,12 @@ extern const char kChromeCleanerLearnMoreURL[];
 extern const char kWindowsXPVistaDeprecationURL[];
 #endif
 
-#if BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
+#if true || BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
 // "Learn more" URL for the one click signin infobar.
 extern const char kChromeSyncLearnMoreURL[];
 #endif
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
 // The URL for the "Learn more" page for the blocked plugin infobar.
 extern const char kBlockedPluginLearnMoreURL[];
 
diff --git a/chrome/common/webui_url_constants.cc b/chrome/common/webui_url_constants.cc
index 5885ecf4bc99..91e75ccdc979 100644
--- a/chrome/common/webui_url_constants.cc
+++ b/chrome/common/webui_url_constants.cc
@@ -316,7 +316,7 @@ bool IsSystemWebUIHost(base::StringPiece host) {
 const char kChromeUICastHost[] = "cast";
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 const char kChromeUIDiscardsHost[] = "discards";
 const char kChromeUIDiscardsURL[] = "chrome://discards/";
 const char kChromeUIHatsHost[] = "hats";
@@ -332,7 +332,7 @@ const char kChromeUISandboxHost[] = "sandbox";
 #endif
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || true
 const char kChromeUIBrowserSwitchHost[] = "browser-switch";
 const char kChromeUIBrowserSwitchURL[] = "chrome://browser-switch/";
 #endif
diff --git a/chrome/common/webui_url_constants.h b/chrome/common/webui_url_constants.h
index 8618c9d0b341..54ba7f26ec04 100644
--- a/chrome/common/webui_url_constants.h
+++ b/chrome/common/webui_url_constants.h
@@ -274,7 +274,7 @@ bool IsSystemWebUIHost(base::StringPiece host);
 extern const char kChromeUICastHost[];
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 extern const char kChromeUIDiscardsHost[];
 extern const char kChromeUIDiscardsURL[];
 extern const char kChromeUIHatsHost[];
@@ -291,7 +291,7 @@ extern const char kChromeUISandboxHost[];
 #endif
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || true
 extern const char kChromeUIBrowserSwitchHost[];
 extern const char kChromeUIBrowserSwitchURL[];
 #endif
diff --git a/chrome/renderer/BUILD.gn b/chrome/renderer/BUILD.gn
index 4e229c16628f..dec1614bc153 100644
--- a/chrome/renderer/BUILD.gn
+++ b/chrome/renderer/BUILD.gn
@@ -204,24 +204,6 @@ jumbo_static_library("renderer") {
   }
   if (enable_plugins) {
     sources += [
-      "pepper/chrome_renderer_pepper_host_factory.cc",
-      "pepper/chrome_renderer_pepper_host_factory.h",
-      "pepper/pepper_flash_drm_renderer_host.cc",
-      "pepper/pepper_flash_drm_renderer_host.h",
-      "pepper/pepper_flash_font_file_host.cc",
-      "pepper/pepper_flash_font_file_host.h",
-      "pepper/pepper_flash_fullscreen_host.cc",
-      "pepper/pepper_flash_fullscreen_host.h",
-      "pepper/pepper_flash_menu_host.cc",
-      "pepper/pepper_flash_menu_host.h",
-      "pepper/pepper_flash_renderer_host.cc",
-      "pepper/pepper_flash_renderer_host.h",
-      "pepper/pepper_helper.cc",
-      "pepper/pepper_helper.h",
-      "pepper/pepper_shared_memory_message_filter.cc",
-      "pepper/pepper_shared_memory_message_filter.h",
-      "pepper/pepper_uma_host.cc",
-      "pepper/pepper_uma_host.h",
       "plugins/chrome_plugin_placeholder.cc",
       "plugins/chrome_plugin_placeholder.h",
       "plugins/plugin_preroller.cc",
@@ -230,7 +212,7 @@ jumbo_static_library("renderer") {
       "plugins/power_saver_info.h",
     ]
     deps += [
-      "//components/pdf/renderer",
+#      "//components/pdf/renderer",
       "//components/strings",
       "//media:media_buildflags",
       "//ppapi/host",
diff --git a/chrome/renderer/chrome_content_renderer_client.cc b/chrome/renderer/chrome_content_renderer_client.cc
index ffde51cd276a..16bf53253a02 100644
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -493,7 +493,7 @@ void ChromeContentRendererClient::RenderFrameCreated(
 #endif
 
 #if BUILDFLAG(ENABLE_PLUGINS)
-  new PepperHelper(render_frame);
+  // new PepperHelper(render_frame);
 #endif
 
 #if BUILDFLAG(ENABLE_NACL)
@@ -634,7 +634,7 @@ bool ChromeContentRendererClient::IsPluginHandledExternally(
     const blink::WebElement& plugin_element,
     const GURL& original_url,
     const std::string& mime_type) {
-#if BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PLUGINS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PLUGINS)
   DCHECK(plugin_element.HasHTMLTagName("object") ||
          plugin_element.HasHTMLTagName("embed"));
   // Blink will next try to load a WebPlugin which would end up in
diff --git a/chrome/renderer/content_settings_agent_impl.cc b/chrome/renderer/content_settings_agent_impl.cc
index 825945721518..ff6fb81f0501 100644
--- a/chrome/renderer/content_settings_agent_impl.cc
+++ b/chrome/renderer/content_settings_agent_impl.cc
@@ -433,7 +433,8 @@ bool ContentSettingsAgentImpl::AllowRunningInsecureContent(
     const blink::WebURL& resource_url) {
   bool allow = allowed_per_settings;
 
-  if (base::FeatureList::IsEnabled(features::kMixedContentSiteSetting)) {
+//  if (base::FeatureList::IsEnabled(features::kMixedContentSiteSetting)) {
+  if (0) {
     if (content_setting_rules_) {
       auto setting = GetContentSettingFromRules(
           content_setting_rules_->mixed_content_rules,
diff --git a/chrome/renderer/media/chrome_key_systems.cc b/chrome/renderer/media/chrome_key_systems.cc
index b1c800648c70..61d8af548ec9 100644
--- a/chrome/renderer/media/chrome_key_systems.cc
+++ b/chrome/renderer/media/chrome_key_systems.cc
@@ -329,7 +329,7 @@ void AddChromeKeySystems(
 
 #endif  // BUILDFLAG(ENABLE_LIBRARY_CDMS)
 
-#if defined(OS_ANDROID)
+#if BUILDFLAG(ENABLE_WIDEVINE) and defined(OS_ANDROID)
   cdm::AddAndroidWidevine(key_systems_properties);
 #endif  // defined(OS_ANDROID)
 }
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 492c4d805d60..466755a23a83 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -4313,7 +4313,7 @@ test("unit_tests") {
     }
   }
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     sources += [
       "../../apps/saved_files_service_unittest.cc",
       "../../tools/json_schema_compiler/test/features_generation_unittest.cc",
diff --git a/chromecast/browser/cast_browser_context.cc b/chromecast/browser/cast_browser_context.cc
index 90dad23b3713..efa9fbd77f57 100644
--- a/chromecast/browser/cast_browser_context.cc
+++ b/chromecast/browser/cast_browser_context.cc
@@ -81,7 +81,7 @@ void CastBrowserContext::InitWhileIOAllowed() {
   BrowserContext::Initialize(this, path_);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 CastBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
diff --git a/chromecast/browser/cast_browser_context.h b/chromecast/browser/cast_browser_context.h
index 7b0b36c8e0fd..dc1fdbb634aa 100644
--- a/chromecast/browser/cast_browser_context.h
+++ b/chromecast/browser/cast_browser_context.h
@@ -25,7 +25,7 @@ class CastBrowserContext final : public content::BrowserContext {
   ~CastBrowserContext() override;
 
   // BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
diff --git a/components/BUILD.gn b/components/BUILD.gn
index a2cae3efc0b5..208dc0a85410 100644
--- a/components/BUILD.gn
+++ b/components/BUILD.gn
@@ -587,7 +587,7 @@ if (!is_ios && !is_fuchsia) {
       data += [ "$root_out_dir/Content Shell.app/" ]
     }
 
-    if (enable_plugins) {
+    if (false && enable_plugins) {
       sources += [ "pdf/renderer/pdf_accessibility_tree_browsertest.cc" ]
       deps += [
         "//components/pdf/renderer",
diff --git a/components/autofill_payments_strings.grdp b/components/autofill_payments_strings.grdp
index 594ca8cbbceb..526f3a0625cf 100644
--- a/components/autofill_payments_strings.grdp
+++ b/components/autofill_payments_strings.grdp
@@ -68,7 +68,7 @@
     </if>
   </if>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_AUTOFILL_FIELD_LABEL_PHONE" desc="The label of the Phone entry in a settings-like UI to enter a phone number.">
       Phone
     </message>
@@ -79,19 +79,15 @@
 
   <!-- Autofill save credit card bubble or infobar prompt -->
   <if expr="is_android or is_ios">
-    <then>
       <message name="IDS_AUTOFILL_SAVE_CARD_INFOBAR_ACCEPT" desc="Text to show for the Autofill save credit card infobar accept button.">
         Save
       </message>
-    </then>
-    <else>
       <message name="IDS_AUTOFILL_SAVE_CARD_BUBBLE_LOCAL_SAVE_ACCEPT" desc="Text to show for the Autofill save credit card local save bubble accept button.">
         Save
       </message>
       <message name="IDS_AUTOFILL_SAVE_CARD_BUBBLE_UPLOAD_SAVE_ACCEPT" desc="Text to show for the Autofill save credit card upload save bubble accept button.">
         Save
       </message>
-    </else>
   </if>
   <if expr="is_android">
     <message name="IDS_AUTOFILL_SAVE_CARD_PROMPT_CONFIRM" desc="Text to show for the Autofill upload save credit card prompt accept button when more information (e.g., CVC) was needed in order to save the card and was entered." formatter_data="android_java">
@@ -202,7 +198,7 @@
   </message>
 
   <!-- Autofill Local card migration bubble or dialog -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <message name="IDS_AUTOFILL_GOOGLE_PAY_LOGO_ACCESSIBLE_NAME" desc="The accessible name for the Google Pay logo in the local card migration bubble or dialog.">
       Google Pay logo
     </message>
@@ -406,7 +402,7 @@
 
   <!-- WebAuthn fingerprint opt-in dialog -->
   <!-- Desktop only -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <if expr="is_macosx">
       <message name="IDS_AUTOFILL_WEBAUTHN_OPT_IN_DIALOG_TITLE" desc="Headline asking the user if they want to use their device's platform authenticator to confirm their cards in the future instead of CVC.">
         Use Touch ID instead of CVC?
@@ -462,7 +458,7 @@
 
   <!-- Webauthn verify pending dialog -->
   <!-- Desktop only -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <message name="IDS_AUTOFILL_WEBAUTHN_VERIFY_PENDING_DIALOG_TITLE" desc="Headline of the dialog shown when user has opted in to use platform biometric authenticator and has selected one card to fill the form. This shows the verification of the selected card is in progress.">
         Verifying your identity...
     </message>
diff --git a/components/autofill_strings.grdp b/components/autofill_strings.grdp
index 5c3061f09013..7a8e00c80eec 100644
--- a/components/autofill_strings.grdp
+++ b/components/autofill_strings.grdp
@@ -165,7 +165,7 @@
     Show cards from your Google Account
   </message>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_AUTOFILL_POPUP_ACCESSIBLE_NODE_DATA" desc="The accessibility text to speak when we display an autofill popup.">
       Autofill
     </message>
diff --git a/components/bookmarks/browser/BUILD.gn b/components/bookmarks/browser/BUILD.gn
index a28dfd2b6ea4..d172f2c558d5 100644
--- a/components/bookmarks/browser/BUILD.gn
+++ b/components/bookmarks/browser/BUILD.gn
@@ -80,7 +80,7 @@ static_library("browser") {
     all_dependent_configs = [ "//ui/views:flags" ]
   }
 
-  if (toolkit_views && !is_mac) {
+  if (true || (toolkit_views && !is_mac)) {
     sources += [ "bookmark_node_data_views.cc" ]
   }
 
diff --git a/components/bookmarks/browser/bookmark_node_data.h b/components/bookmarks/browser/bookmark_node_data.h
index fa46f3c18d01..a8caa07dc8d0 100644
--- a/components/bookmarks/browser/bookmark_node_data.h
+++ b/components/bookmarks/browser/bookmark_node_data.h
@@ -18,7 +18,7 @@
 #include "ui/base/clipboard/clipboard_buffer.h"
 #include "url/gurl.h"
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
 #include "ui/base/clipboard/clipboard_format_type.h"
 #endif
 
@@ -27,7 +27,7 @@ class Pickle;
 class PickleIterator;
 }
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
 namespace ui {
 class OSExchangeData;
 }
@@ -114,7 +114,7 @@ struct BookmarkNodeData {
 
   ~BookmarkNodeData();
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
   static const ui::ClipboardFormatType& GetBookmarkFormatType();
 #endif
 
@@ -133,7 +133,7 @@ struct BookmarkNodeData {
   // WriteToClipboard() but will also attempt to read a plain bookmark.
   bool ReadFromClipboard(ui::ClipboardBuffer buffer);
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
   // Writes elements to data. If there is only one element and it is a URL
   // the URL and title are written to the clipboard in a format other apps can
   // use.
diff --git a/components/components_strings.grd b/components/components_strings.grd
index db81ee5c89ff..22e5b2a7b8bf 100644
--- a/components/components_strings.grd
+++ b/components/components_strings.grd
@@ -257,7 +257,7 @@
       <part file="undo_strings.grdp" />
       <part file="version_ui_strings.grdp" />
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="management_strings.grdp" />
       </if>
 
@@ -334,7 +334,7 @@
       <message name="IDS_PLUGIN_NOT_SUPPORTED" desc="The placeholder text for an unsupported plugin.">
         This plugin is not supported
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_PRINT" desc="The text label of the Print... menu item. Opens a dialog box to select print settings">
             &amp;Print...
diff --git a/components/content_settings/core/browser/cookie_settings.cc b/components/content_settings/core/browser/cookie_settings.cc
index 84d150c6bb34..42857e78dfc2 100644
--- a/components/content_settings/core/browser/cookie_settings.cc
+++ b/components/content_settings/core/browser/cookie_settings.cc
@@ -57,6 +57,7 @@ void CookieSettings::GetCookieSettings(
 
 void CookieSettings::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] CookieSettings::RegisterProfilePrefs";
   registry->RegisterBooleanPref(
       prefs::kBlockThirdPartyCookies, false,
       user_prefs::PrefRegistrySyncable::SYNCABLE_PREF);
diff --git a/components/feature_engagement/public/event_constants.cc b/components/feature_engagement/public/event_constants.cc
index 1e8973aceeaa..00cc4010663a 100644
--- a/components/feature_engagement/public/event_constants.cc
+++ b/components/feature_engagement/public/event_constants.cc
@@ -12,13 +12,13 @@ namespace feature_engagement {
 namespace events {
 
 #if defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || true
 const char kNewTabOpened[] = "new_tab_opened";
 #endif  // defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) ||
         // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const char kReopenTabConditionsMet[] = "reopen_tab_conditions_met";
 const char kTabReopened[] = "tab_reopened";
 
diff --git a/components/feature_engagement/public/event_constants.h b/components/feature_engagement/public/event_constants.h
index 638a72e929dc..98b3fefeb966 100644
--- a/components/feature_engagement/public/event_constants.h
+++ b/components/feature_engagement/public/event_constants.h
@@ -14,7 +14,7 @@ namespace events {
 
 // Desktop and IOS.
 #if defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || true
 // The user has explicitly opened a new tab via an entry point from inside of
 // Chrome.
 extern const char kNewTabOpened[];
@@ -23,7 +23,7 @@ extern const char kNewTabOpened[];
 
 // Desktop
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 // All conditions for reopen closed tab IPH were met. Since this IPH needs to
 // track user events (opening/closing tabs, focusing the omnibox, etc) on the
 // second level, it must be done manually.
diff --git a/components/feature_engagement/public/feature_constants.cc b/components/feature_engagement/public/feature_constants.cc
index 520aa2894612..2a495883924a 100644
--- a/components/feature_engagement/public/feature_constants.cc
+++ b/components/feature_engagement/public/feature_constants.cc
@@ -15,7 +15,7 @@ const base::Feature kIPHDummyFeature{"IPH_Dummy",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const base::Feature kIPHFocusModeFeature{"IPH_FocusMode",
                                          base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kIPHGlobalMediaControlsFeature{
diff --git a/components/feature_engagement/public/feature_constants.h b/components/feature_engagement/public/feature_constants.h
index de4b4117da04..eb47a316c6a0 100644
--- a/components/feature_engagement/public/feature_constants.h
+++ b/components/feature_engagement/public/feature_constants.h
@@ -18,7 +18,7 @@ extern const base::Feature kIPHDemoMode;
 extern const base::Feature kIPHDummyFeature;
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 extern const base::Feature kIPHFocusModeFeature;
 extern const base::Feature kIPHGlobalMediaControlsFeature;
 extern const base::Feature kIPHReopenTabFeature;
diff --git a/components/guest_view/browser/BUILD.gn b/components/guest_view/browser/BUILD.gn
index c13fb5b75886..a1bd569db576 100644
--- a/components/guest_view/browser/BUILD.gn
+++ b/components/guest_view/browser/BUILD.gn
@@ -6,7 +6,7 @@
 # assert to prevent the accidental building of GuestViews on mobile
 # platforms. If you're now using GuestViews on mobile, go ahead and
 # remove this assert.
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 static_library("browser") {
   output_name = "guest_view_browser"
diff --git a/components/guest_view/renderer/BUILD.gn b/components/guest_view/renderer/BUILD.gn
index 51327be6d41e..293dc296f110 100644
--- a/components/guest_view/renderer/BUILD.gn
+++ b/components/guest_view/renderer/BUILD.gn
@@ -6,7 +6,7 @@
 # assert to prevent the accidental building of GuestViews on mobile
 # platforms. If you're now using GuestViews on mobile, go ahead and
 # remove this assert.
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 static_library("renderer") {
   sources = [
diff --git a/components/history_strings.grdp b/components/history_strings.grdp
index 48d5f1e84988..ec2e274037b5 100644
--- a/components/history_strings.grdp
+++ b/components/history_strings.grdp
@@ -63,7 +63,7 @@
       Clear Browsing Data...
     </message>
   </if>
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_HISTORY_OTHER_SESSIONS_COLLAPSE_SESSION" desc="In the 'Other Sessions' menu on the history page, the label for the command to collapse (hide) the list of windows and tabs in a session.">
       Collapse list
     </message>
diff --git a/components/keep_alive_registry/BUILD.gn b/components/keep_alive_registry/BUILD.gn
index a2d881330f8d..b40afc237592 100644
--- a/components/keep_alive_registry/BUILD.gn
+++ b/components/keep_alive_registry/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android)
+# assert(!is_android)
 
 source_set("keep_alive_registry") {
   sources = [
diff --git a/components/new_or_sad_tab_strings.grdp b/components/new_or_sad_tab_strings.grdp
index ffd57decf406..b16be2aeff6f 100644
--- a/components/new_or_sad_tab_strings.grdp
+++ b/components/new_or_sad_tab_strings.grdp
@@ -112,7 +112,7 @@
                desc="Title of the new tab page, not to be confused with the action of opening a new tab.">
         New Tab
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_NEW_TAB_OTR_HEADING"
                  desc="Heading used when a person opens an OTR window">
           You’ve gone incognito
diff --git a/components/page_info_strings.grdp b/components/page_info_strings.grdp
index 5bac7335cb40..b0afe41cc959 100644
--- a/components/page_info_strings.grdp
+++ b/components/page_info_strings.grdp
@@ -175,7 +175,7 @@
     </message>
 
     <!-- Certificate Viewer link -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_PAGE_INFO_CERTIFICATE" desc="Title of the certificate area in the Page Info bubble, shown when a HTTPS site is loaded.">
         Certificate
       </message>
@@ -203,7 +203,7 @@
     </if>
 
     <!-- Cookies -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_PAGE_INFO_COOKIES" desc="The label for the Cookies setting in the Page Information Window.">
         Cookies
       </message>
@@ -405,8 +405,8 @@
     </message>
 
     <!-- Permission change infobar. -->
-    <if expr="not is_android">
-      <message name="IDS_PAGE_INFO_INFOBAR_TEXT" desc="The string shown in the infobar after the user has changed site permissions settings, reminding them to reload the page in order for the new settings to take effect.">
+    <if expr="is_android or not is_android">
+      <message name=" IDS_PAGE_INFO_INFOBAR_TEXT" desc="The string shown in the infobar after the user has changed site permissions settings, reminding them to reload the page in order for the new settings to take effect.">
         To apply your updated settings to this site, reload this page
       </message>
       <message name="IDS_PAGE_INFO_INFOBAR_BUTTON" desc="The string used in the infobar button allowing the user to reload the page directly from the infobar.">
@@ -415,7 +415,7 @@
     </if>
 
     <!-- Password Protection -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_PAGE_INFO_CHANGE_PASSWORD_SUMMARY" desc="A one-line summary at the top of the Page Info bubble (which shows when you click the security indicator) if user has reuse their google password on current website.">
         Your password may be compromised
       </message>
diff --git a/components/payments/content/payment_request.cc b/components/payments/content/payment_request.cc
index 17f7acf0f47b..9fdad0a32c19 100644
--- a/components/payments/content/payment_request.cc
+++ b/components/payments/content/payment_request.cc
@@ -126,7 +126,7 @@ void PaymentRequest::Init(
     mojo::PendingRemote<mojom::PaymentRequestClient> client,
     std::vector<mojom::PaymentMethodDataPtr> method_data,
     mojom::PaymentDetailsPtr details,
-    mojom::PaymentOptionsPtr options) {
+    mojom::PaymentOptionsPtr options, bool google_pay_bridge_eligible) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   if (is_initialized_) {
diff --git a/components/payments/content/payment_request.h b/components/payments/content/payment_request.h
index 5c77ab5d8040..dbb976431f98 100644
--- a/components/payments/content/payment_request.h
+++ b/components/payments/content/payment_request.h
@@ -72,7 +72,7 @@ class PaymentRequest : public mojom::PaymentRequest,
   void Init(mojo::PendingRemote<mojom::PaymentRequestClient> client,
             std::vector<mojom::PaymentMethodDataPtr> method_data,
             mojom::PaymentDetailsPtr details,
-            mojom::PaymentOptionsPtr options) override;
+            mojom::PaymentOptionsPtr options, bool google_pay_bridge_eligible) override;
   void Show(bool is_user_gesture, bool wait_for_updated_details) override;
   void Retry(mojom::PaymentValidationErrorsPtr errors) override;
   void UpdateWith(mojom::PaymentDetailsPtr details) override;
diff --git a/components/payments_strings.grdp b/components/payments_strings.grdp
index 3d51145884ca..5d0123be1449 100644
--- a/components/payments_strings.grdp
+++ b/components/payments_strings.grdp
@@ -603,7 +603,7 @@
   </if>
 
   <!-- Payment Request section preview strings. They are slightly different on desktop and android because the pluralization and formatting code behaves differently. -->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_PAYMENT_REQUEST_PAYMENT_METHODS_PREVIEW" desc="This is a snippet of a payment method a user has saved to Chrome, plus an indication of the number of additional payment methods the user has saved. Its function is to show the user has payment methods that can be used to complete a payment, and thus doesn't have to type the entire payment method. [ICU Syntax]">
     {PAYMENT_METHOD, plural,
        =0 {<ph name="PAYMENT_METHOD_PREVIEW">{1}<ex>VISA ....1234</ex></ph>}
diff --git a/components/pdf/renderer/BUILD.gn b/components/pdf/renderer/BUILD.gn
index b729147c0ad8..057c42ddc37e 100644
--- a/components/pdf/renderer/BUILD.gn
+++ b/components/pdf/renderer/BUILD.gn
@@ -25,7 +25,7 @@ jumbo_static_library("renderer") {
     "//content/public/renderer",
     "//gin",
     "//ipc",
-    "//pdf:features",
+#    "//pdf:features",
     "//ppapi/host",
     "//ppapi/proxy",
     "//ppapi/proxy:ipc",
diff --git a/components/pdf_strings.grdp b/components/pdf_strings.grdp
index 9a83490afd59..60829170e6b5 100644
--- a/components/pdf_strings.grdp
+++ b/components/pdf_strings.grdp
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <grit-part>
-  <if expr="enable_plugins">
+  <if expr="is_android or enable_plugins">
     <message name="IDS_PDF_NEED_PASSWORD" desc="A message asking the user for a password to open a PDF file.">
       This document is password protected.  Please enter a password.
     </message>
diff --git a/components/policy/core/browser/configuration_policy_handler.cc b/components/policy/core/browser/configuration_policy_handler.cc
index 41e8f34d246b..92ee822cb957 100644
--- a/components/policy/core/browser/configuration_policy_handler.cc
+++ b/components/policy/core/browser/configuration_policy_handler.cc
@@ -364,6 +364,7 @@ SchemaValidatingPolicyHandler::SchemaValidatingPolicyHandler(
     Schema schema,
     SchemaOnErrorStrategy strategy)
     : policy_name_(policy_name), schema_(schema), strategy_(strategy) {
+  LOG(ERROR) << "[Kiwi] Processing schema: " << policy_name;
   DCHECK(schema_.valid());
 }
 
diff --git a/components/policy/resources/policy_templates.json b/components/policy/resources/policy_templates.json
index 0348733dcf97..74fdf99817f7 100644
--- a/components/policy/resources/policy_templates.json
+++ b/components/policy/resources/policy_templates.json
@@ -3949,7 +3949,7 @@
         'items': { 'type': 'string' },
         'id': 'ExtensionInstallSources',
       },
-      'supported_on': ['chrome.*:21-', 'chrome_os:21-'],
+      'supported_on': ['chrome.*:21-', 'chrome_os:21-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4008,7 +4008,7 @@
         },
         'id': 'ExtensionAllowedTypes',
       },
-      'supported_on': ['chrome.*:25-', 'chrome_os:25-'],
+      'supported_on': ['chrome.*:25-', 'chrome_os:25-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4123,7 +4123,7 @@
         },
       },
       'url_schema': 'https://www.chromium.org/administrators/policy-list-3/extension-settings-full',
-      'supported_on': ['chrome.*:62-', 'chrome_os:62-'],
+      'supported_on': ['chrome.*:62-', 'chrome_os:62-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4395,7 +4395,7 @@
       'owners': ['file://components/policy/resources/OWNERS'],
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome.*:10-', 'chrome_os:11-'],
+      'supported_on': ['chrome.*:10-', 'chrome_os:11-', 'android:30-'],
       'features': {
         'can_be_recommended': True,
         'dynamic_refresh': True,
@@ -16268,7 +16268,7 @@
           'required': ['url']
         }
       },
-      'supported_on': ['chrome.*:75-', 'chrome_os:75-'],
+      'supported_on': ['chrome.*:75-', 'chrome_os:75-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
diff --git a/components/prefs/pref_service.cc b/components/prefs/pref_service.cc
index 3c067f48bd21..09e9dbaf1dfc 100644
--- a/components/prefs/pref_service.cc
+++ b/components/prefs/pref_service.cc
@@ -97,12 +97,16 @@ PrefService::PrefService(
       user_pref_store_(std::move(user_prefs)),
       read_error_callback_(std::move(read_error_callback)),
       pref_registry_(std::move(pref_registry)) {
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 1";
   pref_notifier_->SetPrefService(this);
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 2";
 
   DCHECK(pref_registry_);
   DCHECK(pref_value_store_);
 
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 3";
   InitFromStorage(async);
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 4";
 }
 
 PrefService::~PrefService() {
diff --git a/components/search/search.cc b/components/search/search.cc
index 4a0ae2f553ac..039c72c98849 100644
--- a/components/search/search.cc
+++ b/components/search/search.cc
@@ -9,11 +9,7 @@
 namespace search {
 
 bool IsInstantExtendedAPIEnabled() {
-#if defined(OS_IOS) || defined(OS_ANDROID)
-  return false;
-#else
   return true;
-#endif
 }
 
 }  // namespace search
diff --git a/components/signin/features.gni b/components/signin/features.gni
index f4636abdb3f5..8a7488b6c7da 100644
--- a/components/signin/features.gni
+++ b/components/signin/features.gni
@@ -3,7 +3,7 @@
 # found in the LICENSE file.
 
 # Dice is supported on the platform (but not necessarily enabled).
-enable_dice_support = (is_linux && !is_chromeos) || is_mac || is_win
+enable_dice_support = (is_linux && !is_chromeos) || is_mac || is_win || is_android
 
 # Mirror is enabled and other account consistency mechanisms are not available.
 enable_mirror = is_android || is_ios
diff --git a/components/storage_monitor/storage_monitor.cc b/components/storage_monitor/storage_monitor.cc
index c7b2798ba42b..3f467d510c55 100644
--- a/components/storage_monitor/storage_monitor.cc
+++ b/components/storage_monitor/storage_monitor.cc
@@ -55,8 +55,8 @@ void StorageMonitor::ReceiverImpl::MarkInitialized() {
 void StorageMonitor::Create(
     std::unique_ptr<service_manager::Connector> connector) {
   delete g_storage_monitor;
-  g_storage_monitor = CreateInternal();
-  g_storage_monitor->connector_ = std::move(connector);
+//  g_storage_monitor = CreateInternal();
+//  g_storage_monitor->connector_ = std::move(connector);
 }
 
 service_manager::Connector* StorageMonitor::GetConnector() {
diff --git a/components/sync_ui_strings.grdp b/components/sync_ui_strings.grdp
index c4751313e4b7..efdd4b94327a 100644
--- a/components/sync_ui_strings.grdp
+++ b/components/sync_ui_strings.grdp
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <grit-part>
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_SYNC_BASIC_ENCRYPTION_DATA" desc="Text of the radio that when selected enables basic encryption.">
       Encrypt synced passwords with your Google credentials
     </message>
diff --git a/components/ui_devtools/views/BUILD.gn b/components/ui_devtools/views/BUILD.gn
index e9fb3b231966..a22cb17bdea7 100644
--- a/components/ui_devtools/views/BUILD.gn
+++ b/components/ui_devtools/views/BUILD.gn
@@ -34,6 +34,13 @@ source_set("views") {
     "//ui/views",
   ]
 
+  sources += [
+    "dom_agent_android.cc",
+    "dom_agent_android.h",
+    "overlay_agent_android.cc",
+    "overlay_agent_android.h",
+  ]
+
   if (use_aura) {
     sources += [
       "dom_agent_aura.cc",
diff --git a/components/ui_devtools/views/dom_agent_android.cc b/components/ui_devtools/views/dom_agent_android.cc
new file mode 100644
index 000000000000..4a48894229be
--- /dev/null
+++ b/components/ui_devtools/views/dom_agent_android.cc
@@ -0,0 +1,44 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/ui_devtools/views/dom_agent_android.h"
+
+#include "base/stl_util.h"
+#include "components/ui_devtools/views/widget_element.h"
+#include "components/ui_devtools/views/window_element.h"
+
+namespace ui_devtools {
+
+namespace {
+using ui_devtools::protocol::Array;
+using ui_devtools::protocol::DOM::Node;
+}  // namespace
+
+DOMAgentAndroid* DOMAgentAndroid::dom_agent_android_ = nullptr;
+
+DOMAgentAndroid::DOMAgentAndroid() {
+  DCHECK(!dom_agent_android_);
+  dom_agent_android_ = this;
+}
+
+DOMAgentAndroid::~DOMAgentAndroid() {
+  dom_agent_android_ = nullptr;
+}
+
+std::vector<UIElement*> DOMAgentAndroid::CreateChildrenForRoot() {
+  std::vector<UIElement*> children;
+  return children;
+}
+
+std::unique_ptr<Node> DOMAgentAndroid::BuildTreeForWindow(
+    UIElement* window_element_root) {
+  return nullptr;
+}
+
+// static
+std::unique_ptr<DOMAgentViews> DOMAgentViews::Create() {
+  return std::make_unique<DOMAgentAndroid>();
+}
+
+}  // namespace ui_devtools
diff --git a/components/ui_devtools/views/dom_agent_android.h b/components/ui_devtools/views/dom_agent_android.h
new file mode 100644
index 000000000000..08348d5abc23
--- /dev/null
+++ b/components/ui_devtools/views/dom_agent_android.h
@@ -0,0 +1,32 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_ANDROID_H_
+#define COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_ANDROID_H_
+
+#include "components/ui_devtools/views/dom_agent_views.h"
+
+namespace ui_devtools {
+
+class DOMAgentAndroid : public DOMAgentViews {
+
+ public:
+  DOMAgentAndroid();
+
+  ~DOMAgentAndroid() override;
+  static DOMAgentAndroid* GetInstance() { return dom_agent_android_; }
+
+  std::vector<UIElement*> CreateChildrenForRoot() override;
+
+  std::unique_ptr<protocol::DOM::Node> BuildTreeForWindow(
+      UIElement* window_element_root) override;
+
+ private:
+  static DOMAgentAndroid* dom_agent_android_;
+
+  DISALLOW_COPY_AND_ASSIGN(DOMAgentAndroid);
+};
+}  // namespace ui_devtools
+
+#endif  // COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_AURA_H_
diff --git a/components/ui_devtools/views/overlay_agent_android.cc b/components/ui_devtools/views/overlay_agent_android.cc
new file mode 100644
index 000000000000..986d65734d9c
--- /dev/null
+++ b/components/ui_devtools/views/overlay_agent_android.cc
@@ -0,0 +1,44 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/ui_devtools/views/overlay_agent_android.h"
+
+#include "components/ui_devtools/dom_agent.h"
+#include "components/ui_devtools/views/window_element.h"
+#include "ui/views/view.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/window_util.h"
+
+namespace ui_devtools {
+
+OverlayAgentAndroid* OverlayAgentAndroid::overlay_agent_android_ = nullptr;
+
+OverlayAgentAndroid::OverlayAgentAndroid(DOMAgent* dom_agent)
+    : OverlayAgentViews(dom_agent) {
+  DCHECK(!overlay_agent_android_);
+  overlay_agent_android_ = this;
+}
+
+OverlayAgentAndroid::~OverlayAgentAndroid() {
+  overlay_agent_android_ = nullptr;
+}
+
+void OverlayAgentAndroid::InstallPreTargetHandler() {
+}
+
+void OverlayAgentAndroid::RemovePreTargetHandler() {
+}
+
+int OverlayAgentAndroid::FindElementIdTargetedByPoint(
+    ui::LocatedEvent* event) const {
+  return 0;
+}
+
+// static
+std::unique_ptr<OverlayAgentViews> OverlayAgentViews::Create(
+    DOMAgent* dom_agent) {
+  return std::make_unique<OverlayAgentAndroid>(dom_agent);
+}
+
+}  // namespace ui_devtools
diff --git a/components/ui_devtools/views/overlay_agent_android.h b/components/ui_devtools/views/overlay_agent_android.h
new file mode 100644
index 000000000000..a991a482cc88
--- /dev/null
+++ b/components/ui_devtools/views/overlay_agent_android.h
@@ -0,0 +1,36 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_ANDROID_H_
+#define COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_ANDROID_H_
+
+#include "components/ui_devtools/views/overlay_agent_views.h"
+
+namespace ui_devtools {
+
+class DOMAgent;
+
+class OverlayAgentAndroid : public OverlayAgentViews {
+ public:
+  OverlayAgentAndroid(DOMAgent* dom_agent);
+  ~OverlayAgentAndroid() override;
+
+  int FindElementIdTargetedByPoint(ui::LocatedEvent* event) const override;
+  static OverlayAgentAndroid* GetInstance() { return overlay_agent_android_; }
+
+ private:
+  void InstallPreTargetHandler() override;
+  void RemovePreTargetHandler() override;
+
+  FRIEND_TEST_ALL_PREFIXES(OverlayAgentTest, HighlightWindow);
+  FRIEND_TEST_ALL_PREFIXES(OverlayAgentTest, HighlightEmptyOrInvisibleWindow);
+
+  static OverlayAgentAndroid* overlay_agent_android_;
+
+  DISALLOW_COPY_AND_ASSIGN(OverlayAgentAndroid);
+};
+
+}  // namespace ui_devtools
+
+#endif  // COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_AURA_H_
diff --git a/components/ui_devtools/views/overlay_agent_views.cc b/components/ui_devtools/views/overlay_agent_views.cc
index 70f61fca5812..21b7e22f5f62 100644
--- a/components/ui_devtools/views/overlay_agent_views.cc
+++ b/components/ui_devtools/views/overlay_agent_views.cc
@@ -718,10 +718,6 @@ bool OverlayAgentViews::UpdateHighlight(
   layer_for_highlighting_screen_offset_ =
       widget->GetContentsView()->GetBoundsInScreen().OffsetFromOrigin();
 #else
-  gfx::NativeWindow root = window_and_bounds.first->GetRootWindow();
-  root_layer = root->layer();
-  layer_for_highlighting_screen_offset_ =
-      root->GetBoundsInScreen().OffsetFromOrigin();
 #endif  // defined(OS_MACOSX)
   DCHECK(root_layer);
 
diff --git a/components/url_formatter/elide_url.cc b/components/url_formatter/elide_url.cc
index 24f090a1f9ca..1507b09c6ddc 100644
--- a/components/url_formatter/elide_url.cc
+++ b/components/url_formatter/elide_url.cc
@@ -25,7 +25,7 @@
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 const base::char16 kDot = '.';
 
 // Build a path from the first |num_components| elements in |path_elements|.
@@ -144,7 +144,7 @@ base::string16 HostForDisplay(base::StringPiece host_in_puny) {
 
 namespace url_formatter {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 // TODO(pkasting): http://crbug.com/77883 This whole function gets
 // kerning/ligatures/etc. issues potentially wrong by assuming that the width of
diff --git a/components/url_formatter/elide_url.h b/components/url_formatter/elide_url.h
index e85cd9db25ac..eeb2183c1c5f 100644
--- a/components/url_formatter/elide_url.h
+++ b/components/url_formatter/elide_url.h
@@ -27,7 +27,7 @@ namespace url_formatter {
 
 // ElideUrl and Elide host require
 // gfx::GetStringWidthF which is not implemented in Android
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // This function takes a GURL object and elides it. It returns a string
 // composed of parts from subdomain, domain, path, filename and query.
 // A "..." is added automatically at the end if the elided string is bigger
diff --git a/components/web_modal/BUILD.gn b/components/web_modal/BUILD.gn
index 13b631e563ed..c9f1730937d6 100644
--- a/components/web_modal/BUILD.gn
+++ b/components/web_modal/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 component("web_modal") {
   sources = [
diff --git a/components/zoom/BUILD.gn b/components/zoom/BUILD.gn
index f2813cef4113..5fe591bdb2bf 100644
--- a/components/zoom/BUILD.gn
+++ b/components/zoom/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android && !is_ios, "Desktop zoom is not used on mobile platforms.")
+# assert(!is_android && !is_ios, "Desktop zoom is not used on mobile platforms.")
 
 static_library("zoom") {
   sources = [
diff --git a/content/app/content_main_runner_impl.cc b/content/app/content_main_runner_impl.cc
index 8b3b16ff94f6..c05dc08a4075 100644
--- a/content/app/content_main_runner_impl.cc
+++ b/content/app/content_main_runner_impl.cc
@@ -404,6 +404,7 @@ class ContentClientInitializer {
   static void Set(const std::string& process_type,
                   ContentMainDelegate* delegate) {
     ContentClient* content_client = GetContentClient();
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Step 1";
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
     if (process_type.empty())
       content_client->browser_ = delegate->CreateContentBrowserClient();
@@ -447,6 +448,7 @@ int RunZygote(ContentMainDelegate* delegate) {
     {switches::kPpapiPluginProcess, PpapiPluginMain},
 #endif
   };
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - RunZygote";
 
   std::vector<std::unique_ptr<service_manager::ZygoteForkDelegate>>
       zygote_fork_delegates;
@@ -521,9 +523,11 @@ static void RegisterMainThreadFactories() {
 // Returns the exit code for this process.
 int RunBrowserProcessMain(const MainFunctionParams& main_function_params,
                           ContentMainDelegate* delegate) {
+  LOG(ERROR) << "[Kiwi] RunBrowserProcessMain - Step 1";
   int exit_code = delegate->RunProcess("", main_function_params);
   if (exit_code >= 0)
     return exit_code;
+  LOG(ERROR) << "[Kiwi] RunBrowserProcessMain - Step 2";
   return BrowserMain(main_function_params);
 }
 #endif  // !defined(CHROME_MULTIPLE_DLL_CHILD)
@@ -586,6 +590,7 @@ int ContentMainRunnerImpl::TerminateForFatalInitializationError() {
 }
 
 int ContentMainRunnerImpl::Initialize(const ContentMainParams& params) {
+  LOG(ERROR) << "[Kiwi] ContentMainRunnerImpl::Initialize - Step 1";
   ui_task_ = params.ui_task;
   created_main_parts_closure_ = params.created_main_parts_closure;
 
@@ -863,6 +868,8 @@ int ContentMainRunnerImpl::Run(bool start_service_manager_only) {
 
   RegisterMainThreadFactories();
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager";
+
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
   if (process_type.empty())
     return RunServiceManager(main_params, start_service_manager_only);
@@ -874,26 +881,36 @@ int ContentMainRunnerImpl::Run(bool start_service_manager_only) {
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
 int ContentMainRunnerImpl::RunServiceManager(MainFunctionParams& main_params,
                                              bool start_service_manager_only) {
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 1";
+
   if (is_browser_main_loop_started_)
     return -1;
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 2";
 
   bool should_start_service_manager_only = start_service_manager_only;
   if (!service_manager_environment_) {
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3";
     if (delegate_->ShouldCreateFeatureList()) {
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3-1";
       // This is intentionally leaked since it needs to live for the duration
       // of the process and there's no benefit in cleaning it up at exit.
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3-2";
       base::FieldTrialList* leaked_field_trial_list =
           SetUpFieldTrialsAndFeatureList().release();
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3-3";
       ANNOTATE_LEAKING_OBJECT_PTR(leaked_field_trial_list);
       ignore_result(leaked_field_trial_list);
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3-4";
       delegate_->PostFieldTrialInitialization();
     }
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3a";
 
     if (GetContentClient()->browser()->ShouldCreateThreadPool()) {
       // Create and start the ThreadPool early to allow upcoming code to use
       // the post_task.h API.
       base::ThreadPoolInstance::Create("Browser");
     }
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3b";
 
     delegate_->PreCreateMainMessageLoop();
 #if defined(OS_WIN)
@@ -909,34 +926,46 @@ int ContentMainRunnerImpl::RunServiceManager(MainFunctionParams& main_params,
     // incorrect to post to a BrowserThread before this point. This instantiates
     // and binds the MessageLoopForUI on the main thread (but it's only labeled
     // as BrowserThread::UI in BrowserMainLoop::MainMessageLoopStart).
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3c";
     BrowserTaskExecutor::Create();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3d";
     delegate_->PostEarlyInitialization(main_params.ui_task != nullptr);
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e";
     if (GetContentClient()->browser()->ShouldCreateThreadPool()) {
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e-1";
       // The FeatureList needs to create before starting the ThreadPool.
       StartBrowserThreadPool();
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e-2";
     }
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3f";
 
     BrowserTaskExecutor::PostFeatureListSetup();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3g";
     tracing::InitTracingPostThreadPoolStartAndFeatureList();
 
     if (should_start_service_manager_only)
       ForceInProcessNetworkService(true);
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3h";
     discardable_shared_memory_manager_ =
         std::make_unique<discardable_memory::DiscardableSharedMemoryManager>();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3i";
     // PowerMonitor is needed in reduced mode. BrowserMainLoop will safely skip
     // initializing it again if it has already been initialized.
     base::PowerMonitor::Initialize(
         std::make_unique<base::PowerMonitorDeviceSource>());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3j";
 
     service_manager_environment_ = std::make_unique<ServiceManagerEnvironment>(
         BrowserTaskExecutor::CreateIOThread());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3k";
     download::SetIOTaskRunner(
         service_manager_environment_->ipc_thread()->task_runner());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3l";
 
     InitializeBrowserMemoryInstrumentationClient();
 
@@ -948,15 +977,19 @@ int ContentMainRunnerImpl::RunServiceManager(MainFunctionParams& main_params,
 #endif
   }
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 5";
   if (should_start_service_manager_only) {
     DVLOG(0) << "Chrome is running in ServiceManager only mode.";
     return -1;
   }
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 6";
+
   DVLOG(0) << "Chrome is running in full browser mode.";
   is_browser_main_loop_started_ = true;
   startup_data_ = service_manager_environment_->CreateBrowserStartupData();
   main_params.startup_data = startup_data_.get();
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 7";
   return RunBrowserProcessMain(main_params, delegate_);
 }
 #endif  // !defined(CHROME_MULTIPLE_DLL_CHILD)
diff --git a/content/app/content_service_manager_main_delegate.cc b/content/app/content_service_manager_main_delegate.cc
index 86d0a470a7c2..05a30624b4bf 100644
--- a/content/app/content_service_manager_main_delegate.cc
+++ b/content/app/content_service_manager_main_delegate.cc
@@ -23,6 +23,7 @@ ContentServiceManagerMainDelegate::~ContentServiceManagerMainDelegate() =
 
 int ContentServiceManagerMainDelegate::Initialize(
     const InitializeParams& params) {
+  LOG(ERROR) << "[Kiwi] ContentServiceManagerMainDelegate::Initialize - Step 1";
 #if defined(OS_ANDROID)
   // May be called twice on Android due to the way browser startup requests are
   // dispatched by the system.
@@ -33,6 +34,7 @@ int ContentServiceManagerMainDelegate::Initialize(
 #if defined(OS_MACOSX)
   content_main_params_.autorelease_pool = params.autorelease_pool;
 #endif
+  LOG(ERROR) << "[Kiwi] ContentServiceManagerMainDelegate::Initialize - Step 2";
 
   return content_main_runner_->Initialize(content_main_params_);
 }
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 2cb2b5bbdc88..709c4621328b 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2190,9 +2190,11 @@ jumbo_source_set("browser") {
       "renderer_host/pepper/pepper_truetype_font_host.cc",
       "renderer_host/pepper/pepper_truetype_font_host.h",
       "renderer_host/pepper/pepper_truetype_font_linux.cc",
+      "renderer_host/pepper/pepper_truetype_font_android.cc",
       "renderer_host/pepper/pepper_truetype_font_list.h",
       "renderer_host/pepper/pepper_truetype_font_list_host.cc",
       "renderer_host/pepper/pepper_truetype_font_list_host.h",
+      "renderer_host/pepper/pepper_truetype_font_list_android.cc",
       "renderer_host/pepper/pepper_truetype_font_list_mac.mm",
       "renderer_host/pepper/pepper_truetype_font_list_win.cc",
       "renderer_host/pepper/pepper_truetype_font_mac.mm",
@@ -2417,7 +2419,7 @@ jumbo_source_set("browser") {
     }
     defines += [ "APPCACHE_USE_SIMPLE_CACHE" ]
     libs += [ "jnigraphics" ]
-  } else {
+
     # Not Android.
     sources += [
       # The WebAuthn devtools protocol API is not supported in Android yet.
@@ -2425,8 +2427,6 @@ jumbo_source_set("browser") {
       "$target_gen_dir/devtools/protocol/web_authn.h",
 
       # Devtools frontend not included in Android
-      "devtools/devtools_frontend_host_impl.cc",
-      "devtools/devtools_frontend_host_impl.h",
       "devtools/protocol/webauthn_handler.cc",
       "devtools/protocol/webauthn_handler.h",
       "host_zoom_level_context.cc",
@@ -2564,7 +2564,8 @@ jumbo_source_set("browser") {
     ]
   }
 
-  if (use_aura || is_mac) {
+  if (true || use_aura || is_mac) {
+if (false) {
     sources += [
       "compositor/browser_compositor_output_surface.cc",
       "compositor/browser_compositor_output_surface.h",
@@ -2574,8 +2575,6 @@ jumbo_source_set("browser") {
       "compositor/gpu_process_transport_factory.h",
       "compositor/gpu_surfaceless_browser_compositor_output_surface.cc",
       "compositor/gpu_surfaceless_browser_compositor_output_surface.h",
-      "compositor/image_transport_factory.cc",
-      "compositor/image_transport_factory.h",
       "compositor/offscreen_browser_compositor_output_surface.cc",
       "compositor/offscreen_browser_compositor_output_surface.h",
       "compositor/owned_mailbox.cc",
@@ -2588,6 +2587,11 @@ jumbo_source_set("browser") {
       "compositor/software_browser_compositor_output_surface.h",
       "compositor/viz_process_transport_factory.cc",
       "compositor/viz_process_transport_factory.h",
+    ]
+}
+    sources += [
+      "compositor/image_transport_factory.cc",
+      "compositor/image_transport_factory.h",
       "context_factory.cc",
       "renderer_host/browser_compositor_view_mac.h",
       "renderer_host/browser_compositor_view_mac.mm",
diff --git a/content/browser/browser_main.cc b/content/browser/browser_main.cc
index 65668ab3f5fd..97bed835d9a4 100644
--- a/content/browser/browser_main.cc
+++ b/content/browser/browser_main.cc
@@ -31,6 +31,7 @@ class ScopedBrowserMainEvent {
 
 // Main routine for running as the Browser process.
 int BrowserMain(const MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 1";
   ScopedBrowserMainEvent scoped_browser_main_event;
 
   base::trace_event::TraceLog::GetInstance()->set_process_name("Browser");
@@ -39,13 +40,16 @@ int BrowserMain(const MainFunctionParams& parameters) {
 
   std::unique_ptr<BrowserMainRunnerImpl> main_runner(
       BrowserMainRunnerImpl::Create());
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 2";
 
   int exit_code = main_runner->Initialize(parameters);
   if (exit_code >= 0)
     return exit_code;
 
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 3";
   exit_code = main_runner->Run();
 
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 4";
   main_runner->Shutdown();
 
   return exit_code;
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 9da6475030a7..799dcdde09e9 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -573,6 +573,7 @@ BrowserMainLoop::~BrowserMainLoop() {
 }
 
 void BrowserMainLoop::Init() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::Init - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::Init");
 
   // |startup_data| is optional. If set, the thread owned by the data
@@ -588,6 +589,7 @@ void BrowserMainLoop::Init() {
     service_manager_shutdown_closure_ =
         std::move(startup_data->service_manager_shutdown_closure);
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::Init - Step 2";
 
   parts_ = GetContentClient()->browser()->CreateBrowserMainParts(parameters_);
 }
@@ -827,6 +829,7 @@ void BrowserMainLoop::PostMainMessageLoopStart() {
 }
 
 int BrowserMainLoop::PreCreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PreCreateThreads - Step 1";
   if (parts_) {
     TRACE_EVENT0("startup",
         "BrowserMainLoop::CreateThreads:PreCreateThreads");
@@ -886,6 +889,7 @@ int BrowserMainLoop::PreCreateThreads() {
 
   // Record metrics about which site isolation flags have been turned on.
   SiteIsolationPolicy::StartRecordingSiteIsolationFlagUsage();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PreCreateThreads - Step 2";
 
   return result_code_;
 }
@@ -895,6 +899,7 @@ void BrowserMainLoop::PreShutdown() {
 }
 
 void BrowserMainLoop::CreateStartupTasks() {
+  LOG(ERROR) << "BrowserMainLoop::CreateStartupTasks - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::CreateStartupTasks");
 
   DCHECK(!startup_task_runner_);
@@ -963,11 +968,13 @@ void BrowserMainLoop::SynchronouslyFlushStartupTasks() {
 #endif  // OS_ANDROID
 
 int BrowserMainLoop::CreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 1";
   TRACE_EVENT0("startup,rail", "BrowserMainLoop::CreateThreads");
 
   // Release the ThreadPool's threads.
   scoped_execution_fence_.reset();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 2";
   // The |io_thread| can have optionally been injected into Init(), but if not,
   // create it here. Thre thread is only tagged as BrowserThread::IO here in
   // order to prevent any code from statically posting to it before
@@ -976,9 +983,12 @@ int BrowserMainLoop::CreateThreads() {
   if (!io_thread_) {
     io_thread_ = BrowserTaskExecutor::CreateIOThread();
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 3";
   io_thread_->RegisterAsBrowserThread();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 4";
   BrowserTaskExecutor::InitializeIOThread();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 5";
   // TODO(https://crbug.com/863341): Replace with a better API
   GetContentClient()->browser()->PostAfterStartupTask(
       FROM_HERE, base::SequencedTaskRunnerHandle::Get(),
@@ -995,20 +1005,24 @@ int BrowserMainLoop::CreateThreads() {
           // Accessing an Unretained pointer to BrowserMainLoop from a main
           // thread task is therefore safe.
           base::Unretained(this)));
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 6";
 
   created_threads_ = true;
   return result_code_;
 }
 
 int BrowserMainLoop::PostCreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 1";
   tracing_controller_ = std::make_unique<content::TracingControllerImpl>();
   content::BackgroundTracingManagerImpl::GetInstance()
       ->AddMetadataGeneratorFunction();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 2";
   if (parts_) {
     TRACE_EVENT0("startup", "BrowserMainLoop::PostCreateThreads");
     parts_->PostCreateThreads();
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 3";
 
   return result_code_;
 }
@@ -1247,16 +1261,19 @@ void BrowserMainLoop::InitializeMainThread() {
 }
 
 int BrowserMainLoop::BrowserThreadsStarted() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::BrowserThreadsStarted");
 
   // Bring up Mojo IPC and the embedded Service Manager as early as possible.
   // Initializaing mojo requires the IO thread to have been initialized first,
   // so this cannot happen any earlier than now.
   InitializeMojo();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 2";
 
   data_decoder_service_provider_ = std::make_unique<OopDataDecoder>();
 
   HistogramSynchronizer::GetInstance();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 3";
 
   // cc assumes a single client name for metrics in a process, which is
   // is inconsistent with single process mode where both the renderer and
@@ -1276,6 +1293,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
   InitShaderCacheFactorySingleton(
       base::CreateSingleThreadTaskRunner({BrowserThread::IO}));
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 4";
   // Initialize the FontRenderParams on IO thread. This needs to be initialized
   // before gpu process initialization below.
   base::PostTask(FROM_HERE, {BrowserThread::IO},
@@ -1283,6 +1301,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
                                 gfx::GetFontRenderParams(
                                     gfx::FontRenderParamsQuery(), nullptr)));
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 5";
   bool always_uses_gpu = true;
   bool established_gpu_channel = false;
 #if defined(OS_ANDROID)
@@ -1297,6 +1316,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
       parsed_command_line_.HasSwitch(switches::kDisableGpuEarlyInit)) {
     established_gpu_channel = always_uses_gpu = false;
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 6";
 
   host_frame_sink_manager_ = std::make_unique<viz::HostFrameSinkManager>();
   BrowserGpuChannelHostFactory::Initialize(established_gpu_channel);
@@ -1329,6 +1349,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
             compositing_mode_reporter_impl_.get(),
             server_shared_bitmap_manager_.get(), GetResizeTaskRunner()));
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 7";
 
 #if defined(USE_AURA)
   env_->set_context_factory(GetContextFactory());
@@ -1341,6 +1362,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
       tracing::GraphicsMemoryDumpProvider::GetInstance(), "AndroidGraphics",
       nullptr);
 #endif
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 8";
 
   {
     TRACE_EVENT0("startup", "BrowserThreadsStarted::Subsystem:AudioMan");
@@ -1358,6 +1380,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
         GetSystemConnector()->Clone());
   }
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 9";
 #if defined(OS_WIN)
   HDRProxy::Initialize();
   system_message_window_.reset(new media::SystemMessageWindowWin);
@@ -1378,6 +1401,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
   // created; namely, WebRtcEventLogManager.
   // Allowed to leak when the browser exits.
   WebRTCInternals::CreateSingletonInstance();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 10";
 
   // MediaStreamManager needs the IO thread to be created.
   {
@@ -1422,6 +1446,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
     save_file_manager_ = new SaveFileManager();
   }
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 11";
   // Alert the clipboard class to which threads are allowed to access the
   // clipboard:
   std::vector<base::PlatformThreadId> allowed_clipboard_threads;
@@ -1442,6 +1467,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
         base::BindOnce(base::IgnoreResult(&GpuProcessHost::Get),
                        GPU_PROCESS_KIND_SANDBOXED, true /* force_create */));
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 12";
 
 #if defined(OS_WIN)
   if (!parsed_command_line_.HasSwitch(
@@ -1464,6 +1490,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
   ThemeHelperMac::GetInstance();
 #endif  // defined(OS_MACOSX)
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 13";
 #if defined(OS_ANDROID)
   media::SetMediaDrmBridgeClient(GetContentClient()->GetMediaDrmBridgeClient());
   if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
@@ -1474,6 +1501,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
 #if defined(ENABLE_IPC_FUZZER)
   SetFileUrlPathAliasForIpcFuzzer();
 #endif
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 14";
   return result_code_;
 }
 
diff --git a/content/browser/browser_main_runner_impl.cc b/content/browser/browser_main_runner_impl.cc
index 4b59e815be0a..df6079c62945 100644
--- a/content/browser/browser_main_runner_impl.cc
+++ b/content/browser/browser_main_runner_impl.cc
@@ -62,6 +62,7 @@ BrowserMainRunnerImpl::~BrowserMainRunnerImpl() {
 }
 
 int BrowserMainRunnerImpl::Initialize(const MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 1";
   SCOPED_UMA_HISTOGRAM_LONG_TIMER(
       "Startup.BrowserMainRunnerImplInitializeLongTime");
   TRACE_EVENT0("startup", "BrowserMainRunnerImpl::Initialize");
@@ -75,6 +76,7 @@ int BrowserMainRunnerImpl::Initialize(const MainFunctionParams& parameters) {
 
     const base::TimeTicks start_time_step1 = base::TimeTicks::Now();
 
+    LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 2";
     SkGraphics::Init();
 
     if (parameters.command_line.HasSwitch(switches::kWaitForDebugger))
@@ -93,6 +95,7 @@ int BrowserMainRunnerImpl::Initialize(const MainFunctionParams& parameters) {
 #endif  // OS_WIN
 
     gfx::InitializeFonts();
+    LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 3";
 
     main_loop_.reset(
         new BrowserMainLoop(parameters, std::move(scoped_execution_fence_)));
diff --git a/content/browser/compositor/gpu_process_transport_factory.cc b/content/browser/compositor/gpu_process_transport_factory.cc
index 0b438d135229..3965520ffcbe 100644
--- a/content/browser/compositor/gpu_process_transport_factory.cc
+++ b/content/browser/compositor/gpu_process_transport_factory.cc
@@ -821,14 +821,6 @@ GpuProcessTransportFactory::CreatePerCompositorData(
   auto data = std::make_unique<PerCompositorData>();
   if (widget == gfx::kNullAcceleratedWidget) {
     data->surface_handle = gpu::kNullSurfaceHandle;
-  } else {
-#if defined(GPU_SURFACE_HANDLE_IS_ACCELERATED_WINDOW)
-    data->surface_handle = widget;
-#else
-    gpu::GpuSurfaceTracker* tracker = gpu::GpuSurfaceTracker::Get();
-    data->surface_handle = tracker->AddSurfaceForNativeWidget(
-        gpu::GpuSurfaceTracker::SurfaceRecord(widget));
-#endif
   }
 
   PerCompositorData* return_ptr = data.get();
diff --git a/content/browser/devtools/BUILD.gn b/content/browser/devtools/BUILD.gn
index 187a511c6fd6..ebc66d339dae 100644
--- a/content/browser/devtools/BUILD.gn
+++ b/content/browser/devtools/BUILD.gn
@@ -7,7 +7,7 @@ import("//third_party/protobuf/proto_library.gni")
 import("//tools/grit/grit_rule.gni")
 
 group("resources") {
-  if (!is_android) {
+  if (true || !is_android) {
     public_deps = [
       ":devtools_resources",
     ]
diff --git a/content/browser/frame_host/navigation_controller_impl.cc b/content/browser/frame_host/navigation_controller_impl.cc
index 9b489fed825c..1f8f77fd172b 100644
--- a/content/browser/frame_host/navigation_controller_impl.cc
+++ b/content/browser/frame_host/navigation_controller_impl.cc
@@ -946,8 +946,10 @@ void NavigationControllerImpl::LoadURL(const GURL& url,
 }
 
 void NavigationControllerImpl::LoadURLWithParams(const LoadURLParams& params) {
+#if 0
   if (params.is_renderer_initiated)
     DCHECK(params.initiator_origin.has_value());
+#endif
 
   TRACE_EVENT1("browser,navigation",
                "NavigationControllerImpl::LoadURLWithParams", "url",
@@ -3087,7 +3089,9 @@ NavigationControllerImpl::CreateNavigationRequestFromLoadParams(
   DCHECK_EQ(-1, GetIndexOfEntry(entry));
   DCHECK(frame_entry);
   // All renderer-initiated navigations must have an initiator_origin.
+#if 0
   DCHECK(!params.is_renderer_initiated || params.initiator_origin.has_value());
+#endif
 
   GURL url_to_load;
   GURL virtual_url;
diff --git a/content/browser/frame_host/navigation_request.cc b/content/browser/frame_host/navigation_request.cc
index 26bbc64c40fa..56a9ba1d9fa0 100644
--- a/content/browser/frame_host/navigation_request.cc
+++ b/content/browser/frame_host/navigation_request.cc
@@ -897,7 +897,9 @@ NavigationRequest::NavigationRequest(
       commit_navigation_client_(mojo::NullAssociatedRemote()),
       rfh_restored_from_back_forward_cache_(
           rfh_restored_from_back_forward_cache) {
+#if 0
   DCHECK(browser_initiated_ || common_params_->initiator_origin.has_value());
+#endif
   DCHECK(!IsRendererDebugURL(common_params_->url));
   DCHECK(common_params_->method == "POST" || !common_params_->post_data);
   TRACE_EVENT_ASYNC_BEGIN2("navigation", "NavigationRequest", this,
diff --git a/content/browser/renderer_host/pepper/pepper_truetype_font_android.cc b/content/browser/renderer_host/pepper/pepper_truetype_font_android.cc
new file mode 100644
index 000000000000..6ed4c5b0ff16
--- /dev/null
+++ b/content/browser/renderer_host/pepper/pepper_truetype_font_android.cc
@@ -0,0 +1,78 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/pepper/pepper_truetype_font.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/compiler_specific.h"
+#include "base/files/scoped_file.h"
+#include "base/macros.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/sys_byteorder.h"
+#include "build/build_config.h"
+#include "components/services/font/ppapi_fontconfig_matching.h"
+#include "content/public/common/common_sandbox_support_linux.h"
+#include "ppapi/buildflags/buildflags.h"
+#include "ppapi/c/dev/ppb_truetype_font_dev.h"
+#include "ppapi/c/pp_errors.h"
+#include "ppapi/c/trusted/ppb_browser_font_trusted.h"
+
+namespace content {
+
+namespace {
+
+class PepperTrueTypeFontAndroid : public PepperTrueTypeFont {
+ public:
+  PepperTrueTypeFontAndroid();
+
+  // PepperTrueTypeFont implementation.
+  int32_t Initialize(ppapi::proxy::SerializedTrueTypeFontDesc* desc) override;
+  int32_t GetTableTags(std::vector<uint32_t>* tags) override;
+  int32_t GetTable(uint32_t table_tag,
+                   int32_t offset,
+                   int32_t max_data_length,
+                   std::string* data) override;
+
+ private:
+  ~PepperTrueTypeFontAndroid() override;
+
+  base::ScopedFD fd_;
+
+  DISALLOW_COPY_AND_ASSIGN(PepperTrueTypeFontAndroid);
+};
+
+PepperTrueTypeFontAndroid::PepperTrueTypeFontAndroid() {
+}
+
+PepperTrueTypeFontAndroid::~PepperTrueTypeFontAndroid() {
+}
+
+int32_t PepperTrueTypeFontAndroid::Initialize(
+    ppapi::proxy::SerializedTrueTypeFontDesc* desc) {
+  return fd_.is_valid() ? PP_OK : PP_ERROR_FAILED;
+}
+
+int32_t PepperTrueTypeFontAndroid::GetTableTags(std::vector<uint32_t>* tags) {
+  return PP_ERROR_FAILED;
+}
+
+int32_t PepperTrueTypeFontAndroid::GetTable(uint32_t table_tag,
+                                          int32_t offset,
+                                          int32_t max_data_length,
+                                          std::string* data) {
+  return PP_ERROR_FAILED;
+}
+
+}  // namespace
+
+// static
+PepperTrueTypeFont* PepperTrueTypeFont::Create() {
+  return new PepperTrueTypeFontAndroid();
+}
+
+}  // namespace content
diff --git a/content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc b/content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc
new file mode 100644
index 000000000000..12e2c61a8cf5
--- /dev/null
+++ b/content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc
@@ -0,0 +1,20 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/logging.h"
+#include "content/browser/renderer_host/pepper/pepper_truetype_font_list.h"
+
+namespace content {
+
+void GetFontFamilies_SlowBlocking(std::vector<std::string>* font_families) {
+  NOTIMPLEMENTED();
+}
+
+void GetFontsInFamily_SlowBlocking(
+    const std::string& family,
+    std::vector<ppapi::proxy::SerializedTrueTypeFontDesc>* fonts_in_family) {
+  NOTIMPLEMENTED();
+}
+
+}  // namespace content
diff --git a/content/browser/renderer_host/render_view_host_impl.cc b/content/browser/renderer_host/render_view_host_impl.cc
index a73a05383e44..5efa9bc1dd0a 100644
--- a/content/browser/renderer_host/render_view_host_impl.cc
+++ b/content/browser/renderer_host/render_view_host_impl.cc
@@ -106,7 +106,7 @@
 #include "ui/gfx/system_fonts_win.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/browser/host_zoom_map_impl.h"
 #endif
 
@@ -704,7 +704,7 @@ void RenderViewHostImpl::ClosePage() {
 
     // TODO(creis): Should this be moved to Shutdown?  It may not be called for
     // RenderViewHosts that have been swapped out.
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     static_cast<HostZoomMapImpl*>(HostZoomMap::Get(GetSiteInstance()))
         ->WillCloseRenderView(GetProcess()->GetID(), GetRoutingID());
 #endif
@@ -905,7 +905,7 @@ void RenderViewHostImpl::OnDocumentAvailableInMainFrame(
   if (!uses_temporary_zoom_level)
     return;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   HostZoomMapImpl* host_zoom_map =
       static_cast<HostZoomMapImpl*>(HostZoomMap::Get(GetSiteInstance()));
   host_zoom_map->SetTemporaryZoomLevel(GetProcess()->GetID(),
diff --git a/content/browser/storage_partition_impl.cc b/content/browser/storage_partition_impl.cc
index c05ce85a2327..df33f47430a1 100644
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -90,7 +90,6 @@
 
 #if defined(OS_ANDROID)
 #include "net/android/http_auth_negotiate_android.h"
-#else
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // defined(OS_ANDROID)
 
@@ -1236,7 +1235,7 @@ void StoragePartitionImpl::Initialize() {
   push_messaging_context_ =
       new PushMessagingContext(browser_context_, service_worker_context_);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   host_zoom_level_context_ = new HostZoomLevelContext(
       browser_context_->CreateZoomLevelDelegate(partition_path_));
 #endif  // !defined(OS_ANDROID)
@@ -1459,7 +1458,7 @@ SharedWorkerServiceImpl* StoragePartitionImpl::GetSharedWorkerService() {
   return shared_worker_service_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 HostZoomMap* StoragePartitionImpl::GetHostZoomMap() {
   DCHECK(initialized_);
   DCHECK(host_zoom_level_context_.get());
diff --git a/content/browser/storage_partition_impl.h b/content/browser/storage_partition_impl.h
index 8fa1496d5782..35b7354a9910 100644
--- a/content/browser/storage_partition_impl.h
+++ b/content/browser/storage_partition_impl.h
@@ -47,7 +47,7 @@
 #include "storage/browser/quota/special_storage_policy.h"
 #include "third_party/blink/public/mojom/dom_storage/storage_partition_service.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/browser/host_zoom_level_context.h"
 #endif
 
@@ -138,7 +138,7 @@ class CONTENT_EXPORT StoragePartitionImpl
   DevToolsBackgroundServicesContextImpl* GetDevToolsBackgroundServicesContext()
       override;
   ContentIndexContextImpl* GetContentIndexContext() override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   HostZoomMap* GetHostZoomMap() override;
   HostZoomLevelContext* GetHostZoomLevelContext() override;
   ZoomLevelDelegate* GetZoomLevelDelegate() override;
@@ -437,7 +437,7 @@ class CONTENT_EXPORT StoragePartitionImpl
   std::unique_ptr<SharedWorkerServiceImpl> shared_worker_service_;
   scoped_refptr<PushMessagingContext> push_messaging_context_;
   scoped_refptr<storage::SpecialStoragePolicy> special_storage_policy_;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   scoped_refptr<HostZoomLevelContext> host_zoom_level_context_;
 #endif  // !defined(OS_ANDROID)
   scoped_refptr<PlatformNotificationContextImpl> platform_notification_context_;
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 6f2ee557fb41..28c88eb30ac2 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -176,7 +176,7 @@
 #include "content/browser/android/nfc_host.h"
 #include "content/browser/web_contents/web_contents_android.h"
 #include "services/device/public/mojom/nfc.mojom.h"
-#else  // !OS_ANDROID
+
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // OS_ANDROID
 
@@ -599,7 +599,7 @@ WebContentsImpl::WebContentsImpl(BrowserContext* browser_context)
       audio_stream_monitor_(this),
       media_web_contents_observer_(
           std::make_unique<MediaWebContentsObserver>(this)),
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
       page_scale_factor_is_one_(true),
 #endif  // !defined(OS_ANDROID)
       is_overlay_content_(false),
@@ -1192,7 +1192,7 @@ FindRequestManager* WebContentsImpl::GetFindRequestManagerForTesting() {
   return GetFindRequestManager();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void WebContentsImpl::UpdateZoom() {
   RenderWidgetHostImpl* rwh = GetRenderViewHost()->GetWidget();
   if (rwh->GetView())
@@ -5638,7 +5638,7 @@ WebContents* WebContentsImpl::GetAsWebContents() {
   return this;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 double WebContentsImpl::GetPendingPageZoomLevel() {
   NavigationEntry* pending_entry = GetController().GetPendingEntry();
   if (!pending_entry)
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
index 0f8667f45492..b80dcd3654b5 100644
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -253,7 +253,7 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
   // bitmap.
   void AddAccessibilityMode(ui::AXMode mode);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Sets the zoom level for frames associated with this WebContents.
   void UpdateZoom();
 
@@ -787,7 +787,7 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
   void OnVerticalScrollDirectionChanged(
       viz::VerticalScrollDirection scroll_direction) override;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   double GetPendingPageZoomLevel() override;
 #endif  // !defined(OS_ANDROID)
 
@@ -1853,7 +1853,7 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
 
   PageImportanceSignals page_importance_signals_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   bool page_scale_factor_is_one_;
 #endif  // !defined(OS_ANDROID)
 
diff --git a/content/browser/webui/shared_resources_data_source.cc b/content/browser/webui/shared_resources_data_source.cc
index 64bdcea5ff6a..c3eb826668d1 100644
--- a/content/browser/webui/shared_resources_data_source.cc
+++ b/content/browser/webui/shared_resources_data_source.cc
@@ -87,7 +87,7 @@ const std::map<std::string, std::string> CreatePathPrefixAliasesMap() {
     return aliases;
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   aliases["../../../third_party/polymer/v1_0/components-chromium/polymer2/"] =
       "polymer/v1_0/polymer/";
 #endif  // !defined(OS_ANDROID)
@@ -179,7 +179,7 @@ const std::map<int, std::string> CreateChromeosMojoResourceIdToAliasMap() {
 }
 #endif  // !defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool ShouldIgnore(std::string resource) {
 #if defined(OS_CHROMEOS)
   if (UsingMultiplePolymerVersions())
@@ -211,7 +211,7 @@ void AddResourcesToMap(ResourcesMap* resources_map) {
   for (size_t i = 0; i < kWebuiResourcesSize; ++i) {
     const auto& resource = kWebuiResources[i];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     if (ShouldIgnore(resource.name))
       continue;
 #endif  // !defined(OS_ANDROID)
diff --git a/content/child/child_process.cc b/content/child/child_process.cc
index 04b8f40e3dcd..1e93f7c76c07 100644
--- a/content/child/child_process.cc
+++ b/content/child/child_process.cc
@@ -52,19 +52,24 @@ ChildProcess::ChildProcess(base::ThreadPriority io_thread_priority,
     DCHECK(base::ThreadPoolInstance::Get());
     initialized_thread_pool_ = true;
   }
+  LOG(ERROR) << "[Kiwi] ChildProcess::ChildProcess - Step 1";
   tracing::InitTracingPostThreadPoolStartAndFeatureList();
 
+  LOG(ERROR) << "[Kiwi] ChildProcess::ChildProcess - Step 2";
   // We can't recover from failing to start the IO thread.
   base::Thread::Options thread_options(base::MessagePumpType::IO, 0);
+  LOG(ERROR) << "[Kiwi] ChildProcess::ChildProcess - Step 3";
   thread_options.priority = io_thread_priority;
 #if defined(OS_ANDROID)
   // TODO(reveman): Remove this in favor of setting it explicitly for each type
   // of process.
+  LOG(ERROR) << "[Kiwi] ChildProcess::ChildProcess - Step 4";
   if (base::FeatureList::IsEnabled(
           blink::features::kBlinkCompositorUseDisplayThreadPriority)) {
     thread_options.priority = base::ThreadPriority::DISPLAY;
   }
 #endif
+  LOG(ERROR) << "[Kiwi] ChildProcess::ChildProcess - Step 5";
   CHECK(io_thread_.StartWithOptions(thread_options));
 }
 
diff --git a/content/public/browser/browser_context.h b/content/public/browser/browser_context.h
index 683e352d1dd7..db1d56b33034 100644
--- a/content/public/browser/browser_context.h
+++ b/content/public/browser/browser_context.h
@@ -28,7 +28,7 @@
 #include "third_party/blink/public/mojom/blob/blob.mojom-forward.h"
 #include "third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom-forward.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/public/browser/zoom_level_delegate.h"
 #endif
 
@@ -248,7 +248,7 @@ class CONTENT_EXPORT BrowserContext : public base::SupportsUserData {
   // StoragePartition can have time to do necessary cleanups on IO thread.
   void ShutdownStoragePartitions();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Creates a delegate to initialize a HostZoomMap and persist its information.
   // This is called during creation of each StoragePartition.
   virtual std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index bcb85464359c..5351e6ac0d85 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -853,7 +853,7 @@ void ContentBrowserClient::CreateWebUsbService(
     RenderFrameHost* render_frame_host,
     mojo::PendingReceiver<blink::mojom::WebUsbService> receiver) {}
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 SerialDelegate* ContentBrowserClient::GetSerialDelegate() {
   return nullptr;
 }
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index b70473936db0..90a9e88ebdeb 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1508,7 +1508,7 @@ class CONTENT_EXPORT ContentBrowserClient {
       RenderFrameHost* render_frame_host,
       mojo::PendingReceiver<blink::mojom::WebUsbService> receiver);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Allows the embedder to provide an implementation of the Serial API.
   virtual SerialDelegate* GetSerialDelegate();
 #endif
diff --git a/content/public/browser/desktop_media_id.cc b/content/public/browser/desktop_media_id.cc
index 9330ec65d449..b7842b984982 100644
--- a/content/public/browser/desktop_media_id.cc
+++ b/content/public/browser/desktop_media_id.cc
@@ -27,15 +27,13 @@ const DesktopMediaID::Id DesktopMediaID::kNullId = 0;
 // static
 const DesktopMediaID::Id DesktopMediaID::kFakeId = -3;
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) //|| true
 // static
 DesktopMediaID DesktopMediaID::RegisterNativeWindow(DesktopMediaID::Type type,
                                                     gfx::NativeWindow window) {
   DCHECK(type == TYPE_SCREEN || type == TYPE_WINDOW);
   DCHECK(window);
   DesktopMediaID media_id(type, kNullId);
-  media_id.window_id =
-      DesktopMediaWindowRegistry::GetInstance()->RegisterWindow(window);
   return media_id;
 }
 
diff --git a/content/public/browser/desktop_media_id.h b/content/public/browser/desktop_media_id.h
index c9791b4f436a..839b19686d26 100644
--- a/content/public/browser/desktop_media_id.h
+++ b/content/public/browser/desktop_media_id.h
@@ -28,7 +28,7 @@ struct CONTENT_EXPORT DesktopMediaID {
   // Represents a fake id to create a dummy capturer for autotests.
   static const Id kFakeId;
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || true
   // Assigns integer identifier to the |window| and returns its DesktopMediaID.
   static DesktopMediaID RegisterNativeWindow(Type type,
                                              gfx::NativeWindow window);
diff --git a/content/public/browser/storage_partition.h b/content/public/browser/storage_partition.h
index da224f4c3478..eaece325dd44 100644
--- a/content/public/browser/storage_partition.h
+++ b/content/public/browser/storage_partition.h
@@ -64,7 +64,7 @@ class PlatformNotificationContext;
 class ServiceWorkerContext;
 class SharedWorkerService;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class HostZoomLevelContext;
 class HostZoomMap;
 class ZoomLevelDelegate;
@@ -133,7 +133,7 @@ class CONTENT_EXPORT StoragePartition {
   virtual DevToolsBackgroundServicesContext*
   GetDevToolsBackgroundServicesContext() = 0;
   virtual ContentIndexContext* GetContentIndexContext() = 0;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   virtual HostZoomMap* GetHostZoomMap() = 0;
   virtual HostZoomLevelContext* GetHostZoomLevelContext() = 0;
   virtual ZoomLevelDelegate* GetZoomLevelDelegate() = 0;
diff --git a/content/public/common/pepper_plugin_info.h b/content/public/common/pepper_plugin_info.h
index 753bff723ad0..79846e8c216e 100644
--- a/content/public/common/pepper_plugin_info.h
+++ b/content/public/common/pepper_plugin_info.h
@@ -17,9 +17,11 @@
 #include "ppapi/c/pp_module.h"
 #include "ppapi/c/ppb.h"
 
+#if 0
 #if !BUILDFLAG(ENABLE_PLUGINS)
 #error "Plugins should be enabled"
 #endif
+#endif
 
 namespace content {
 
diff --git a/content/shell/BUILD.gn b/content/shell/BUILD.gn
index e82958e70dd1..3317b006b292 100644
--- a/content/shell/BUILD.gn
+++ b/content/shell/BUILD.gn
@@ -574,7 +574,7 @@ repack("pak") {
     sources +=
         [ "$root_gen_dir/ui/views/resources/views_resources_100_percent.pak" ]
   }
-  if (!is_android) {
+  if (true || !is_android) {
     sources +=
         [ "$root_gen_dir/content/browser/devtools/devtools_resources.pak" ]
     deps += [ "//content/browser/devtools:resources" ]
diff --git a/content/shell/browser/shell_browser_context.cc b/content/shell/browser/shell_browser_context.cc
index 8faba962a63c..1f1dace7bdf0 100644
--- a/content/shell/browser/shell_browser_context.cc
+++ b/content/shell/browser/shell_browser_context.cc
@@ -139,7 +139,7 @@ void ShellBrowserContext::FinishInitWhileIOAllowed() {
   SimpleKeyMap::GetInstance()->Associate(this, key_.get());
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<ZoomLevelDelegate> ShellBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath&) {
   return std::unique_ptr<ZoomLevelDelegate>();
diff --git a/content/shell/browser/shell_browser_context.h b/content/shell/browser/shell_browser_context.h
index d199c22ae034..6bc4aab5af5a 100644
--- a/content/shell/browser/shell_browser_context.h
+++ b/content/shell/browser/shell_browser_context.h
@@ -25,7 +25,7 @@ class ClientHintsControllerDelegate;
 class DownloadManagerDelegate;
 class PermissionControllerDelegate;
 class ShellDownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class ZoomLevelDelegate;
 #endif  // !defined(OS_ANDROID)
 
@@ -44,7 +44,7 @@ class ShellBrowserContext : public BrowserContext {
 
   // BrowserContext implementation.
   base::FilePath GetPath() override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
diff --git a/extensions/BUILD.gn b/extensions/BUILD.gn
index ac430db0ec4a..1fa06a47b70f 100644
--- a/extensions/BUILD.gn
+++ b/extensions/BUILD.gn
@@ -203,42 +203,6 @@ repack("shell_and_test_pak") {
   ]
 }
 
-test("extensions_unittests") {
-  sources = [
-    "test/extensions_unittests_main.cc",
-    "test/logging_timer_unittest.cc",
-  ]
-
-  data = [
-    "test/data/",
-    "//chrome/test/data/extensions/",
-    "//components/test/data/cast_certificate/",
-    "$root_out_dir/content_shell.pak",
-    "$root_out_dir/extensions_shell_and_test.pak",
-  ]
-
-  deps = [
-    ":extensions_resources",
-    ":shell_and_test_pak",
-    ":test_support",
-    "//base/test:test_support",
-    "//content/public/common",
-    "//content/test:test_support",
-    "//extensions/browser:unit_tests",
-    "//extensions/common",
-    "//extensions/common:unit_tests",
-    "//extensions/renderer:unit_tests",
-    "//extensions/shell:unit_tests",
-    "//services/data_decoder:lib",
-    "//services/service_manager/public/cpp/test:test_support",
-    "//ui/gl:test_support",
-  ]
-
-  data_deps = [
-    "//third_party/mesa_headers",
-  ]
-}
-
 test("extensions_browsertests") {
   data = [
     "//extensions/test/data/",
diff --git a/extensions/browser/api/BUILD.gn b/extensions/browser/api/BUILD.gn
index 33291552ce3c..36010e5ef10c 100644
--- a/extensions/browser/api/BUILD.gn
+++ b/extensions/browser/api/BUILD.gn
@@ -103,7 +103,7 @@ source_set("api") {
   # TODO(michaelpg): Move these deps to the individual APIs that require them.
   deps += [
     "//components/onc",
-    "//components/storage_monitor",
+#    "//components/storage_monitor",
     "//device/bluetooth",
   ]
 
diff --git a/extensions/browser/api/api_resource_manager.h b/extensions/browser/api/api_resource_manager.h
index ae047659934e..45c0e6572261 100644
--- a/extensions/browser/api/api_resource_manager.h
+++ b/extensions/browser/api/api_resource_manager.h
@@ -106,8 +106,11 @@ class ApiResourceManager : public BrowserContextKeyedAPI,
  public:
   explicit ApiResourceManager(content::BrowserContext* context)
       : data_(base::MakeRefCounted<ApiResourceData>()) {
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 1";
     extension_registry_observer_.Add(ExtensionRegistry::Get(context));
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 2";
     process_manager_observer_.Add(ProcessManager::Get(context));
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 3";
   }
 
   virtual ~ApiResourceManager() {
@@ -387,10 +390,15 @@ template <class T>
 struct BrowserContextFactoryDependencies<ApiResourceManager<T>> {
   static void DeclareFactoryDependencies(
       BrowserContextKeyedAPIFactory<ApiResourceManager<T>>* factory) {
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Prestep A";
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step A";
     factory->DependsOn(
         ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step B";
     factory->DependsOn(ExtensionRegistryFactory::GetInstance());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step C";
     factory->DependsOn(ProcessManagerFactory::GetInstance());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step D";
   }
 };
 
diff --git a/extensions/browser/api/messaging/message_service.cc b/extensions/browser/api/messaging/message_service.cc
index c3918725562f..bd62f6e04f46 100644
--- a/extensions/browser/api/messaging/message_service.cc
+++ b/extensions/browser/api/messaging/message_service.cc
@@ -441,7 +441,7 @@ void MessageService::OpenChannelToNativeApp(
   channel->opener->IncrementLazyKeepaliveCount();
 
   AddChannel(std::move(channel), receiver_port_id);
-#else  // !(defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX))
+#elif 0  // !(defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX))
   const char kNativeMessagingNotSupportedError[] =
       "Native Messaging is not supported on this platform.";
   opener_port->DispatchOnDisconnect(kNativeMessagingNotSupportedError);
diff --git a/extensions/browser/api/socket/tcp_socket.cc b/extensions/browser/api/socket/tcp_socket.cc
index b01331a2c092..098a99325908 100644
--- a/extensions/browser/api/socket/tcp_socket.cc
+++ b/extensions/browser/api/socket/tcp_socket.cc
@@ -30,35 +30,8 @@ namespace extensions {
 
 namespace {
 
-// Returns true if successfully parsed the SSL protocol version that is
-// represented by a string. Returns false if |version_str| is invalid.
-bool SSLProtocolVersionFromString(const std::string& version_str,
-                                  network::mojom::SSLVersion* version_out) {
-  if (version_str == "tls1") {
-    *version_out = network::mojom::SSLVersion::kTLS1;
-    return true;
-  }
-  if (version_str == "tls1.1") {
-    *version_out = network::mojom::SSLVersion::kTLS11;
-    return true;
-  }
-  if (version_str == "tls1.2") {
-    *version_out = network::mojom::SSLVersion::kTLS12;
-    return true;
-  }
-  if (version_str == "tls1.3") {
-    *version_out = network::mojom::SSLVersion::kTLS13;
-    return true;
-  }
-  return false;
-}
-
 }  // namespace
 
-const char kTCPSocketTypeInvalidError[] =
-    "Cannot call both connect and listen on the same socket.";
-const char kSocketListenError[] = "Could not listen on the specified port.";
-
 static base::LazyInstance<BrowserContextKeyedAPIFactory<
     ApiResourceManager<ResumableTCPSocket>>>::DestructorAtExit g_factory =
     LAZY_INSTANCE_INITIALIZER;
@@ -85,7 +58,6 @@ TCPSocket::TCPSocket(content::BrowserContext* browser_context,
                      const std::string& owner_extension_id)
     : Socket(owner_extension_id),
       browser_context_(browser_context),
-      socket_mode_(UNKNOWN),
       mojo_data_pump_(nullptr),
       task_runner_(base::SequencedTaskRunnerHandle::Get()) {}
 
@@ -97,7 +69,6 @@ TCPSocket::TCPSocket(
     const std::string& owner_extension_id)
     : Socket(owner_extension_id),
       browser_context_(nullptr),
-      socket_mode_(CLIENT),
       client_socket_(std::move(socket)),
       mojo_data_pump_(std::make_unique<MojoDataPump>(std::move(receive_stream),
                                                      std::move(send_stream))),
@@ -113,7 +84,7 @@ TCPSocket::~TCPSocket() {
 void TCPSocket::Connect(const net::AddressList& address,
                         net::CompletionOnceCallback callback) {
   DCHECK(callback);
-
+#if 0
   if (socket_mode_ == SERVER || connect_callback_) {
     std::move(callback).Run(net::ERR_CONNECTION_FAILED);
     return;
@@ -144,6 +115,7 @@ void TCPSocket::Connect(const net::AddressList& address,
                                 storage_partition_, browser_context_, address,
                                 client_socket_.BindNewPipeAndPassReceiver(),
                                 std::move(completion_callback_ui)));
+#endif
 }
 
 void TCPSocket::Disconnect(bool socket_destroying) {
@@ -174,28 +146,6 @@ void TCPSocket::Bind(const std::string& address,
 
 void TCPSocket::Read(int count, ReadCompletionCallback callback) {
   DCHECK(callback);
-
-  const bool socket_destroying = false;
-  if (socket_mode_ != CLIENT) {
-    std::move(callback).Run(net::ERR_FAILED, nullptr, socket_destroying);
-    return;
-  }
-
-  if (!mojo_data_pump_) {
-    std::move(callback).Run(net::ERR_SOCKET_NOT_CONNECTED, nullptr,
-                            socket_destroying);
-    return;
-  }
-  if (mojo_data_pump_->HasPendingRead() || connect_callback_) {
-    // It's illegal to read a net::TCPSocket while a pending Connect or Read is
-    // already in progress.
-    std::move(callback).Run(net::ERR_IO_PENDING, nullptr, socket_destroying);
-    return;
-  }
-
-  read_callback_ = std::move(callback);
-  mojo_data_pump_->Read(count, base::BindOnce(&TCPSocket::OnReadComplete,
-                                              base::Unretained(this)));
 }
 
 void TCPSocket::RecvFrom(int count, RecvFromCompletionCallback callback) {
@@ -213,25 +163,16 @@ void TCPSocket::SendTo(scoped_refptr<net::IOBuffer> io_buffer,
 void TCPSocket::SetKeepAlive(bool enable,
                              int delay,
                              SetKeepAliveCallback callback) {
-  if (!client_socket_) {
-    std::move(callback).Run(net::ERR_FAILED);
-    return;
-  }
-  client_socket_->SetKeepAlive(enable, delay, std::move(callback));
 }
 
 void TCPSocket::SetNoDelay(bool no_delay, SetNoDelayCallback callback) {
-  if (!client_socket_) {
-    std::move(callback).Run(net::ERR_FAILED);
-    return;
-  }
-  client_socket_->SetNoDelay(no_delay, std::move(callback));
 }
 
 void TCPSocket::Listen(const std::string& address,
                        uint16_t port,
                        int backlog,
                        ListenCallback callback) {
+#if 0
   DCHECK(!server_socket_);
   DCHECK(!client_socket_);
   DCHECK(!listen_callback_);
@@ -269,9 +210,11 @@ void TCPSocket::Listen(const std::string& address,
                      browser_context_, ip_end_point, backlog,
                      server_socket_.BindNewPipeAndPassReceiver(),
                      std::move(completion_callback_ui)));
+#endif
 }
 
 void TCPSocket::Accept(AcceptCompletionCallback callback) {
+#if 0
   if (socket_mode_ != SERVER || !server_socket_) {
     std::move(callback).Run(net::ERR_FAILED, mojo::NullRemote(), base::nullopt,
                             mojo::ScopedDataPipeConsumerHandle(),
@@ -291,6 +234,7 @@ void TCPSocket::Accept(AcceptCompletionCallback callback) {
   server_socket_->Accept(
       mojo::NullRemote() /* observer */,
       base::BindOnce(&TCPSocket::OnAccept, base::Unretained(this)));
+#endif
 }
 
 bool TCPSocket::IsConnected() {
@@ -357,12 +301,6 @@ void TCPSocket::OnConnectCompleteOnUIThread(
     const base::Optional<net::IPEndPoint>& peer_addr,
     mojo::ScopedDataPipeConsumerHandle receive_stream,
     mojo::ScopedDataPipeProducerHandle send_stream) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  original_task_runner->PostTask(
-      FROM_HERE,
-      base::BindOnce(std::move(callback), result, local_addr, peer_addr,
-                     std::move(receive_stream), std::move(send_stream)));
 }
 
 void TCPSocket::OnConnectComplete(
@@ -371,18 +309,6 @@ void TCPSocket::OnConnectComplete(
     const base::Optional<net::IPEndPoint>& peer_addr,
     mojo::ScopedDataPipeConsumerHandle receive_stream,
     mojo::ScopedDataPipeProducerHandle send_stream) {
-  DCHECK(!is_connected_);
-  DCHECK(connect_callback_);
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
-
-  if (result == net::OK) {
-    is_connected_ = true;
-    local_addr_ = local_addr;
-    peer_addr_ = peer_addr;
-    mojo_data_pump_ = std::make_unique<MojoDataPump>(std::move(receive_stream),
-                                                     std::move(send_stream));
-  }
-  std::move(connect_callback_).Run(result);
 }
 
 // static
@@ -393,6 +319,7 @@ void TCPSocket::ListenOnUIThread(
     int backlog,
     mojo::PendingReceiver<network::mojom::TCPServerSocket> receiver,
     network::mojom::NetworkContext::CreateTCPServerSocketCallback callback) {
+#if 0
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   if (!storage_partition) {
@@ -404,6 +331,7 @@ void TCPSocket::ListenOnUIThread(
       net::MutableNetworkTrafficAnnotationTag(
           Socket::GetNetworkTrafficAnnotationTag()),
       std::move(receiver), std::move(callback));
+#endif
 }
 
 // static
@@ -412,25 +340,11 @@ void TCPSocket::OnListenCompleteOnUIThread(
     network::mojom::NetworkContext::CreateTCPServerSocketCallback callback,
     int result,
     const base::Optional<net::IPEndPoint>& local_addr) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  original_task_runner->PostTask(
-      FROM_HERE, base::BindOnce(std::move(callback), result, local_addr));
 }
 
 void TCPSocket::OnListenComplete(
     int result,
     const base::Optional<net::IPEndPoint>& local_addr) {
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
-  DCHECK(listen_callback_);
-
-  if (result != net::OK) {
-    server_socket_.reset();
-    std::move(listen_callback_).Run(result, kSocketListenError);
-    return;
-  }
-  local_addr_ = local_addr;
-  std::move(listen_callback_).Run(result, "");
 }
 
 content::StoragePartition* TCPSocket::GetStoragePartitionHelper() {
@@ -495,6 +409,7 @@ void TCPSocket::OnUpgradeToTLSComplete(
 
 void TCPSocket::UpgradeToTLS(api::socket::SecureOptions* options,
                              UpgradeToTLSCallback callback) {
+#if 0
   if (!client_socket_ || !mojo_data_pump_ ||
       mojo_data_pump_->HasPendingRead() || mojo_data_pump_->HasPendingWrite()) {
     std::move(callback).Run(net::ERR_FAILED, mojo::NullRemote(),
@@ -562,6 +477,7 @@ void TCPSocket::UpgradeToTLS(api::socket::SecureOptions* options,
       base::BindOnce(&TCPSocket::OnUpgradeToTLSComplete, base::Unretained(this),
                      std::move(callback), std::move(tls_socket),
                      local_addr_.value(), peer_addr_.value()));
+#endif
 }
 
 ResumableTCPSocket::ResumableTCPSocket(content::BrowserContext* browser_context,
diff --git a/extensions/browser/api/socket/tcp_socket.h b/extensions/browser/api/socket/tcp_socket.h
index 4f71a0819771..0dcd75c6a5f7 100644
--- a/extensions/browser/api/socket/tcp_socket.h
+++ b/extensions/browser/api/socket/tcp_socket.h
@@ -170,8 +170,6 @@ class TCPSocket : public Socket {
   // ApiResourceManager which is a BrowserContextKeyedAPI.
   content::BrowserContext* browser_context_;
 
-  SocketMode socket_mode_;
-
   // CLIENT mode.
   mojo::Remote<network::mojom::TCPConnectedSocket> client_socket_;
   // SERVER mode.
diff --git a/extensions/browser/api/system_cpu/BUILD.gn b/extensions/browser/api/system_cpu/BUILD.gn
index 16c1602d2890..e13dbda0a79a 100644
--- a/extensions/browser/api/system_cpu/BUILD.gn
+++ b/extensions/browser/api/system_cpu/BUILD.gn
@@ -11,6 +11,7 @@ source_set("system_cpu") {
   sources = [
     "cpu_info_provider.cc",
     "cpu_info_provider.h",
+    "cpu_info_provider_android.cc",
     "cpu_info_provider_linux.cc",
     "cpu_info_provider_mac.cc",
     "cpu_info_provider_win.cc",
diff --git a/extensions/browser/api/system_cpu/cpu_info_provider_android.cc b/extensions/browser/api/system_cpu/cpu_info_provider_android.cc
new file mode 100644
index 000000000000..2adbdb15f0f7
--- /dev/null
+++ b/extensions/browser/api/system_cpu/cpu_info_provider_android.cc
@@ -0,0 +1,77 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/browser/api/system_cpu/cpu_info_provider.h"
+
+#include <stdint.h>
+
+#include <cstdio>
+#include <sstream>
+
+#include "base/files/file_util.h"
+#include "base/format_macros.h"
+
+namespace extensions {
+
+namespace {
+
+const char kProcStat[] = "/proc/stat";
+
+}  // namespace
+
+bool CpuInfoProvider::QueryCpuTimePerProcessor(
+    std::vector<api::system_cpu::ProcessorInfo>* infos) {
+  DCHECK(infos);
+
+  // WARNING: this method may return incomplete data because some processors may
+  // be brought offline at runtime. /proc/stat does not report statistics of
+  // offline processors. CPU usages of offline processors will be filled with
+  // zeros.
+  //
+  // An example of output of /proc/stat when processor 0 and 3 are online, but
+  // processor 1 and 2 are offline:
+  //
+  //   cpu  145292 20018 83444 1485410 995 44 3578 0 0 0
+  //   cpu0 138060 19947 78350 1479514 570 44 3576 0 0 0
+  //   cpu3 2033 32 1075 1400 52 0 1 0 0 0
+  std::string contents;
+  if (!base::ReadFileToString(base::FilePath(kProcStat), &contents))
+    return false;
+
+  std::istringstream iss(contents);
+  std::string line;
+
+  // Skip the first line because it is just an aggregated number of
+  // all cpuN lines.
+  std::getline(iss, line);
+  while (std::getline(iss, line)) {
+    if (line.compare(0, 3, "cpu") != 0)
+      continue;
+
+    uint64_t user = 0, nice = 0, sys = 0, idle = 0;
+    uint32_t pindex = 0;
+    int vals =
+        sscanf(line.c_str(),
+               "cpu%" PRIu32 " %" PRIu64 " %" PRIu64 " %" PRIu64 " %" PRIu64,
+               &pindex,
+               &user,
+               &nice,
+               &sys,
+               &idle);
+    if (vals != 5 || pindex >= infos->size()) {
+      NOTREACHED();
+      return false;
+    }
+
+    infos->at(pindex).usage.kernel = static_cast<double>(sys);
+    infos->at(pindex).usage.user = static_cast<double>(user + nice);
+    infos->at(pindex).usage.idle = static_cast<double>(idle);
+    infos->at(pindex).usage.total =
+        static_cast<double>(sys + user + nice + idle);
+  }
+
+  return true;
+}
+
+}  // namespace extensions
diff --git a/extensions/browser/extensions_browser_client.cc b/extensions/browser/extensions_browser_client.cc
index f2a503e5d6de..d508de715184 100644
--- a/extensions/browser/extensions_browser_client.cc
+++ b/extensions/browser/extensions_browser_client.cc
@@ -21,6 +21,7 @@ ExtensionsBrowserClient::ExtensionsBrowserClient() {}
 ExtensionsBrowserClient::~ExtensionsBrowserClient() = default;
 
 ExtensionsBrowserClient* ExtensionsBrowserClient::Get() {
+  LOG(ERROR) << "[Kiwi] ExtensionsBrowserClient::Get - Step: " << g_extension_browser_client;
   return g_extension_browser_client;
 }
 
diff --git a/extensions/browser/guest_view/web_view/web_view_guest.cc b/extensions/browser/guest_view/web_view/web_view_guest.cc
index 7ab074a466e6..2e172eea7042 100644
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -145,6 +145,7 @@ static std::string TerminationStatusToString(base::TerminationStatus status) {
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED_BY_OOM:
       return "oom killed";
 #endif
+    case base::TERMINATION_STATUS_OOM_PROTECTED:
     case base::TERMINATION_STATUS_OOM:
       return "oom";
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:
diff --git a/extensions/buildflags/buildflags.gni b/extensions/buildflags/buildflags.gni
index 6836e4ae3310..8a637a78a4c7 100644
--- a/extensions/buildflags/buildflags.gni
+++ b/extensions/buildflags/buildflags.gni
@@ -5,7 +5,7 @@
 import("//build/config/features.gni")
 
 declare_args() {
-  enable_extensions = !is_android && !is_ios && !is_fuchsia
+  enable_extensions = !is_ios && !is_fuchsia
 
   # Enables Wi-Fi Display functionality
   # WARNING: This enables MPEG Transport Stream (MPEG-TS) encoding!
diff --git a/google_apis/BUILD.gn b/google_apis/BUILD.gn
index 29d2d7596c89..c58bd1d2fb26 100644
--- a/google_apis/BUILD.gn
+++ b/google_apis/BUILD.gn
@@ -140,7 +140,7 @@ template("google_apis_tmpl") {
       "//services/network/public/cpp",
     ]
 
-    if (use_official_google_api_keys) {
+    if (false && use_official_google_api_keys) {
       deps += [ "internal:generate_metrics_key_header" ]
     }
 
diff --git a/mojo/public/js/mojo_bindings_resources.grd b/mojo/public/js/mojo_bindings_resources.grd
index 4f4db5fe4487..ec4923c33fc0 100644
--- a/mojo/public/js/mojo_bindings_resources.grd
+++ b/mojo/public/js/mojo_bindings_resources.grd
@@ -14,7 +14,7 @@
   <release seq="1">
     <includes>
       <!-- All resources included on Android should use the lite bindings. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MOJO_MOJO_BINDINGS_JS"
             file="${root_gen_dir}/mojo/public/js/mojo_bindings.js"
             use_base_dir="false"
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index 4c19c0567d12..4358b7453480 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -292,6 +292,10 @@ void URLRequestHttpJob::Start() {
       http_user_agent_settings_ ?
           http_user_agent_settings_->GetUserAgent() : std::string());
 
+  if (request_info_.url.host().find("chrome.google.com") != std::string::npos) {
+    request_info_.extra_headers.SetHeader(HttpRequestHeaders::kUserAgent, "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.90 Safari/537.36");
+  }
+
   AddExtraHeaders();
   AddCookieHeaderAndStart();
 }
diff --git a/services/device/public/cpp/hid/BUILD.gn b/services/device/public/cpp/hid/BUILD.gn
index 3408f2bca518..686e7b30f92b 100644
--- a/services/device/public/cpp/hid/BUILD.gn
+++ b/services/device/public/cpp/hid/BUILD.gn
@@ -7,7 +7,7 @@ import("//build/config/features.gni")
 source_set("hid") {
   # HID is not implemented on Android and we want to be particularly careful
   # about not bloating binary size by accidentially including it.
-  assert(!is_android)
+#  assert(!is_android)
 
   sources = [
     "fake_input_service_linux.cc",
diff --git a/services/service_manager/embedder/main.cc b/services/service_manager/embedder/main.cc
index 53e9e0aafc49..b90f70422cf4 100644
--- a/services/service_manager/embedder/main.cc
+++ b/services/service_manager/embedder/main.cc
@@ -251,6 +251,8 @@ int Main(const MainParams& params) {
   MainDelegate* delegate = params.delegate;
   DCHECK(delegate);
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 1";
+
   int exit_code = -1;
   base::debug::GlobalActivityTracker* tracker = nullptr;
   ProcessType process_type = delegate->OverrideProcessType();
@@ -258,6 +260,7 @@ int Main(const MainParams& params) {
   std::unique_ptr<base::mac::ScopedNSAutoreleasePool> autorelease_pool;
 #endif
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 2";
   // A flag to indicate whether Main() has been called before. On Android, we
   // may re-run Main() without restarting the browser process. This flag
   // prevents initializing things more than once.
@@ -265,12 +268,15 @@ int Main(const MainParams& params) {
 #if !defined(OS_ANDROID)
   DCHECK(!is_initialized);
 #endif
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3";
   if (!is_initialized) {
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3a";
     is_initialized = true;
 #if defined(OS_MACOSX) && BUILDFLAG(USE_ALLOCATOR_SHIM)
     base::allocator::InitializeAllocatorShim();
 #endif
     base::EnableTerminationOnOutOfMemory();
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3b";
 
 #if defined(OS_LINUX)
     // The various desktop environments set this environment variable that
@@ -286,6 +292,7 @@ int Main(const MainParams& params) {
     setenv("DBUS_SESSION_BUS_ADDRESS", "disabled:", kNoOverrideIfAlreadySet);
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3c";
 #if defined(OS_WIN)
     base::win::RegisterInvalidParamHandler();
     ui::win::CreateATLModuleIfNeeded();
@@ -301,17 +308,20 @@ int Main(const MainParams& params) {
     argc = params.argc;
     argv = params.argv;
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3d";
 
     base::CommandLine::Init(argc, argv);
 
 #if defined(OS_POSIX)
     PopulateFDsFromCommandLine();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3e";
 
     base::EnableTerminationOnHeapCorruption();
 
     SetProcessTitleFromCommandLine(argv);
 #endif  // !defined(OS_ANDROID)
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3f";
 
 // On Android setlocale() is not supported, and we don't override the signal
 // handlers so we can get a stack trace when crashing.
@@ -332,6 +342,7 @@ int Main(const MainParams& params) {
 
     SetupSignalHandlers();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3g";
 
     const auto& command_line = *base::CommandLine::ForCurrentProcess();
 
@@ -339,6 +350,7 @@ int Main(const MainParams& params) {
     base::win::SetupCRT(command_line);
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3h";
     MainDelegate::InitializeParams init_params;
 
 #if defined(OS_MACOSX)
@@ -350,6 +362,7 @@ int Main(const MainParams& params) {
     init_params.autorelease_pool = autorelease_pool.get();
     InitializeMac();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3i";
 
     mojo::core::Configuration mojo_config;
     if (process_type == ProcessType::kDefault &&
@@ -357,16 +370,21 @@ int Main(const MainParams& params) {
             switches::kProcessTypeServiceManager) {
       mojo_config.is_broker_process = true;
     }
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3j";
     mojo_config.max_message_num_bytes = kMaximumMojoMessageSize;
     delegate->OverrideMojoConfiguration(&mojo_config);
     mojo::core::Init(mojo_config);
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3k";
     ui::RegisterPathProvider();
 
     tracker = base::debug::GlobalActivityTracker::Get();
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3l";
     exit_code = delegate->Initialize(init_params);
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3m";
     if (exit_code >= 0) {
       if (tracker) {
+        LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3n";
         tracker->SetProcessPhase(
             base::debug::GlobalActivityTracker::PROCESS_LAUNCH_FAILED);
         tracker->process_data().SetInt("exit-code", exit_code);
@@ -374,6 +392,7 @@ int Main(const MainParams& params) {
       return exit_code;
     }
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3o";
 #if defined(OS_WIN)
     // Route stdio to parent console (if any) or create one.
     if (base::CommandLine::ForCurrentProcess()->HasSwitch(
@@ -382,6 +401,7 @@ int Main(const MainParams& params) {
     }
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3p";
     if (base::CommandLine::ForCurrentProcess()->HasSwitch(
             ::switches::kTraceToConsole)) {
       base::trace_event::TraceConfig trace_config =
@@ -391,6 +411,7 @@ int Main(const MainParams& params) {
     }
   }
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 4";
   const auto& command_line = *base::CommandLine::ForCurrentProcess();
   if (process_type == ProcessType::kDefault) {
     std::string type_switch =
@@ -403,21 +424,26 @@ int Main(const MainParams& params) {
       process_type = ProcessType::kEmbedder;
     }
   }
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5";
   switch (process_type) {
     case ProcessType::kDefault:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5a";
       NOTREACHED();
       break;
 
     case ProcessType::kServiceManager:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5b";
       exit_code = RunServiceManager(delegate);
       break;
 
     case ProcessType::kService:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5c";
       CommonSubprocessInit();
       exit_code = RunService(delegate);
       break;
 
     case ProcessType::kEmbedder:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5d";
       if (delegate->IsEmbedderSubprocess())
         CommonSubprocessInit();
       exit_code = delegate->RunEmbedderProcess();
@@ -425,6 +451,7 @@ int Main(const MainParams& params) {
   }
 
   if (tracker) {
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5e";
     if (exit_code == 0) {
       tracker->SetProcessPhaseIfEnabled(
           base::debug::GlobalActivityTracker::PROCESS_EXITED_CLEANLY);
diff --git a/services/tracing/public/cpp/perfetto/perfetto_traced_process.cc b/services/tracing/public/cpp/perfetto/perfetto_traced_process.cc
index 24a37c545575..be088a3e44f5 100644
--- a/services/tracing/public/cpp/perfetto/perfetto_traced_process.cc
+++ b/services/tracing/public/cpp/perfetto/perfetto_traced_process.cc
@@ -143,19 +143,24 @@ PerfettoTaskRunner* PerfettoTracedProcess::GetTaskRunner() {
 void PerfettoTracedProcess::ResetTaskRunnerForTesting(
     scoped_refptr<base::SequencedTaskRunner> task_runner) {
   GetTaskRunner()->ResetTaskRunnerForTesting(task_runner);
+  LOG(ERROR) << "[Kiwi] PerfettoTracedProcess::ResetTaskRunnerForTesting - Step 1";
   InitTracingPostThreadPoolStartAndFeatureList();
   // Detaching the sequence_checker_ must happen after we reset the task runner.
   // This is because the Get() could call the constructor (if this is the first
   // call to Get()) which would then PostTask which would create races if we
   // reset the task runner right afterwards.
+  LOG(ERROR) << "[Kiwi] PerfettoTracedProcess::ResetTaskRunnerForTesting - Step 2";
   DETACH_FROM_SEQUENCE(PerfettoTracedProcess::Get()->sequence_checker_);
   // Call Get() explicitly. This ensures that we constructed the
   // PerfettoTracedProcess. On some tests (like cast linux) the DETACH macro is
   // compiled to nothing, which woud cause this PostTask to access a nullptr the
   // producer requires a PostTask from inside the constructor.
+  LOG(ERROR) << "[Kiwi] PerfettoTracedProcess::ResetTaskRunnerForTesting - Step 3";
   PerfettoTracedProcess::Get();
+  LOG(ERROR) << "[Kiwi] PerfettoTracedProcess::ResetTaskRunnerForTesting - Step 4";
   PerfettoTracedProcess::GetTaskRunner()->GetOrCreateTaskRunner()->PostTask(
       FROM_HERE, base::BindOnce([]() {
+  LOG(ERROR) << "[Kiwi] PerfettoTracedProcess::ResetTaskRunnerForTesting - BindOnce";
         auto* producer =
             PerfettoTracedProcess::Get()->SystemProducerForTesting();
         CHECK(producer);
diff --git a/services/tracing/public/cpp/trace_startup.cc b/services/tracing/public/cpp/trace_startup.cc
index 3827c2a8f9f2..a7be4fe0eab4 100644
--- a/services/tracing/public/cpp/trace_startup.cc
+++ b/services/tracing/public/cpp/trace_startup.cc
@@ -100,8 +100,11 @@ void InitTracingPostThreadPoolStartAndFeatureList() {
   // TODO(nuskos): We should switch these to DCHECK once we're reasonably
   // confident we've ensured this is called properly in all processes. Probably
   // after M78 release has been cut (since we'll verify in the rollout of M78).
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 3: " << base::ThreadPoolInstance::Get();
   CHECK(base::ThreadPoolInstance::Get());
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 4: " << base::FeatureList::GetInstance();
   CHECK(base::FeatureList::GetInstance());
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 5";
   // Below are the things tracing must do once per process.
   TraceEventDataSource::GetInstance()->OnTaskSchedulerAvailable();
   if (ShouldSetupSystemTracing()) {
@@ -111,6 +114,7 @@ void InitTracingPostThreadPoolStartAndFeatureList() {
     // state. This Get() call ensures that the constructor has run.
     PerfettoTracedProcess::Get();
   }
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 6";
 }
 
 void PropagateTracingFlagsToChildProcessCmdLine(base::CommandLine* cmd_line) {
diff --git a/third_party/blink/public/mojom/BUILD.gn b/third_party/blink/public/mojom/BUILD.gn
index 687a0ba72ecb..736efffdecc3 100644
--- a/third_party/blink/public/mojom/BUILD.gn
+++ b/third_party/blink/public/mojom/BUILD.gn
@@ -153,7 +153,7 @@ mojom("mojom_platform") {
     "worker/worker_main_script_load_params.mojom",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     sources += [ "serial/serial.mojom" ]
   }
 
diff --git a/third_party/libavif/src b/third_party/libavif/src
new file mode 160000
index 000000000000..167e406f1e2b
--- /dev/null
+++ b/third_party/libavif/src
@@ -0,0 +1 @@
+Subproject commit 167e406f1e2b86f6699224b5c492dc9e862ab539
diff --git a/third_party/libgav1/src b/third_party/libgav1/src
new file mode 160000
index 000000000000..638ef84819f8
--- /dev/null
+++ b/third_party/libgav1/src
@@ -0,0 +1 @@
+Subproject commit 638ef84819f8b3cd614dcf63378fe4814aa4cb2a
diff --git a/third_party/pywebsocket3/src b/third_party/pywebsocket3/src
new file mode 160000
index 000000000000..89c922843410
--- /dev/null
+++ b/third_party/pywebsocket3/src
@@ -0,0 +1 @@
+Subproject commit 89c9228434100e4dabb19f61d0d4f55625940638
diff --git a/third_party/sqlite/src b/third_party/sqlite/src
new file mode 160000
index 000000000000..c906d361bd62
--- /dev/null
+++ b/third_party/sqlite/src
@@ -0,0 +1 @@
+Subproject commit c906d361bd62412e009a4ab8a9077ccf974b2fd8
diff --git a/third_party/turbine/src b/third_party/turbine/src
new file mode 160000
index 000000000000..95f6fb6f1e96
--- /dev/null
+++ b/third_party/turbine/src
@@ -0,0 +1 @@
+Subproject commit 95f6fb6f1e962e8b6ec672905b0b04233f002dc2
diff --git a/third_party/webgpu-cts/src b/third_party/webgpu-cts/src
new file mode 160000
index 000000000000..d2bd82eb5431
--- /dev/null
+++ b/third_party/webgpu-cts/src
@@ -0,0 +1 @@
+Subproject commit d2bd82eb543151dc9db4e058483a34bc4a3b6ff0
diff --git a/third_party/weston/src b/third_party/weston/src
new file mode 160000
index 000000000000..db905f467169
--- /dev/null
+++ b/third_party/weston/src
@@ -0,0 +1 @@
+Subproject commit db905f467169f9f131c5ddc6038296f866d5daeb
diff --git a/ui/android/window_android.h b/ui/android/window_android.h
index e9dfbc755172..b21643e8a5d5 100644
--- a/ui/android/window_android.h
+++ b/ui/android/window_android.h
@@ -54,6 +54,14 @@ class UI_ANDROID_EXPORT WindowAndroid : public ViewAndroid {
 
   base::android::ScopedJavaLocalRef<jobject> GetJavaObject();
 
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::PointF* point);
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::Point* point);
+
+
   // Compositor callback relay.
   void OnCompositingDidCommit();
 
diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index 224ced89a428..6b2f4dcba89b 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -447,6 +447,11 @@ jumbo_component("base") {
     deps += [ "//third_party/re2" ]
   }
 
+  sources += [
+    "dragdrop/os_exchange_data_provider_android.cc",
+    "dragdrop/os_exchange_data_provider_android.h",
+  ]
+
   if (!is_ios) {
     # iOS does not use Chromium-specific code for event handling.
     public_deps += [
@@ -607,7 +612,7 @@ jumbo_component("base") {
     ]
   }
 
-  if (!toolkit_views && !use_aura) {
+  if (false && !toolkit_views && !use_aura) {
     sources -= [
       "dragdrop/drag_drop_types.h",
       "dragdrop/drop_target_event.cc",
@@ -624,16 +629,6 @@ jumbo_component("base") {
   if (is_android) {
     deps += [ ":ui_base_jni_headers" ]
     libs += [ "jnigraphics" ]
-
-    sources -= [
-      "cursor/cursor_android.cc",
-      "default_theme_provider.cc",
-      "l10n/l10n_font_util.cc",
-      "models/button_menu_item_model.cc",
-      "pointer/touch_editing_controller.cc",
-      "theme_provider.cc",
-      "ui_base_types.cc",
-    ]
   }
 
   if (use_aura) {
diff --git a/ui/base/cursor/cursor.cc b/ui/base/cursor/cursor.cc
index be37579590ec..e4e62e4aa97c 100644
--- a/ui/base/cursor/cursor.cc
+++ b/ui/base/cursor/cursor.cc
@@ -36,7 +36,7 @@ void Cursor::SetPlatformCursor(const PlatformCursor& platform) {
     RefCustomCursor();
 }
 
-#if !defined(USE_AURA)
+#if false && !defined(USE_AURA)
 void Cursor::RefCustomCursor() {
   NOTIMPLEMENTED();
 }
diff --git a/ui/base/dragdrop/os_exchange_data.cc b/ui/base/dragdrop/os_exchange_data.cc
index 4af8c7b6fcd3..1aa1cc7d963c 100644
--- a/ui/base/dragdrop/os_exchange_data.cc
+++ b/ui/base/dragdrop/os_exchange_data.cc
@@ -114,7 +114,7 @@ bool OSExchangeData::HasAnyFormat(
   if ((formats & FILE_CONTENTS) != 0 && provider_->HasFileContents())
     return true;
 #endif
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
   if ((formats & HTML) != 0 && provider_->HasHtml())
     return true;
 #endif
@@ -159,7 +159,7 @@ void OSExchangeData::SetDownloadFileInfo(DownloadFileInfo* download) {
 }
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
 bool OSExchangeData::HasHtml() const {
   return provider_->HasHtml();
 }
diff --git a/ui/base/dragdrop/os_exchange_data.h b/ui/base/dragdrop/os_exchange_data.h
index 484e0df3dfef..dff0c7b94077 100644
--- a/ui/base/dragdrop/os_exchange_data.h
+++ b/ui/base/dragdrop/os_exchange_data.h
@@ -63,7 +63,7 @@ class UI_BASE_EXPORT OSExchangeData {
 #if defined(OS_WIN)
     FILE_CONTENTS  = 1 << 4,
 #endif
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
     HTML           = 1 << 5,
 #endif
   };
@@ -138,13 +138,13 @@ class UI_BASE_EXPORT OSExchangeData {
     virtual void SetDownloadFileInfo(DownloadFileInfo* download) = 0;
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
     virtual void SetHtml(const base::string16& html, const GURL& base_url) = 0;
     virtual bool GetHtml(base::string16* html, GURL* base_url) const = 0;
     virtual bool HasHtml() const = 0;
 #endif
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if true || defined(USE_AURA) || defined(OS_MACOSX)
     virtual void SetDragImage(const gfx::ImageSkia& image,
                               const gfx::Vector2d& cursor_offset) = 0;
     virtual gfx::ImageSkia GetDragImage() const = 0;
@@ -269,7 +269,7 @@ class UI_BASE_EXPORT OSExchangeData {
   void SetDownloadFileInfo(DownloadFileInfo* download);
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
   // Adds a snippet of HTML.  |html| is just raw html but this sets both
   // text/html and CF_HTML.
   void SetHtml(const base::string16& html, const GURL& base_url);
diff --git a/ui/base/dragdrop/os_exchange_data_provider_android.cc b/ui/base/dragdrop/os_exchange_data_provider_android.cc
new file mode 100644
index 000000000000..530c1e4ac627
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.cc
@@ -0,0 +1,220 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/dragdrop/file_info.h"
+
+namespace ui {
+
+OSExchangeDataProviderAndroid::OSExchangeDataProviderAndroid()
+    : formats_(0) {
+}
+
+OSExchangeDataProviderAndroid::~OSExchangeDataProviderAndroid() = default;
+
+std::unique_ptr<OSExchangeData::Provider>
+OSExchangeDataProviderAndroid::Clone() const {
+  OSExchangeDataProviderAndroid* ret = new OSExchangeDataProviderAndroid();
+  ret->formats_ = formats_;
+  ret->string_ = string_;
+  ret->url_ = url_;
+  ret->title_ = title_;
+  ret->filenames_ = filenames_;
+  ret->pickle_data_ = pickle_data_;
+  // We skip copying the drag images.
+  ret->html_ = html_;
+  ret->base_url_ = base_url_;
+
+  return base::WrapUnique<OSExchangeData::Provider>(ret);
+}
+
+void OSExchangeDataProviderAndroid::MarkOriginatedFromRenderer() {
+  // TODO(dcheng): Currently unneeded because ChromeOS Android correctly separates
+  // URL and filename metadata, and does not implement the DownloadURL protocol.
+}
+
+bool OSExchangeDataProviderAndroid::DidOriginateFromRenderer() const {
+  return false;
+}
+
+void OSExchangeDataProviderAndroid::SetString(const base::string16& data) {
+  if (HasString())
+    return;
+
+  string_ = data;
+  formats_ |= OSExchangeData::STRING;
+}
+
+void OSExchangeDataProviderAndroid::SetURL(const GURL& url,
+                                        const base::string16& title) {
+  url_ = url;
+  title_ = title;
+  formats_ |= OSExchangeData::URL;
+
+  SetString(base::UTF8ToUTF16(url.spec()));
+}
+
+void OSExchangeDataProviderAndroid::SetFilename(const base::FilePath& path) {
+  filenames_.clear();
+  filenames_.push_back(FileInfo(path, base::FilePath()));
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetFilenames(
+    const std::vector<FileInfo>& filenames) {
+  filenames_ = filenames;
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetPickledData(
+    const ClipboardFormatType& format,
+    const base::Pickle& data) {
+  pickle_data_[format] = data;
+  formats_ |= OSExchangeData::PICKLED_DATA;
+}
+
+bool OSExchangeDataProviderAndroid::GetString(base::string16* data) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+  *data = string_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetURLAndTitle(
+    OSExchangeData::FilenameToURLPolicy policy,
+    GURL* url,
+    base::string16* title) const {
+  if ((formats_ & OSExchangeData::URL) == 0) {
+    title->clear();
+    return GetPlainTextURL(url) ||
+           (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(url));
+  }
+
+  if (!url_.is_valid())
+    return false;
+
+  *url = url_;
+  *title = title_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilename(base::FilePath* path) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  DCHECK(!filenames_.empty());
+  *path = filenames_[0].path;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilenames(
+    std::vector<FileInfo>* filenames) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  *filenames = filenames_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPickledData(
+    const ClipboardFormatType& format,
+    base::Pickle* data) const {
+  PickleData::const_iterator i = pickle_data_.find(format);
+  if (i == pickle_data_.end())
+    return false;
+
+  *data = i->second;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasString() const {
+  return (formats_ & OSExchangeData::STRING) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasURL(
+    OSExchangeData::FilenameToURLPolicy policy) const {
+  if ((formats_ & OSExchangeData::URL) != 0) {
+    return true;
+  }
+  // No URL, see if we have plain text that can be parsed as a URL.
+  return GetPlainTextURL(NULL) ||
+         (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(nullptr));
+}
+
+bool OSExchangeDataProviderAndroid::HasFile() const {
+  return (formats_ & OSExchangeData::FILE_NAME) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasCustomFormat(
+    const ClipboardFormatType& format) const {
+  return pickle_data_.find(format) != pickle_data_.end();
+}
+
+void OSExchangeDataProviderAndroid::SetHtml(const base::string16& html,
+                                         const GURL& base_url) {
+  formats_ |= OSExchangeData::HTML;
+  html_ = html;
+  base_url_ = base_url;
+}
+
+bool OSExchangeDataProviderAndroid::GetHtml(base::string16* html,
+                                         GURL* base_url) const {
+  if ((formats_ & OSExchangeData::HTML) == 0)
+    return false;
+  *html = html_;
+  *base_url = base_url_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasHtml() const {
+  return ((formats_ & OSExchangeData::HTML) != 0);
+}
+
+void OSExchangeDataProviderAndroid::SetDragImage(
+    const gfx::ImageSkia& image,
+    const gfx::Vector2d& cursor_offset) {
+  drag_image_ = image;
+  drag_image_offset_ = cursor_offset;
+}
+
+gfx::ImageSkia OSExchangeDataProviderAndroid::GetDragImage() const {
+  return drag_image_;
+}
+
+gfx::Vector2d OSExchangeDataProviderAndroid::GetDragImageOffset() const {
+  return drag_image_offset_;
+}
+
+bool OSExchangeDataProviderAndroid::GetFileURL(GURL* url) const {
+  base::FilePath file_path;
+  if (!GetFilename(&file_path))
+    return false;
+
+  GURL test_url = net::FilePathToFileURL(file_path);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPlainTextURL(GURL* url) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+
+  GURL test_url(string_);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+}  // namespace ui
diff --git a/ui/base/dragdrop/os_exchange_data_provider_android.h b/ui/base/dragdrop/os_exchange_data_provider_android.h
new file mode 100644
index 000000000000..e76e9d6973d3
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.h
@@ -0,0 +1,101 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+
+#include <map>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/pickle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/image/image_skia.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+struct ClipboardFormatType;
+
+// OSExchangeData::Provider implementation for Android on linux.
+class UI_BASE_EXPORT OSExchangeDataProviderAndroid
+    : public OSExchangeData::Provider {
+ public:
+  OSExchangeDataProviderAndroid();
+  ~OSExchangeDataProviderAndroid() override;
+
+  // Overridden from OSExchangeData::Provider:
+  std::unique_ptr<Provider> Clone() const override;
+  void MarkOriginatedFromRenderer() override;
+  bool DidOriginateFromRenderer() const override;
+  void SetString(const base::string16& data) override;
+  void SetURL(const GURL& url, const base::string16& title) override;
+  void SetFilename(const base::FilePath& path) override;
+  void SetFilenames(const std::vector<FileInfo>& filenames) override;
+  void SetPickledData(const ClipboardFormatType& format,
+                      const base::Pickle& data) override;
+  bool GetString(base::string16* data) const override;
+  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
+                      GURL* url,
+                      base::string16* title) const override;
+  bool GetFilename(base::FilePath* path) const override;
+  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
+  bool GetPickledData(const ClipboardFormatType& format,
+                      base::Pickle* data) const override;
+  bool HasString() const override;
+  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
+  bool HasFile() const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
+
+  void SetHtml(const base::string16& html, const GURL& base_url) override;
+  bool GetHtml(base::string16* html, GURL* base_url) const override;
+  bool HasHtml() const override;
+  void SetDragImage(const gfx::ImageSkia& image,
+                    const gfx::Vector2d& cursor_offset) override;
+  gfx::ImageSkia GetDragImage() const override;
+  gfx::Vector2d GetDragImageOffset() const override;
+
+ private:
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
+
+  // Returns true if |formats_| contains a file format and the file name can be
+  // parsed as a URL.
+  bool GetFileURL(GURL* url) const;
+
+  // Returns true if |formats_| contains a string format and the string can be
+  // parsed as a URL.
+  bool GetPlainTextURL(GURL* url) const;
+
+  // Actual formats that have been set. See comment above |known_formats_|
+  // for details.
+  int formats_;
+
+  // String contents.
+  base::string16 string_;
+
+  // URL contents.
+  GURL url_;
+  base::string16 title_;
+
+  // File name.
+  std::vector<FileInfo> filenames_;
+
+  // PICKLED_DATA contents.
+  PickleData pickle_data_;
+
+  // Drag image and offset data.
+  gfx::ImageSkia drag_image_;
+  gfx::Vector2d drag_image_offset_;
+
+  // For HTML format
+  base::string16 html_;
+  GURL base_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAndroid);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
diff --git a/ui/base/dragdrop/os_exchange_data_provider_factory.cc b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
index 4c5fbfbc079a..6ed61179eadf 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_factory.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
@@ -16,6 +16,8 @@
 #include "ui/base/dragdrop/os_exchange_data_provider_win.h"
 #endif
 
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
 namespace ui {
 
 //static
@@ -34,7 +36,7 @@ OSExchangeDataProviderFactory::CreateProvider() {
   NOTIMPLEMENTED();
   return nullptr;
 #else
-#error "Unknown operating system"
+  return std::make_unique<OSExchangeDataProviderAndroid>();
 #endif
 }
 
diff --git a/ui/events/event.h b/ui/events/event.h
index f38982eda75b..f25cdf84a170 100644
--- a/ui/events/event.h
+++ b/ui/events/event.h
@@ -29,6 +29,7 @@
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/geometry/point_conversions.h"
 #include "ui/latency/latency_info.h"
+#include "ui/android/window_android.h"
 
 namespace gfx {
 class Transform;
diff --git a/ui/gfx/BUILD.gn b/ui/gfx/BUILD.gn
index 164089b84732..1e47a951f680 100644
--- a/ui/gfx/BUILD.gn
+++ b/ui/gfx/BUILD.gn
@@ -405,13 +405,6 @@ jumbo_component("gfx") {
     ]
   }
 
-  if ((!use_aura && !toolkit_views) || is_ios) {
-    sources -= [
-      "nine_image_painter.cc",
-      "nine_image_painter.h",
-    ]
-  }
-
   if (use_x11) {
     deps += [ "//ui/gfx/x" ]
     configs += [ "//build/config/linux:x11" ]
diff --git a/ui/gfx/animation/BUILD.gn b/ui/gfx/animation/BUILD.gn
index 52f57441e332..cec9e5cc0074 100644
--- a/ui/gfx/animation/BUILD.gn
+++ b/ui/gfx/animation/BUILD.gn
@@ -51,7 +51,7 @@ jumbo_component("animation") {
     sources += [ "animation_win.cc" ]
   }
 
-  if (!is_android) {
+  if (true || !is_android) {
     sources += [
       "throb_animation.cc",
       "throb_animation.h",
diff --git a/ui/message_center/BUILD.gn b/ui/message_center/BUILD.gn
index 9ca2f4b5ce17..3b84024d8675 100644
--- a/ui/message_center/BUILD.gn
+++ b/ui/message_center/BUILD.gn
@@ -38,7 +38,7 @@ jumbo_component("message_center") {
 
   defines = [ "MESSAGE_CENTER_IMPLEMENTATION" ]
 
-  if (enable_message_center) {
+  if (true || enable_message_center) {
     deps += [
       ":message_center_vector_icons",
       "//base:i18n",
@@ -90,7 +90,7 @@ jumbo_component("message_center") {
       ]
     }
 
-    if (toolkit_views) {
+    if (true || toolkit_views) {
       sources += [
         "views/desktop_message_popup_collection.cc",
         "views/desktop_message_popup_collection.h",
diff --git a/ui/native_theme/native_theme_android.cc b/ui/native_theme/native_theme_android.cc
index 1a33a8f3496a..b14357344315 100644
--- a/ui/native_theme/native_theme_android.cc
+++ b/ui/native_theme/native_theme_android.cc
@@ -22,8 +22,7 @@ NativeTheme* NativeTheme::GetInstanceForWeb() {
 }
 
 NativeTheme* NativeTheme::GetInstanceForNativeUi() {
-  NOTREACHED();
-  return nullptr;
+  return NativeThemeAndroid::instance();
 }
 #endif
 
diff --git a/ui/native_theme/native_theme_android.h b/ui/native_theme/native_theme_android.h
index 6d5c3811a0fa..30185986a2ce 100644
--- a/ui/native_theme/native_theme_android.h
+++ b/ui/native_theme/native_theme_android.h
@@ -20,11 +20,11 @@ class NativeThemeAndroid : public NativeThemeBase {
                         const ExtraParams& extra) const override;
   SkColor GetSystemColor(ColorId color_id,
                          ColorScheme color_scheme) const override;
+  static NativeThemeAndroid* instance();
 
  protected:
   friend class NativeTheme;
   friend class base::NoDestructor<NativeThemeAndroid>;
-  static NativeThemeAndroid* instance();
 
   // NativeThemeBase:
   void AdjustCheckboxRadioRectForPadding(SkRect* rect) const override;
diff --git a/ui/resources/BUILD.gn b/ui/resources/BUILD.gn
index a1be35643a27..bc5054a71373 100644
--- a/ui/resources/BUILD.gn
+++ b/ui/resources/BUILD.gn
@@ -209,7 +209,7 @@ repack("repack_ui_test_pak_100_percent") {
     ]
   }
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     deps += [ "//ui/views/resources" ]
     sources += [
       "$root_gen_dir/third_party/blink/public/resources/blink_resources.pak",
@@ -238,7 +238,7 @@ repack("repack_ui_test_pak_200_percent") {
     "//ui/resources",
   ]
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     deps += [ "//ui/views/resources" ]
     sources +=
         [ "$root_gen_dir/ui/views/resources/views_resources_200_percent.pak" ]
diff --git a/ui/resources/ui_resources.grd b/ui/resources/ui_resources.grd
index 5f88d78bfdea..398bdfe05624 100644
--- a/ui/resources/ui_resources.grd
+++ b/ui/resources/ui_resources.grd
@@ -78,7 +78,7 @@
         <structure type="chrome_scaled_image" name="IDR_AURA_CURSOR_ZOOM_IN" file="common/pointers/zoom_in.png" />
         <structure type="chrome_scaled_image" name="IDR_AURA_CURSOR_ZOOM_OUT" file="common/pointers/zoom_out.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2" file="close_2.png" />
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2_H" file="close_2_hover.png" />
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2_MASK" file="close_2_mask.png" />
@@ -92,7 +92,7 @@
       </if>
       <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON" file="common/default_favicon.png" />
       <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_DARK" file="common/default_favicon_dark.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_32" file="common/default_favicon_32.png" />
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_DARK_32" file="common/default_favicon_dark_32.png" />
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_64" file="common/default_favicon_64.png" />
@@ -134,7 +134,7 @@
       <if expr="toolkit_views and not is_macosx">
         <structure type="chrome_scaled_image" name="IDR_NOTIFICATION_SETTINGS" file="common/notification_settings.png"/>
       </if>
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <structure type="chrome_scaled_image" name="IDR_NTP_DEFAULT_FAVICON" file="common/ntp_default_favicon.png" />
       </if>
       <if expr="not is_android and not is_ios">
@@ -142,7 +142,7 @@
         <structure type="chrome_scaled_image" name="IDR_OOBE_ACTION_BOX_BUTTON_NORMAL" file="cros/action_box_button_normal.png" />
         <structure type="chrome_scaled_image" name="IDR_OOBE_ACTION_BOX_BUTTON_PRESSED" file="cros/action_box_button_pressed.png" />
       </if>
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_0_BAR" file="common/signal_0_bar.png" />
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_1_BAR" file="common/signal_1_bar.png" />
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_2_BAR" file="common/signal_2_bar.png" />
diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index 4c814e4495d3..7ce1d87cb1f7 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -12,7 +12,7 @@ import("//ui/base/ui_features.gni")
 import("//ui/ozone/ozone.gni")
 import("//ui/views/features.gni")
 
-assert(toolkit_views)
+# assert(toolkit_views)
 
 # Reset sources_assignment_filter for the BUILD.gn file to prevent
 # regression during the migration of Chromium away from the feature.
@@ -200,6 +200,7 @@ jumbo_component("views") {
     "drag_controller.h",
     "drag_utils.h",
     "event_monitor.h",
+    "event_monitor_android.h",
     "event_monitor_mac.h",
     "focus/external_focus_tracker.h",
     "focus/focus_manager.h",
@@ -260,6 +261,8 @@ jumbo_component("views") {
     "views_touch_selection_controller_factory.h",
     "widget/drop_helper.h",
     "widget/native_widget.h",
+    "widget/native_widget_aura.h",
+    "widget/native_widget_android.h",
     "widget/native_widget_delegate.h",
     "widget/native_widget_mac.h",
     "widget/native_widget_private.h",
@@ -355,8 +358,6 @@ jumbo_component("views") {
     "controls/image_view.cc",
     "controls/label.cc",
     "controls/link.cc",
-    "controls/menu/menu_closure_animation_mac.mm",
-    "controls/menu/menu_cocoa_watcher_mac.mm",
     "controls/menu/menu_config.cc",
     "controls/menu/menu_controller.cc",
     "controls/menu/menu_delegate.cc",
@@ -428,6 +429,7 @@ jumbo_component("views") {
     "metadata/metadata_types.cc",
     "metadata/type_conversion.cc",
     "metrics.cc",
+    "metrics_android.cc",
     "mouse_watcher.cc",
     "mouse_watcher_view_host.cc",
     "paint_info.cc",
@@ -658,6 +660,17 @@ jumbo_component("views") {
     ]
   }
 
+  sources += [
+      "native_cursor_android.cc",
+      "controls/native/native_view_host_android.cc",
+      "event_monitor_android.cc",
+      "widget/native_widget_android.cc",
+  ]
+
+  public += [
+      "controls/native/native_view_host_android.h",
+  ]
+
   if (use_aura) {
     public += [
       "accessibility/accessibility_alert_window.h",
@@ -682,6 +695,7 @@ jumbo_component("views") {
       "view_constants_aura.h",
       "widget/focus_manager_event_handler.h",
       "widget/native_widget_aura.h",
+      "widget/native_widget_android.h",
       "widget/tooltip_manager_aura.h",
       "widget/window_reorderer.h",
     ]
diff --git a/ui/views/controls/menu/menu_config.cc b/ui/views/controls/menu/menu_config.cc
index a798aad86b06..6f8fa31a21e6 100644
--- a/ui/views/controls/menu/menu_config.cc
+++ b/ui/views/controls/menu/menu_config.cc
@@ -12,7 +12,7 @@
 namespace views {
 
 MenuConfig::MenuConfig() {
-  Init();
+//  Init();
 }
 
 MenuConfig::~MenuConfig() = default;
diff --git a/ui/views/controls/menu/menu_config_android.cc b/ui/views/controls/menu/menu_config_android.cc
new file mode 100644
index 000000000000..ded2045a5536
--- /dev/null
+++ b/ui/views/controls/menu/menu_config_android.cc
@@ -0,0 +1,13 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/menu/menu_config.h"
+
+namespace views {
+
+void MenuConfig::Init() {
+  arrow_to_edge_padding = 6;
+}
+
+}  // namespace views
diff --git a/ui/views/controls/menu/menu_controller.cc b/ui/views/controls/menu/menu_controller.cc
index bbb1cc387eb2..6f80c431db9b 100644
--- a/ui/views/controls/menu/menu_controller.cc
+++ b/ui/views/controls/menu/menu_controller.cc
@@ -497,10 +497,6 @@ void MenuController::Run(Widget* parent,
     owner_ = parent;
     if (owner_)
       owner_->AddObserver(this);
-
-    // Only create a MenuPreTargetHandler for non-nested menus. Nested menus
-    // will use the existing one.
-    menu_pre_target_handler_ = MenuPreTargetHandler::Create(this, owner_);
   }
 
 #if defined(OS_MACOSX)
@@ -862,8 +858,6 @@ void MenuController::OnGestureEvent(SubmenuView* source,
 #if defined(OS_MACOSX)
     NOTIMPLEMENTED();
 #else   // !defined(OS_MACOSX)
-    event->ConvertLocationToTarget(source->GetWidget()->GetNativeWindow(),
-                                   owner()->GetNativeWindow());
 #endif  // defined(OS_MACOSX)
     owner()->OnGestureEvent(event);
     // Reset |send_gesture_events_to_owner_| when the first gesture ends.
@@ -1012,42 +1006,7 @@ int MenuController::OnDragUpdated(SubmenuView* source,
     if (menu_item)
       over_empty_menu = true;
   }
-  MenuDelegate::DropPosition drop_position = MenuDelegate::DropPosition::kNone;
   int drop_operation = ui::DragDropTypes::DRAG_NONE;
-  if (menu_item) {
-    gfx::Point menu_item_loc(event.location());
-    View::ConvertPointToTarget(source, menu_item, &menu_item_loc);
-    MenuItemView* query_menu_item;
-    if (!over_empty_menu) {
-      int menu_item_height = menu_item->height();
-      if (menu_item->HasSubmenu() &&
-          (menu_item_loc.y() > kDropBetweenPixels &&
-           menu_item_loc.y() < (menu_item_height - kDropBetweenPixels))) {
-        drop_position = MenuDelegate::DropPosition::kOn;
-      } else {
-        drop_position = (menu_item_loc.y() < menu_item_height / 2)
-                            ? MenuDelegate::DropPosition::kBefore
-                            : MenuDelegate::DropPosition::kAfter;
-      }
-      query_menu_item = menu_item;
-    } else {
-      query_menu_item = menu_item->GetParentMenuItem();
-      drop_position = MenuDelegate::DropPosition::kOn;
-    }
-    drop_operation = menu_item->GetDelegate()->GetDropOperation(
-        query_menu_item, event, &drop_position);
-
-    // If the menu has a submenu, schedule the submenu to open.
-    SetSelection(menu_item, menu_item->HasSubmenu() ? SELECTION_OPEN_SUBMENU
-                                                    : SELECTION_DEFAULT);
-
-    if (drop_position == MenuDelegate::DropPosition::kNone ||
-        drop_operation == ui::DragDropTypes::DRAG_NONE)
-      menu_item = nullptr;
-  } else {
-    SetSelection(source->GetMenuItem(), SELECTION_OPEN_SUBMENU);
-  }
-  SetDropMenuItem(menu_item, drop_position);
   last_drop_operation_ = drop_operation;
   return drop_operation;
 }
@@ -2869,34 +2828,6 @@ void MenuController::UpdateActiveMouseView(SubmenuView* event_source,
     if (target == target_menu || !target->GetEnabled())
       target = nullptr;
   }
-  View* active_mouse_view = active_mouse_view_tracker_->view();
-  if (target != active_mouse_view) {
-    SendMouseCaptureLostToActiveView();
-    active_mouse_view = target;
-    active_mouse_view_tracker_->SetView(active_mouse_view);
-    if (active_mouse_view) {
-      gfx::Point target_point(target_menu_loc);
-      View::ConvertPointToTarget(target_menu, active_mouse_view, &target_point);
-      ui::MouseEvent mouse_entered_event(ui::ET_MOUSE_ENTERED, target_point,
-                                         target_point, ui::EventTimeForNow(), 0,
-                                         0);
-      active_mouse_view->OnMouseEntered(mouse_entered_event);
-
-      ui::MouseEvent mouse_pressed_event(
-          ui::ET_MOUSE_PRESSED, target_point, target_point,
-          ui::EventTimeForNow(), event.flags(), event.changed_button_flags());
-      active_mouse_view->OnMousePressed(mouse_pressed_event);
-    }
-  }
-
-  if (active_mouse_view) {
-    gfx::Point target_point(target_menu_loc);
-    View::ConvertPointToTarget(target_menu, active_mouse_view, &target_point);
-    ui::MouseEvent mouse_dragged_event(
-        ui::ET_MOUSE_DRAGGED, target_point, target_point, ui::EventTimeForNow(),
-        event.flags(), event.changed_button_flags());
-    active_mouse_view->OnMouseDragged(mouse_dragged_event);
-  }
 }
 
 void MenuController::SendMouseReleaseToActiveView(SubmenuView* event_source,
diff --git a/ui/views/controls/menu/menu_host.cc b/ui/views/controls/menu/menu_host.cc
index e2bc742bd7de..09a760d709b9 100644
--- a/ui/views/controls/menu/menu_host.cc
+++ b/ui/views/controls/menu/menu_host.cc
@@ -80,13 +80,6 @@ class PreMenuEventDispatchHandler : public ui::EventHandler,
 #endif  // OS_MACOSX
 
 void TransferGesture(Widget* source, Widget* target) {
-#if defined(OS_MACOSX)
-  NOTIMPLEMENTED();
-#else   // !defined(OS_MACOSX)
-  source->GetGestureRecognizer()->TransferEventsTo(
-      source->GetNativeView(), target->GetNativeView(),
-      ui::TransferTouchesBehavior::kDontCancel);
-#endif  // defined(OS_MACOSX)
 }
 
 }  // namespace internal
@@ -138,12 +131,6 @@ void MenuHost::InitMenuHost(Widget* parent,
 #endif
   Init(std::move(params));
 
-#if !defined(OS_MACOSX)
-  pre_dispatch_handler_ =
-      std::make_unique<internal::PreMenuEventDispatchHandler>(
-          menu_controller, submenu_, GetNativeView());
-#endif
-
   DCHECK(!owner_);
   owner_ = parent;
   if (owner_)
@@ -158,32 +145,6 @@ bool MenuHost::IsMenuHostVisible() {
 }
 
 void MenuHost::ShowMenuHost(bool do_capture) {
-  // Doing a capture may make us get capture lost. Ignore it while we're in the
-  // process of showing.
-  base::AutoReset<bool> reseter(&ignore_capture_lost_, true);
-  ShowInactive();
-  if (do_capture) {
-    MenuController* menu_controller =
-        submenu_->GetMenuItem()->GetMenuController();
-    if (menu_controller && menu_controller->send_gesture_events_to_owner()) {
-      // TransferGesture when owner needs gesture events so that the incoming
-      // touch events after MenuHost is created are properly translated into
-      // gesture events instead of being dropped.
-      internal::TransferGesture(owner_, this);
-    } else {
-      GetGestureRecognizer()->CancelActiveTouchesExcept(nullptr);
-    }
-#if defined(MACOSX)
-    // Cancel existing touches, so we don't miss some touch release/cancel
-    // events due to the menu taking capture.
-    GetGestureRecognizer()->CancelActiveTouchesExcept(nullptr);
-#endif  // defined (OS_MACOSX)
-    // If MenuHost has no parent widget, it needs to call Show to get focus,
-    // so that it will get keyboard events.
-    if (owner_ == nullptr)
-      Show();
-    native_widget_private()->SetCapture();
-  }
 }
 
 void MenuHost::HideMenuHost() {
@@ -203,9 +164,6 @@ void MenuHost::DestroyMenuHost() {
   HideMenuHost();
   destroying_ = true;
   static_cast<MenuHostRootView*>(GetRootView())->ClearSubmenu();
-#if !defined(OS_MACOSX)
-  pre_dispatch_handler_.reset();
-#endif
   Close();
 }
 
diff --git a/ui/views/controls/menu/menu_host.h b/ui/views/controls/menu/menu_host.h
index e3df270ad1df..2edfb41d5e00 100644
--- a/ui/views/controls/menu/menu_host.h
+++ b/ui/views/controls/menu/menu_host.h
@@ -95,11 +95,6 @@ class MenuHost : public Widget, public WidgetObserver {
   // If true and capture is lost we don't notify the delegate.
   bool ignore_capture_lost_;
 
-#if !defined(OS_MACOSX)
-  // Handles raw touch events at the moment.
-  std::unique_ptr<internal::PreMenuEventDispatchHandler> pre_dispatch_handler_;
-#endif
-
   DISALLOW_COPY_AND_ASSIGN(MenuHost);
 };
 
diff --git a/ui/views/controls/native/native_view_host_android.cc b/ui/views/controls/native/native_view_host_android.cc
new file mode 100644
index 000000000000..6fa914c45f21
--- /dev/null
+++ b/ui/views/controls/native/native_view_host_android.cc
@@ -0,0 +1,121 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/native/native_view_host_android.h"
+
+#include <memory>
+
+#include "base/logging.h"
+#include "base/optional.h"
+#include "build/build_config.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/base/hit_test.h"
+#include "ui/compositor/paint_recorder.h"
+#include "ui/gfx/geometry/insets.h"
+#include "ui/views/controls/native/native_view_host.h"
+#include "ui/views/painter.h"
+#include "ui/views/view_class_properties.h"
+#include "ui/views/widget/widget.h"
+
+namespace views {
+
+NativeViewHostAndroid::NativeViewHostAndroid(NativeViewHost* host) : host_(host) {}
+
+NativeViewHostAndroid::~NativeViewHostAndroid() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeViewHostAura, NativeViewHostWrapper implementation:
+void NativeViewHostAndroid::AttachNativeView() {
+}
+
+void NativeViewHostAndroid::SetParentAccessible(
+    gfx::NativeViewAccessible accessible) {
+}
+
+void NativeViewHostAndroid::NativeViewDetaching(bool destroyed) {
+}
+
+void NativeViewHostAndroid::AddedToWidget() {
+}
+
+void NativeViewHostAndroid::RemovedFromWidget() {
+}
+
+bool NativeViewHostAndroid::SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) {
+  return false;
+}
+
+void NativeViewHostAndroid::SetHitTestTopInset(int top_inset) {
+}
+
+void NativeViewHostAndroid::InstallClip(int x, int y, int w, int h) {
+}
+
+int NativeViewHostAndroid::GetHitTestTopInset() const {
+  return top_inset_;
+}
+
+bool NativeViewHostAndroid::HasInstalledClip() {
+  return !!clip_rect_;
+}
+
+void NativeViewHostAndroid::UninstallClip() {
+  clip_rect_.reset();
+}
+
+void NativeViewHostAndroid::ShowWidget(int x,
+                                    int y,
+                                    int w,
+                                    int h,
+                                    int native_w,
+                                    int native_h) {
+}
+
+void NativeViewHostAndroid::HideWidget() {
+}
+
+void NativeViewHostAndroid::SetFocus() {
+}
+
+gfx::NativeView NativeViewHostAndroid::GetNativeViewContainer() const {
+  return gfx::NativeView();
+}
+
+gfx::NativeViewAccessible NativeViewHostAndroid::GetNativeViewAccessible() {
+  return nullptr;
+}
+
+gfx::NativeCursor NativeViewHostAndroid::GetCursor(int x, int y) {
+  return gfx::kNullCursor;
+}
+
+void NativeViewHostAndroid::SetVisible(bool visible) {
+}
+
+// static
+NativeViewHostWrapper* NativeViewHostWrapper::CreateWrapper(
+    NativeViewHost* host) {
+  return new NativeViewHostAndroid(host);
+}
+
+void NativeViewHostAndroid::CreateClippingWindow() {
+}
+
+void NativeViewHostAndroid::AddClippingWindow() {
+}
+
+void NativeViewHostAndroid::RemoveClippingWindow() {
+}
+
+void NativeViewHostAndroid::InstallMask() {
+}
+
+void NativeViewHostAndroid::UninstallMask() {
+}
+
+void NativeViewHostAndroid::UpdateInsets() {
+}
+
+}  // namespace views
diff --git a/ui/views/controls/native/native_view_host_android.h b/ui/views/controls/native/native_view_host_android.h
new file mode 100644
index 000000000000..9434ddcf27f9
--- /dev/null
+++ b/ui/views/controls/native/native_view_host_android.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+#define UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "ui/compositor/layer_owner.h"
+#include "ui/gfx/transform.h"
+#include "ui/views/controls/native/native_view_host_wrapper.h"
+#include "ui/views/views_export.h"
+
+namespace views {
+
+class NativeViewHost;
+
+// Android implementation of NativeViewHostWrapper.
+class NativeViewHostAndroid : public NativeViewHostWrapper {
+
+ public:
+  explicit NativeViewHostAndroid(NativeViewHost* host);
+  ~NativeViewHostAndroid() override;
+
+  // Overridden from NativeViewHostWrapper:
+  void AttachNativeView() override;
+  void NativeViewDetaching(bool destroyed) override;
+  void AddedToWidget() override;
+  void RemovedFromWidget() override;
+  bool SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) override;
+  void SetHitTestTopInset(int top_inset) override;
+  int GetHitTestTopInset() const override;
+  void InstallClip(int x, int y, int w, int h) override;
+  bool HasInstalledClip() override;
+  void UninstallClip() override;
+  void ShowWidget(int x, int y, int w, int h, int native_w, int native_h)
+      override;
+  void HideWidget() override;
+  void SetFocus() override;
+  gfx::NativeView GetNativeViewContainer() const override;
+  gfx::NativeViewAccessible GetNativeViewAccessible() override;
+  gfx::NativeCursor GetCursor(int x, int y) override;
+  void SetVisible(bool visible) override;
+  void SetParentAccessible(gfx::NativeViewAccessible) override;
+
+ private:
+  friend class NativeViewHostAndroidTest;
+
+  void CreateClippingWindow();
+
+  // Reparents the native view with the clipping window existing between it and
+  // its old parent, so that the fast resize path works.
+  void AddClippingWindow();
+
+  // If the native view has been reparented via AddClippingWindow, this call
+  // undoes it.
+  void RemoveClippingWindow();
+
+  // Sets or updates the mask layer on the native view's layer.
+  void InstallMask();
+
+  // Unsets the mask layer on the native view's layer.
+  void UninstallMask();
+
+  // Updates the top insets of |clipping_window_|.
+  void UpdateInsets();
+
+  // Our associated NativeViewHost.
+  NativeViewHost* host_;
+
+  // Window that exists between the native view and the parent that allows for
+  // clipping to occur. This is positioned in the coordinate space of
+  // host_->GetWidget().
+  std::unique_ptr<gfx::Rect> clip_rect_;
+
+  // This mask exists for the sake of SetCornerRadius().
+  std::unique_ptr<ui::LayerOwner> mask_;
+
+  // Set when AttachNativeView() is called. This is the original transform of
+  // the NativeView's layer. The NativeView's layer may be modified to scale
+  // when ShowWidget() is called with a native view size not equal to the
+  // region's size. When NativeViewDetaching() is called, the NativeView's
+  // transform is restored to this.
+  gfx::Transform original_transform_;
+
+  // True if a transform different from the original was set.
+  bool original_transform_changed_ = false;
+
+  // The top insets to exclude the underlying native view from the target.
+  int top_inset_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeViewHostAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
diff --git a/ui/views/controls/webview/unhandled_keyboard_event_handler.cc b/ui/views/controls/webview/unhandled_keyboard_event_handler.cc
index 85a1cc6e07ad..473248f1ec24 100644
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler.cc
@@ -50,9 +50,6 @@ bool UnhandledKeyboardEventHandler::HandleKeyboardEvent(
     ignore_next_char_event_ = false;
   }
 
-  if (event.os_event && !event.skip_in_browser)
-    return HandleNativeKeyboardEvent(event.os_event, focus_manager);
-
   return false;
 }
 
diff --git a/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc b/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
index f6cb4a38d17a..9e9ca028ec45 100644
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
@@ -13,7 +13,7 @@ namespace views {
 bool UnhandledKeyboardEventHandler::HandleNativeKeyboardEvent(
     gfx::NativeEvent event,
     FocusManager* focus_manager) {
-  return !focus_manager->OnKeyEvent(*(event->AsKeyEvent()));
+  return false;
 }
 
 }  // namespace views
diff --git a/ui/views/controls/webview/web_dialog_view.cc b/ui/views/controls/webview/web_dialog_view.cc
index ed1c7a5a0456..d9881f9137c5 100644
--- a/ui/views/controls/webview/web_dialog_view.cc
+++ b/ui/views/controls/webview/web_dialog_view.cc
@@ -351,11 +351,7 @@ void WebDialogView::SetContentsBounds(WebContents* source,
 // they're all browser-specific. (This may change in the future.)
 bool WebDialogView::HandleKeyboardEvent(content::WebContents* source,
                                         const NativeWebKeyboardEvent& event) {
-  if (!event.os_event)
-    return false;
-
-  return unhandled_keyboard_event_handler_.HandleKeyboardEvent(
-      event, GetFocusManager());
+  return false;
 }
 
 void WebDialogView::CloseContents(WebContents* source) {
diff --git a/ui/views/event_monitor_android.cc b/ui/views/event_monitor_android.cc
new file mode 100644
index 000000000000..c7cad8b7ea37
--- /dev/null
+++ b/ui/views/event_monitor_android.cc
@@ -0,0 +1,65 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/event_monitor_android.h"
+
+#include <memory>
+
+#include "base/logging.h"
+#include "base/scoped_observer.h"
+#include "ui/events/event_observer.h"
+#include "ui/events/event_target.h"
+
+namespace views {
+
+EventMonitorAndroid::EventMonitorAndroid(ui::EventObserver* event_observer,
+                                   ui::EventTarget* event_target,
+                                   const std::set<ui::EventType>& types) {
+}
+
+EventMonitorAndroid::~EventMonitorAndroid() {
+}
+
+namespace {
+
+// An EventMonitorAndroid that removes its event observer on window destruction.
+class WindowMonitorAndroid : public EventMonitorAndroid {
+ public:
+  WindowMonitorAndroid(ui::EventObserver* event_observer,
+                    ui::EventTarget* target_window,
+                    const std::set<ui::EventType>& types)
+      : EventMonitorAndroid(event_observer, target_window, types) {
+  }
+  ~WindowMonitorAndroid() override = default;
+
+ private:
+
+  DISALLOW_COPY_AND_ASSIGN(WindowMonitorAndroid);
+};
+
+}  // namespace
+
+// static
+std::unique_ptr<EventMonitor> EventMonitor::CreateApplicationMonitor(
+    ui::EventObserver* event_observer,
+    gfx::NativeWindow context,
+    const std::set<ui::EventType>& types) {
+  return std::make_unique<EventMonitorAndroid>(event_observer,
+                                            nullptr, types);
+}
+
+// static
+std::unique_ptr<EventMonitor> EventMonitor::CreateWindowMonitor(
+    ui::EventObserver* event_observer,
+    gfx::NativeWindow target_window,
+    const std::set<ui::EventType>& types) {
+  return std::make_unique<WindowMonitorAndroid>(event_observer, nullptr,
+                                             types);
+}
+
+gfx::Point EventMonitorAndroid::GetLastMouseLocation() {
+  return gfx::Point();
+}
+
+}  // namespace views
diff --git a/ui/views/event_monitor_android.h b/ui/views/event_monitor_android.h
new file mode 100644
index 000000000000..0437aff5003b
--- /dev/null
+++ b/ui/views/event_monitor_android.h
@@ -0,0 +1,37 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+#define UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+
+#include "base/macros.h"
+#include "ui/views/event_monitor.h"
+
+namespace ui {
+class EventTarget;
+}
+
+namespace views {
+
+// Observes events by installing a pre-target handler on the ui::EventTarget.
+class EventMonitorAndroid : public EventMonitor {
+ public:
+  EventMonitorAndroid(ui::EventObserver* event_observer,
+                   ui::EventTarget* event_target,
+                   const std::set<ui::EventType>& types);
+  ~EventMonitorAndroid() override;
+
+  // EventMonitor:
+  gfx::Point GetLastMouseLocation() override;
+
+ protected:
+
+ private:
+
+  DISALLOW_COPY_AND_ASSIGN(EventMonitorAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_EVENT_MONITOR_Android_H_
diff --git a/ui/views/metrics_android.cc b/ui/views/metrics_android.cc
new file mode 100644
index 000000000000..cf576ebb0d95
--- /dev/null
+++ b/ui/views/metrics_android.cc
@@ -0,0 +1,36 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "build/build_config.h"
+#include "ui/views/metrics.h"
+
+#if defined(OS_WIN)
+#include <windows.h>
+#endif
+
+namespace views {
+
+int GetDoubleClickInterval() {
+#if defined(OS_WIN)
+  return ::GetDoubleClickTime();
+#else
+  // TODO(jennyz): This value may need to be adjusted on different platforms.
+  const int kDefaultDoubleClickIntervalMs = 500;
+  return kDefaultDoubleClickIntervalMs;
+#endif
+}
+
+int GetMenuShowDelay() {
+#if defined(OS_WIN)
+  static DWORD delay = 0;
+  if (!delay && !SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &delay, 0))
+    delay = kDefaultMenuShowDelay;
+  return delay;
+#else
+  return 0;
+#endif
+}
+
+}  // namespace views
+
diff --git a/ui/views/native_cursor_android.cc b/ui/views/native_cursor_android.cc
new file mode 100644
index 000000000000..0b6ad4b6dd41
--- /dev/null
+++ b/ui/views/native_cursor_android.cc
@@ -0,0 +1,31 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/native_cursor.h"
+
+#include "ui/base/cursor/cursor.h"
+
+namespace views {
+
+gfx::NativeCursor GetNativeIBeamCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeHandCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeColumnResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeEastWestResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeNorthSouthResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+}  // namespace views
diff --git a/ui/views/view.cc b/ui/views/view.cc
index 9b7245cc9c15..566884ccddae 100644
--- a/ui/views/view.cc
+++ b/ui/views/view.cc
@@ -2307,6 +2307,7 @@ void View::PropagateRemoveNotifications(View* old_parent,
 
 void View::PropagateAddNotifications(const ViewHierarchyChangedDetails& details,
                                      bool is_added_to_widget) {
+#if 0
   {
     internal::ScopedChildrenLock lock(this);
     for (auto* child : children_)
@@ -2318,6 +2319,7 @@ void View::PropagateAddNotifications(const ViewHierarchyChangedDetails& details,
     for (ViewObserver& observer : observers_)
       observer.OnViewAddedToWidget(this);
   }
+#endif
 }
 
 void View::PropagateNativeViewHierarchyChanged() {
diff --git a/ui/views/views_delegate.cc b/ui/views/views_delegate.cc
index 049fc51f6aa5..d3636320a881 100644
--- a/ui/views/views_delegate.cc
+++ b/ui/views/views_delegate.cc
@@ -24,7 +24,8 @@ ViewsDelegate* views_delegate = nullptr;
 }  // namespace
 
 ViewsDelegate::ViewsDelegate()
-    : editing_controller_factory_(new ViewsTouchEditingControllerFactory) {
+    : editing_controller_factory_(nullptr) {
+//    : editing_controller_factory_(new ViewsTouchEditingControllerFactory) {
   DCHECK(!views_delegate);
   views_delegate = this;
 
diff --git a/ui/views/views_touch_selection_controller_factory_android.cc b/ui/views/views_touch_selection_controller_factory_android.cc
new file mode 100644
index 000000000000..53eb2ede6247
--- /dev/null
+++ b/ui/views/views_touch_selection_controller_factory_android.cc
@@ -0,0 +1,22 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/views_touch_selection_controller_factory.h"
+
+#include "ui/base/ui_base_switches_util.h"
+#include "ui/views/touchui/touch_selection_controller_impl.h"
+
+namespace views {
+
+ViewsTouchEditingControllerFactory::ViewsTouchEditingControllerFactory() {
+}
+
+ui::TouchEditingControllerDeprecated*
+ViewsTouchEditingControllerFactory::Create(
+    ui::TouchEditable* client_view) {
+  return nullptr;
+}
+
+}  // namespace views
+
diff --git a/ui/views/views_touch_selection_controller_factory_aura.cc b/ui/views/views_touch_selection_controller_factory_aura.cc
index 8010719703f6..fb93a372660f 100644
--- a/ui/views/views_touch_selection_controller_factory_aura.cc
+++ b/ui/views/views_touch_selection_controller_factory_aura.cc
@@ -15,7 +15,7 @@ ViewsTouchEditingControllerFactory::ViewsTouchEditingControllerFactory() =
 ui::TouchEditingControllerDeprecated*
 ViewsTouchEditingControllerFactory::Create(
     ui::TouchEditable* client_view) {
-  return new views::TouchSelectionControllerImpl(client_view);
+  return nullptr;
 }
 
 }  // namespace views
diff --git a/ui/views/widget/native_widget_android.cc b/ui/views/widget/native_widget_android.cc
new file mode 100644
index 000000000000..e7dfce7250ab
--- /dev/null
+++ b/ui/views/widget/native_widget_android.cc
@@ -0,0 +1,491 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/native_widget_android.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/location.h"
+#include "base/single_thread_task_runner.h"
+#include "base/strings/string_util.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "build/build_config.h"
+#include "ui/base/class_property.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/ui_base_types.h"
+#include "ui/compositor/layer.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/events/event.h"
+#include "ui/gfx/canvas.h"
+#include "ui/native_theme/native_theme_android.h"
+#include "ui/views/drag_utils.h"
+#include "ui/views/views_delegate.h"
+#include "ui/views/widget/drop_helper.h"
+#include "ui/views/widget/focus_manager_event_handler.h"
+#include "ui/views/widget/native_widget_delegate.h"
+#include "ui/views/widget/root_view.h"
+#include "ui/views/widget/tooltip_manager_aura.h"
+#include "ui/views/widget/widget_aura_utils.h"
+#include "ui/views/widget/widget_delegate.h"
+#include "ui/views/widget/window_reorderer.h"
+#include "ui/wm/core/coordinate_conversion.h"
+#include "ui/wm/core/shadow_types.h"
+#include "ui/wm/core/transient_window_manager.h"
+#include "ui/wm/core/window_animations.h"
+#include "ui/wm/core/window_properties.h"
+#include "ui/wm/core/window_util.h"
+#include "ui/wm/public/activation_client.h"
+#include "ui/wm/public/window_move_client.h"
+
+#if defined(OS_WIN)
+#include "base/win/scoped_gdi_object.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
+#endif
+
+#if defined(USE_X11)
+#include "ui/views/linux_ui/linux_ui.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_x11.h"
+#endif
+
+#if !defined(OS_CHROMEOS)
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
+#endif
+
+DEFINE_UI_CLASS_PROPERTY_TYPE(views::internal::NativeWidgetPrivate*)
+
+namespace views {
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, public:
+
+NativeWidgetAndroid::NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate)
+    : delegate_(delegate),
+      ownership_(Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET),
+      destroying_(false) {
+}
+
+// static
+void NativeWidgetAndroid::RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window) {
+}
+
+// static
+void NativeWidgetAndroid::AssignIconToAuraWindow(gfx::NativeWindow window,
+                                              const gfx::ImageSkia& window_icon,
+                                              const gfx::ImageSkia& app_icon) {
+}
+
+// static
+void NativeWidgetAndroid::SetShadowElevationFromInitParams(
+    gfx::NativeWindow window,
+    const Widget::InitParams& params) {
+}
+
+// static
+void NativeWidgetAndroid::SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                                     gfx::NativeWindow window) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, internal::NativeWidgetPrivate implementation:
+
+void NativeWidgetAndroid::InitNativeWidget(Widget::InitParams params) {
+  delegate_->OnNativeWidgetCreated();
+}
+
+void NativeWidgetAndroid::OnWidgetInitDone() {}
+
+NonClientFrameView* NativeWidgetAndroid::CreateNonClientFrameView() {
+  return nullptr;
+}
+
+bool NativeWidgetAndroid::ShouldUseNativeFrame() const {
+  // There is only one frame type for aura.
+  return false;
+}
+
+bool NativeWidgetAndroid::ShouldWindowContentsBeTransparent() const {
+  return false;
+}
+
+void NativeWidgetAndroid::FrameTypeChanged() {
+  // This is called when the Theme has changed; forward the event to the root
+  // widget.
+  GetWidget()->ThemeChanged();
+  GetWidget()->GetRootView()->SchedulePaint();
+}
+
+Widget* NativeWidgetAndroid::GetWidget() {
+  return delegate_->AsWidget();
+}
+
+const Widget* NativeWidgetAndroid::GetWidget() const {
+  return delegate_->AsWidget();
+}
+
+gfx::NativeView NativeWidgetAndroid::GetNativeView() const {
+  return window_;
+}
+
+gfx::NativeWindow NativeWidgetAndroid::GetNativeWindow() const {
+  return window_;
+}
+
+Widget* NativeWidgetAndroid::GetTopLevelWidget() {
+  NativeWidgetPrivate* native_widget = GetTopLevelNativeWidget(GetNativeView());
+  return native_widget ? native_widget->GetWidget() : nullptr;
+}
+
+const ui::Compositor* NativeWidgetAndroid::GetCompositor() const {
+  return nullptr;
+}
+
+const ui::Layer* NativeWidgetAndroid::GetLayer() const {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::ReorderNativeViews() {
+}
+
+void NativeWidgetAndroid::ViewRemoved(View* view) {
+  DCHECK(drop_helper_.get() != nullptr);
+  drop_helper_->ResetTargetViewIfEquals(view);
+}
+
+void NativeWidgetAndroid::SetNativeWindowProperty(const char* name, void* value) {
+}
+
+void* NativeWidgetAndroid::GetNativeWindowProperty(const char* name) const {
+  return nullptr;
+}
+
+TooltipManager* NativeWidgetAndroid::GetTooltipManager() const {
+  return tooltip_manager_.get();
+}
+
+void NativeWidgetAndroid::SetCapture() {
+}
+
+void NativeWidgetAndroid::ReleaseCapture() {
+}
+
+bool NativeWidgetAndroid::HasCapture() const {
+  return false;
+}
+
+ui::InputMethod* NativeWidgetAndroid::GetInputMethod() {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::CenterWindow(const gfx::Size& size) {
+}
+
+void NativeWidgetAndroid::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+}
+
+bool NativeWidgetAndroid::SetWindowTitle(const base::string16& title) {
+  return true;
+}
+
+void NativeWidgetAndroid::SetWindowIcons(const gfx::ImageSkia& window_icon,
+                                      const gfx::ImageSkia& app_icon) {
+}
+
+void NativeWidgetAndroid::InitModalType(ui::ModalType modal_type) {
+}
+
+gfx::Rect NativeWidgetAndroid::GetWindowBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+gfx::Rect NativeWidgetAndroid::GetClientAreaBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+gfx::Rect NativeWidgetAndroid::GetRestoredBounds() const {
+  return gfx::Rect();
+}
+
+std::string NativeWidgetAndroid::GetWorkspace() const {
+  return std::string();
+}
+
+void NativeWidgetAndroid::SetBounds(const gfx::Rect& bounds) {
+}
+
+void NativeWidgetAndroid::SetBoundsConstrained(const gfx::Rect& bounds) {
+}
+
+void NativeWidgetAndroid::SetSize(const gfx::Size& size) {
+}
+
+void NativeWidgetAndroid::StackAbove(gfx::NativeView native_view) {
+}
+
+void NativeWidgetAndroid::StackAtTop() {
+}
+
+void NativeWidgetAndroid::SetShape(std::unique_ptr<Widget::ShapeRects> shape) {
+}
+
+void NativeWidgetAndroid::Close() {
+}
+
+void NativeWidgetAndroid::CloseNow() {
+}
+
+void NativeWidgetAndroid::Show(ui::WindowShowState show_state,
+                            const gfx::Rect& restore_bounds) {
+}
+
+void NativeWidgetAndroid::Hide() {
+}
+
+bool NativeWidgetAndroid::IsVisible() const {
+  return true;
+}
+
+void NativeWidgetAndroid::Activate() {
+}
+
+void NativeWidgetAndroid::Deactivate() {
+}
+
+bool NativeWidgetAndroid::IsActive() const {
+  return true;
+}
+
+void NativeWidgetAndroid::SetZOrderLevel(ui::ZOrderLevel order) {
+}
+
+ui::ZOrderLevel NativeWidgetAndroid::GetZOrderLevel() const {
+  return ui::ZOrderLevel::kNormal;
+}
+
+void NativeWidgetAndroid::SetVisibleOnAllWorkspaces(bool always_visible) {
+  // Not implemented on chromeos or for child widgets.
+}
+
+bool NativeWidgetAndroid::IsVisibleOnAllWorkspaces() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Maximize() {
+}
+
+void NativeWidgetAndroid::Minimize() {
+}
+
+bool NativeWidgetAndroid::IsMaximized() const {
+  return true;
+}
+
+bool NativeWidgetAndroid::IsMinimized() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Restore() {
+}
+
+void NativeWidgetAndroid::SetFullscreen(bool fullscreen) {
+}
+
+bool NativeWidgetAndroid::IsFullscreen() const {
+  return false;
+}
+
+void NativeWidgetAndroid::SetCanAppearInExistingFullscreenSpaces(
+    bool can_appear_in_existing_fullscreen_spaces) {}
+
+void NativeWidgetAndroid::SetOpacity(float opacity) {
+}
+
+void NativeWidgetAndroid::SetAspectRatio(const gfx::SizeF& aspect_ratio) {
+}
+
+void NativeWidgetAndroid::FlashFrame(bool flash) {
+}
+
+void NativeWidgetAndroid::RunShellDrag(View* view,
+                                    std::unique_ptr<ui::OSExchangeData> data,
+                                    const gfx::Point& location,
+                                    int operation,
+                                    ui::DragDropTypes::DragEventSource source) {
+}
+
+void NativeWidgetAndroid::SchedulePaintInRect(const gfx::Rect& rect) {
+}
+
+void NativeWidgetAndroid::ScheduleLayout() {
+}
+
+void NativeWidgetAndroid::SetCursor(gfx::NativeCursor cursor) {
+}
+
+bool NativeWidgetAndroid::IsMouseEventsEnabled() const {
+  return true;
+}
+
+bool NativeWidgetAndroid::IsMouseButtonDown() const {
+  return false;
+}
+
+void NativeWidgetAndroid::ClearNativeFocus() {
+}
+
+gfx::Rect NativeWidgetAndroid::GetWorkAreaBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+Widget::MoveLoopResult NativeWidgetAndroid::RunMoveLoop(
+    const gfx::Vector2d& drag_offset,
+    Widget::MoveLoopSource source,
+    Widget::MoveLoopEscapeBehavior escape_behavior) {
+  return Widget::MOVE_LOOP_CANCELED;
+}
+
+void NativeWidgetAndroid::EndMoveLoop() {
+}
+
+void NativeWidgetAndroid::SetVisibilityChangedAnimationsEnabled(bool value) {
+}
+
+void NativeWidgetAndroid::SetVisibilityAnimationDuration(
+    const base::TimeDelta& duration) {
+}
+
+void NativeWidgetAndroid::SetVisibilityAnimationTransition(
+    Widget::VisibilityTransition transition) {
+}
+
+bool NativeWidgetAndroid::IsTranslucentWindowOpacitySupported() const {
+  return true;
+}
+
+ui::GestureRecognizer* NativeWidgetAndroid::GetGestureRecognizer() {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::OnSizeConstraintsChanged() {
+}
+
+std::string NativeWidgetAndroid::GetName() const {
+  return std::string();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, protected:
+
+NativeWidgetAndroid::~NativeWidgetAndroid() {
+  destroying_ = true;
+  if (ownership_ == Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET)
+    delete delegate_;
+  else
+    CloseNow();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, private:
+
+void NativeWidgetAndroid::SetInitialFocus(ui::WindowShowState show_state) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Widget, public:
+
+namespace {
+#if defined(OS_WIN) || defined(USE_X11)
+void CloseWindow(gfx::NativeWindow window) {
+  if (window) {
+    Widget* widget = Widget::GetWidgetForNativeView(window);
+    if (widget && widget->is_secondary_widget())
+      // To avoid the delay in shutdown caused by using Close which may wait
+      // for animations, use CloseNow. Because this is only used on secondary
+      // widgets it seems relatively safe to skip the extra processing of
+      // Close.
+      widget->CloseNow();
+  }
+}
+#endif
+
+#if defined(OS_WIN)
+BOOL CALLBACK WindowCallbackProc(HWND hwnd, LPARAM lParam) {
+  gfx::NativeWindow root_window =
+      DesktopWindowTreeHostWin::GetContentWindowForHWND(hwnd);
+  CloseWindow(root_window);
+  return TRUE;
+}
+#endif
+}  // namespace
+
+// static
+void Widget::CloseAllSecondaryWidgets() {
+#if defined(OS_WIN)
+  EnumThreadWindows(GetCurrentThreadId(), WindowCallbackProc, 0);
+#endif
+
+#if defined(USE_X11)
+  DesktopWindowTreeHostX11::CleanUpWindowList(CloseWindow);
+#endif
+}
+
+namespace internal {
+
+////////////////////////////////////////////////////////////////////////////////
+// internal::NativeWidgetPrivate, public:
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::CreateNativeWidget(
+    internal::NativeWidgetDelegate* delegate) {
+  return new NativeWidgetAndroid(delegate);
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeView(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeWindow(
+    gfx::NativeWindow native_window) {
+  return nullptr;
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetTopLevelNativeWidget(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+// static
+void NativeWidgetPrivate::GetAllChildWidgets(gfx::NativeView native_view,
+                                             Widget::Widgets* children) {
+}
+
+// static
+void NativeWidgetPrivate::GetAllOwnedWidgets(gfx::NativeView native_view,
+                                             Widget::Widgets* owned) {
+}
+
+// static
+void NativeWidgetPrivate::ReparentNativeView(gfx::NativeView native_view,
+                                             gfx::NativeView new_parent) {
+}
+
+// static
+gfx::NativeView NativeWidgetPrivate::GetGlobalCapture(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+}  // namespace internal
+}  // namespace views
diff --git a/ui/views/widget/native_widget_android.h b/ui/views/widget/native_widget_android.h
new file mode 100644
index 000000000000..de83c381d51a
--- /dev/null
+++ b/ui/views/widget/native_widget_android.h
@@ -0,0 +1,192 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+#define UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "build/build_config.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/events/event_constants.h"
+#include "ui/views/views_export.h"
+#include "ui/views/widget/native_widget_private.h"
+#include "ui/wm/public/activation_change_observer.h"
+#include "ui/wm/public/activation_delegate.h"
+
+#if defined(OS_MACOSX)
+#error This file must not be included on macOS; Chromium Mac doesn't use Aura.
+#endif
+
+namespace aura {
+class Window;
+}
+
+namespace views {
+
+class DropHelper;
+class FocusManagerEventHandler;
+class TooltipManagerAura;
+class WindowReorderer;
+
+class VIEWS_EXPORT NativeWidgetAndroid : public internal::NativeWidgetPrivate {
+ public:
+  explicit NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate);
+
+  // Called internally by NativeWidgetAndroid and DesktopNativeWidgetAndroid to
+  // associate |native_widget| with |window|.
+  static void RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window);
+
+  // Assign an icon to aura window.
+  static void AssignIconToAuraWindow(gfx::NativeWindow window,
+                                     const gfx::ImageSkia& window_icon,
+                                     const gfx::ImageSkia& app_icon);
+
+  // If necessary, sets the ShadowElevation of |window| from |params|.
+  static void SetShadowElevationFromInitParams(
+      gfx::NativeWindow window,
+      const Widget::InitParams& params);
+
+  // Sets the window property aura::client::kResizeBehaviorKey based on the
+  // values from the delegate.
+  static void SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                            gfx::NativeWindow window);
+
+  // Overridden from internal::NativeWidgetPrivate:
+  void InitNativeWidget(Widget::InitParams params) override;
+  void OnWidgetInitDone() override;
+  NonClientFrameView* CreateNonClientFrameView() override;
+  bool ShouldUseNativeFrame() const override;
+  bool ShouldWindowContentsBeTransparent() const override;
+  void FrameTypeChanged() override;
+  Widget* GetWidget() override;
+  const Widget* GetWidget() const override;
+  gfx::NativeView GetNativeView() const override;
+  gfx::NativeWindow GetNativeWindow() const override;
+  Widget* GetTopLevelWidget() override;
+  const ui::Compositor* GetCompositor() const override;
+  const ui::Layer* GetLayer() const override;
+  void ReorderNativeViews() override;
+  void ViewRemoved(View* view) override;
+  void SetNativeWindowProperty(const char* name, void* value) override;
+  void* GetNativeWindowProperty(const char* name) const override;
+  TooltipManager* GetTooltipManager() const override;
+  void SetCapture() override;
+  void ReleaseCapture() override;
+  bool HasCapture() const override;
+  ui::InputMethod* GetInputMethod() override;
+  void CenterWindow(const gfx::Size& size) override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* maximized) const override;
+  bool SetWindowTitle(const base::string16& title) override;
+  void SetWindowIcons(const gfx::ImageSkia& window_icon,
+                      const gfx::ImageSkia& app_icon) override;
+  void InitModalType(ui::ModalType modal_type) override;
+  gfx::Rect GetWindowBoundsInScreen() const override;
+  gfx::Rect GetClientAreaBoundsInScreen() const override;
+  gfx::Rect GetRestoredBounds() const override;
+  std::string GetWorkspace() const override;
+  void SetBounds(const gfx::Rect& bounds) override;
+  void SetBoundsConstrained(const gfx::Rect& bounds) override;
+  void SetSize(const gfx::Size& size) override;
+  void StackAbove(gfx::NativeView native_view) override;
+  void StackAtTop() override;
+  void SetShape(std::unique_ptr<Widget::ShapeRects> shape) override;
+  void Close() override;
+  void CloseNow() override;
+  void Show(ui::WindowShowState show_state,
+            const gfx::Rect& restore_bounds) override;
+  void Hide() override;
+  bool IsVisible() const override;
+  void Activate() override;
+  void Deactivate() override;
+  bool IsActive() const override;
+  void SetZOrderLevel(ui::ZOrderLevel order) override;
+  ui::ZOrderLevel GetZOrderLevel() const override;
+  void SetVisibleOnAllWorkspaces(bool always_visible) override;
+  bool IsVisibleOnAllWorkspaces() const override;
+  void Maximize() override;
+  void Minimize() override;
+  bool IsMaximized() const override;
+  bool IsMinimized() const override;
+  void Restore() override;
+  void SetFullscreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetCanAppearInExistingFullscreenSpaces(
+      bool can_appear_in_existing_fullscreen_spaces) override;
+  void SetOpacity(float opacity) override;
+  void SetAspectRatio(const gfx::SizeF& aspect_ratio) override;
+  void FlashFrame(bool flash_frame) override;
+  void RunShellDrag(View* view,
+                    std::unique_ptr<ui::OSExchangeData> data,
+                    const gfx::Point& location,
+                    int operation,
+                    ui::DragDropTypes::DragEventSource source) override;
+  void SchedulePaintInRect(const gfx::Rect& rect) override;
+  void ScheduleLayout() override;
+  void SetCursor(gfx::NativeCursor cursor) override;
+  bool IsMouseEventsEnabled() const override;
+  bool IsMouseButtonDown() const override;
+  void ClearNativeFocus() override;
+  gfx::Rect GetWorkAreaBoundsInScreen() const override;
+  Widget::MoveLoopResult RunMoveLoop(
+      const gfx::Vector2d& drag_offset,
+      Widget::MoveLoopSource source,
+      Widget::MoveLoopEscapeBehavior escape_behavior) override;
+  void EndMoveLoop() override;
+  void SetVisibilityChangedAnimationsEnabled(bool value) override;
+  void SetVisibilityAnimationDuration(const base::TimeDelta& duration) override;
+  void SetVisibilityAnimationTransition(
+      Widget::VisibilityTransition transition) override;
+  bool IsTranslucentWindowOpacitySupported() const override;
+  ui::GestureRecognizer* GetGestureRecognizer() override;
+  void OnSizeConstraintsChanged() override;
+  std::string GetName() const override;
+
+ protected:
+  ~NativeWidgetAndroid() override;
+
+  internal::NativeWidgetDelegate* delegate() { return delegate_; }
+
+ private:
+  void SetInitialFocus(ui::WindowShowState show_state);
+
+  internal::NativeWidgetDelegate* delegate_;
+
+  // WARNING: set to NULL when destroyed. As the Widget is not necessarily
+  // destroyed along with |window_| all usage of |window_| should first verify
+  // non-NULL.
+  gfx::NativeWindow window_;
+
+  // See class documentation for Widget in widget.h for a note about ownership.
+  Widget::InitParams::Ownership ownership_;
+
+  // Are we in the destructor?
+  bool destroying_;
+
+  std::unique_ptr<TooltipManagerAura> tooltip_manager_;
+
+  // Reorders child windows of |window_| associated with a view based on the
+  // order of the associated views in the widget's view hierarchy.
+  std::unique_ptr<WindowReorderer> window_reorderer_;
+
+  std::unique_ptr<DropHelper> drop_helper_;
+
+  // Native widget's handler to receive events before the event target.
+  std::unique_ptr<FocusManagerEventHandler> focus_manager_event_handler_;
+
+  // The following factory is used for calls to close the NativeWidgetAndroid
+  // instance.
+  base::WeakPtrFactory<NativeWidgetAndroid> close_widget_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWidgetAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WIDGET_NATIVE_WIDGET_AURA_H_
diff --git a/ui/views/widget/widget.cc b/ui/views/widget/widget.cc
index af72459e1589..433649756050 100644
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -33,6 +33,7 @@
 #include "ui/views/focus/widget_focus_manager.h"
 #include "ui/views/views_delegate.h"
 #include "ui/views/widget/native_widget_private.h"
+#include "ui/native_theme/native_theme_android.h"
 #include "ui/views/widget/root_view.h"
 #include "ui/views/widget/tooltip_manager.h"
 #include "ui/views/widget/widget_delegate.h"
@@ -175,6 +176,10 @@ ui::ZOrderLevel Widget::InitParams::EffectiveZOrderLevel() const {
 ////////////////////////////////////////////////////////////////////////////////
 // Widget, public:
 
+const ui::NativeTheme* Widget::GetNativeTheme() const {
+  return ui::NativeThemeAndroid::instance();
+}
+
 Widget::Widget() = default;
 
 Widget::~Widget() {
@@ -229,42 +234,35 @@ Widget* Widget::CreateWindowWithContextAndBounds(WidgetDelegate* delegate,
 
 // static
 Widget* Widget::GetWidgetForNativeView(gfx::NativeView native_view) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetNativeWidgetForNativeView(native_view);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 Widget* Widget::GetWidgetForNativeWindow(gfx::NativeWindow native_window) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetNativeWidgetForNativeWindow(
-          native_window);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 Widget* Widget::GetTopLevelWidgetForNativeView(gfx::NativeView native_view) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetTopLevelNativeWidget(native_view);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 void Widget::GetAllChildWidgets(gfx::NativeView native_view,
                                 Widgets* children) {
-  internal::NativeWidgetPrivate::GetAllChildWidgets(native_view, children);
+  return ;
 }
 
 // static
 void Widget::GetAllOwnedWidgets(gfx::NativeView native_view,
                                 Widgets* owned) {
-  internal::NativeWidgetPrivate::GetAllOwnedWidgets(native_view, owned);
+  return ;
 }
 
 // static
 void Widget::ReparentNativeView(gfx::NativeView native_view,
                                 gfx::NativeView new_parent) {
-  internal::NativeWidgetPrivate::ReparentNativeView(native_view, new_parent);
+  return ;
 }
 
 // static
@@ -344,13 +342,16 @@ void Widget::Init(InitParams params) {
   root_view_.reset(CreateRootView());
   default_theme_provider_ = std::make_unique<ui::DefaultThemeProvider>();
 
+#if 0
   // Copy the elements of params that will be used after it is moved.
   const InitParams::Type type = params.type;
   const gfx::Rect bounds = params.bounds;
   const ui::WindowShowState show_state = params.show_state;
+#endif
   WidgetDelegate* delegate = params.delegate;
 
   native_widget_->InitNativeWidget(std::move(params));
+#if 0
   if (type == InitParams::TYPE_MENU)
     is_mouse_button_pressed_ = native_widget_->IsMouseButtonDown();
   if (RequiresNonClientView(type)) {
@@ -396,6 +397,7 @@ void Widget::Init(InitParams params) {
     observer_manager_.Add(native_theme);
 #else
   observer_manager_.Add(GetNativeTheme());
+#endif
 #endif
   native_widget_initialized_ = true;
   native_widget_->OnWidgetInitDone();
@@ -1255,91 +1257,6 @@ void Widget::OnKeyEvent(ui::KeyEvent* event) {
 //                   RootView from anywhere in Widget. Use
 //                   SendEventToSink() instead. See crbug.com/348087.
 void Widget::OnMouseEvent(ui::MouseEvent* event) {
-  View* root_view = GetRootView();
-  switch (event->type()) {
-    case ui::ET_MOUSE_PRESSED: {
-      last_mouse_event_was_move_ = false;
-
-      // We may get deleted by the time we return from OnMousePressed. So we
-      // use an observer to make sure we are still alive.
-      WidgetDeletionObserver widget_deletion_observer(this);
-
-      gfx::NativeView current_capture =
-          internal::NativeWidgetPrivate::GetGlobalCapture(
-              native_widget_->GetNativeView());
-      // Make sure we're still visible before we attempt capture as the mouse
-      // press processing may have made the window hide (as happens with menus).
-      //
-      // It is possible that capture has changed as a result of a mouse-press.
-      // In these cases do not update internal state.
-      //
-      // A mouse-press may trigger a nested message-loop, and absorb the paired
-      // release. If so the code returns here. So make sure that that
-      // mouse-button is still down before attempting to do a capture.
-      if (root_view && root_view->OnMousePressed(*event) &&
-          widget_deletion_observer.IsWidgetAlive() && IsVisible() &&
-          native_widget_->IsMouseButtonDown() &&
-          current_capture == internal::NativeWidgetPrivate::GetGlobalCapture(
-                                 native_widget_->GetNativeView())) {
-        is_mouse_button_pressed_ = true;
-        if (!native_widget_->HasCapture())
-          native_widget_->SetCapture();
-        event->SetHandled();
-      }
-      return;
-    }
-
-    case ui::ET_MOUSE_RELEASED:
-      last_mouse_event_was_move_ = false;
-      is_mouse_button_pressed_ = false;
-      // Release capture first, to avoid confusion if OnMouseReleased blocks.
-      if (auto_release_capture_ && native_widget_->HasCapture()) {
-        base::AutoReset<bool> resetter(&ignore_capture_loss_, true);
-        native_widget_->ReleaseCapture();
-      }
-      if (root_view)
-        root_view->OnMouseReleased(*event);
-      if ((event->flags() & ui::EF_IS_NON_CLIENT) == 0 &&
-          // If none of the "normal" buttons are pressed, this event may be from
-          // one of the newer mice that have buttons bound to browser forward
-          // back actions. Don't squelch the event and let the default handler
-          // process it.
-          (event->flags() &
-           (ui::EF_LEFT_MOUSE_BUTTON | ui::EF_MIDDLE_MOUSE_BUTTON |
-            ui::EF_RIGHT_MOUSE_BUTTON)) != 0)
-        event->SetHandled();
-      return;
-
-    case ui::ET_MOUSE_MOVED:
-    case ui::ET_MOUSE_DRAGGED:
-      if (native_widget_->HasCapture() && is_mouse_button_pressed_) {
-        last_mouse_event_was_move_ = false;
-        if (root_view)
-          root_view->OnMouseDragged(*event);
-      } else if (!last_mouse_event_was_move_ ||
-                 last_mouse_event_position_ != event->location()) {
-        last_mouse_event_position_ = event->location();
-        last_mouse_event_was_move_ = true;
-        if (root_view)
-          root_view->OnMouseMoved(*event);
-      }
-      return;
-
-    case ui::ET_MOUSE_EXITED:
-      last_mouse_event_was_move_ = false;
-      if (root_view)
-        root_view->OnMouseExited(*event);
-      return;
-
-    case ui::ET_MOUSEWHEEL:
-      if (root_view && root_view->OnMouseWheel(
-          static_cast<const ui::MouseWheelEvent&>(*event)))
-        event->SetHandled();
-      return;
-
-    default:
-      return;
-  }
 }
 
 void Widget::OnMouseCaptureLost() {
diff --git a/ui/webui/resources/css/roboto.css b/ui/webui/resources/css/roboto.css
index af0bdbc6a976..827bec2913ef 100644
--- a/ui/webui/resources/css/roboto.css
+++ b/ui/webui/resources/css/roboto.css
@@ -2,7 +2,7 @@
  * Use of this source code is governed by a BSD-style license that can be
  * found in the LICENSE file. */
 
-<if expr="not chromeos and not is_android">
+<if expr="is_android or not chromeos and not is_android">
 @font-face {
   font-family: 'Roboto';
   font-style: normal;
diff --git a/ui/webui/resources/webui_resources.grd b/ui/webui/resources/webui_resources.grd
index c48c0f22da36..90955f7af882 100644
--- a/ui/webui/resources/webui_resources.grd
+++ b/ui/webui/resources/webui_resources.grd
@@ -135,12 +135,12 @@ without changes to the corresponding grd file. -->
                use_base_dir="false" type="BINDATA" compress="gzip"
                preprocess="true" />
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="cr_components/cr_components_images.grdp" />
         <part file="cr_elements_images.grdp" />
       </if>
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="cr_components/cr_components_resources_v3.grdp" />
         <part file="cr_elements_resources_v3.grdp" />
         <part file="cr_polymer_resources_v3.grdp" />
@@ -462,7 +462,7 @@ without changes to the corresponding grd file. -->
                    compress="gzip" />
       </if>
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="cr_components/cr_components_resources.grdp" />
         <part file="cr_elements_resources.grdp" />
         <part file="cr_polymer_resources.grdp" />
